<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/home/kevin/Documents/GitHub/limit-pocs/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='unexecuted'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  14 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  15 |     | <span class='neutral'> * For a generic mechanism see {ERC20PresetMinterPauser}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The default value of {decimals} is 18. To change this, you should override</span>
  22 |     | <span class='neutral'> * this function so it returns a different value.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  25 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  26 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  27 |     | <span class='neutral'> * applications.</span>
  28 |     | <span class='neutral'> *</span>
  29 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  30 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  31 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  32 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  33 |     | <span class='neutral'> *</span>
  34 |     | <span class='neutral'> * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}</span>
  35 |     | <span class='neutral'> * functions have been added to mitigate the well-known issues around setting</span>
  36 |     | <span class='neutral'> * allowances. See {IERC20-approve}.</span>
  37 |     | <span class='neutral'> */</span>
  38 |     | <span class='unexecuted'>contract ERC20 is Context, IERC20, IERC20Metadata {</span>
  39 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    string private _name;</span>
  46 |     | <span class='neutral'>    string private _symbol;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  52 |     | <span class='neutral'>     * construction.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_) {</span>
  55 |     | <span class='unexecuted'>        _name = name_;</span>
  56 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  61 |     | <span class='neutral'>     */</span>
  62 | *   | <span class='executed'>    function name() public view virtual override returns (string memory) {</span>
  63 |     | <span class='unexecuted'>        return _name;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  68 |     | <span class='neutral'>     * name.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  71 |     | <span class='unexecuted'>        return _symbol;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  76 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  77 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  80 |     | <span class='neutral'>     * Ether and Wei. This is the default value returned by this function, unless</span>
  81 |     | <span class='neutral'>     * it&#39;s overridden.</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  84 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  85 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
  88 |     | <span class='unexecuted'>        return 18;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  93 |     | <span class='neutral'>     */</span>
  94 | *   | <span class='executed'>    function totalSupply() public view virtual override returns (uint256) {</span>
  95 |     | <span class='unexecuted'>        return _totalSupply;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 | *   | <span class='executed'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 102 | *   | <span class='executed'>        return _balances[account];</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * Requirements:</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 111 |     | <span class='neutral'>     * - the caller must have a balance of at least `amount`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
 114 |     | <span class='neutral'>        address owner = _msgSender();</span>
 115 |     | <span class='unexecuted'>        _transfer(owner, to, amount);</span>
 116 |     | <span class='neutral'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 121 |     | <span class='neutral'>     */</span>
 122 | *   | <span class='executed'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 123 | *   | <span class='executed'>        return _allowances[owner][spender];</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span>
 130 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * Requirements:</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 135 |     | <span class='neutral'>     */</span>
 136 | *   | <span class='executed'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 137 |     | <span class='neutral'>        address owner = _msgSender();</span>
 138 | *   | <span class='executed'>        _approve(owner, spender, amount);</span>
 139 | *   | <span class='executed'>        return true;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 144 |     | <span class='neutral'>     *</span>
 145 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 146 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 149 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Requirements:</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 154 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 155 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 156 |     | <span class='neutral'>     * `amount`.</span>
 157 |     | <span class='neutral'>     */</span>
 158 | *   | <span class='executed'>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 159 |     | <span class='neutral'>        address spender = _msgSender();</span>
 160 | *   | <span class='executed'>        _spendAllowance(from, spender, amount);</span>
 161 | *   | <span class='executed'>        _transfer(from, to, amount);</span>
 162 | *   | <span class='executed'>        return true;</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    /**</span>
 166 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 169 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 170 |     | <span class='neutral'>     *</span>
 171 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 172 |     | <span class='neutral'>     *</span>
 173 |     | <span class='neutral'>     * Requirements:</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 178 |     | <span class='neutral'>        address owner = _msgSender();</span>
 179 |     | <span class='unexecuted'>        _approve(owner, spender, allowance(owner, spender) + addedValue);</span>
 180 |     | <span class='neutral'>        return true;</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /**</span>
 184 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 185 |     | <span class='neutral'>     *</span>
 186 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 187 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 188 |     | <span class='neutral'>     *</span>
 189 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 190 |     | <span class='neutral'>     *</span>
 191 |     | <span class='neutral'>     * Requirements:</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 194 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 195 |     | <span class='neutral'>     * `subtractedValue`.</span>
 196 |     | <span class='neutral'>     */</span>
 197 |     | <span class='unexecuted'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 198 |     | <span class='neutral'>        address owner = _msgSender();</span>
 199 |     | <span class='unexecuted'>        uint256 currentAllowance = allowance(owner, spender);</span>
 200 | *   | <span class='executed'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 201 |     | <span class='neutral'>        unchecked {</span>
 202 |     | <span class='unexecuted'>            _approve(owner, spender, currentAllowance - subtractedValue);</span>
 203 |     | <span class='neutral'>        }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>        return true;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /**</span>
 209 |     | <span class='neutral'>     * @dev Moves `amount` of tokens from `from` to `to`.</span>
 210 |     | <span class='neutral'>     *</span>
 211 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 212 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 213 |     | <span class='neutral'>     *</span>
 214 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 215 |     | <span class='neutral'>     *</span>
 216 |     | <span class='neutral'>     * Requirements:</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 219 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 220 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 221 |     | <span class='neutral'>     */</span>
 222 | *   | <span class='executed'>    function _transfer(address from, address to, uint256 amount) internal virtual {</span>
 223 | *   | <span class='executed'>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 224 | *   | <span class='executed'>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>        _beforeTokenTransfer(from, to, amount);</span>
 227 |     | <span class='neutral'></span>
 228 | *   | <span class='executed'>        uint256 fromBalance = _balances[from];</span>
 229 | *   | <span class='executed'>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 230 |     | <span class='neutral'>        unchecked {</span>
 231 | *   | <span class='executed'>            _balances[from] = fromBalance - amount;</span>
 232 |     | <span class='neutral'>            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by</span>
 233 |     | <span class='neutral'>            // decrementing then incrementing.</span>
 234 | *   | <span class='executed'>            _balances[to] += amount;</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'></span>
 237 | *   | <span class='executed'>        emit Transfer(from, to, amount);</span>
 238 |     | <span class='neutral'></span>
 239 | *   | <span class='executed'>        _afterTokenTransfer(from, to, amount);</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 243 |     | <span class='neutral'>     * the total supply.</span>
 244 |     | <span class='neutral'>     *</span>
 245 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 246 |     | <span class='neutral'>     *</span>
 247 |     | <span class='neutral'>     * Requirements:</span>
 248 |     | <span class='neutral'>     *</span>
 249 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 250 |     | <span class='neutral'>     */</span>
 251 | *   | <span class='executed'>    function _mint(address account, uint256 amount) internal virtual {</span>
 252 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), account, amount);</span>
 255 |     | <span class='neutral'></span>
 256 | *   | <span class='executed'>        _totalSupply += amount;</span>
 257 |     | <span class='neutral'>        unchecked {</span>
 258 |     | <span class='neutral'>            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.</span>
 259 | *   | <span class='executed'>            _balances[account] += amount;</span>
 260 |     | <span class='neutral'>        }</span>
 261 | *   | <span class='executed'>        emit Transfer(address(0), account, amount);</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        _afterTokenTransfer(address(0), account, amount);</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /**</span>
 267 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 268 |     | <span class='neutral'>     * total supply.</span>
 269 |     | <span class='neutral'>     *</span>
 270 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 271 |     | <span class='neutral'>     *</span>
 272 |     | <span class='neutral'>     * Requirements:</span>
 273 |     | <span class='neutral'>     *</span>
 274 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 275 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 276 |     | <span class='neutral'>     */</span>
 277 | *   | <span class='executed'>    function _burn(address account, uint256 amount) internal virtual {</span>
 278 |     | <span class='unexecuted'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>        _beforeTokenTransfer(account, address(0), amount);</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='unexecuted'>        uint256 accountBalance = _balances[account];</span>
 283 |     | <span class='unexecuted'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 284 |     | <span class='neutral'>        unchecked {</span>
 285 |     | <span class='unexecuted'>            _balances[account] = accountBalance - amount;</span>
 286 |     | <span class='neutral'>            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.</span>
 287 |     | <span class='unexecuted'>            _totalSupply -= amount;</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='unexecuted'>        emit Transfer(account, address(0), amount);</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>        _afterTokenTransfer(account, address(0), amount);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    /**</span>
 296 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 297 |     | <span class='neutral'>     *</span>
 298 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 299 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 300 |     | <span class='neutral'>     *</span>
 301 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 302 |     | <span class='neutral'>     *</span>
 303 |     | <span class='neutral'>     * Requirements:</span>
 304 |     | <span class='neutral'>     *</span>
 305 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 306 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 307 |     | <span class='neutral'>     */</span>
 308 | *   | <span class='executed'>    function _approve(address owner, address spender, uint256 amount) internal virtual {</span>
 309 | *   | <span class='executed'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 310 | *   | <span class='executed'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 311 |     | <span class='neutral'></span>
 312 | *   | <span class='executed'>        _allowances[owner][spender] = amount;</span>
 313 | *   | <span class='executed'>        emit Approval(owner, spender, amount);</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    /**</span>
 317 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span>
 318 |     | <span class='neutral'>     *</span>
 319 |     | <span class='neutral'>     * Does not update the allowance amount in case of infinite allowance.</span>
 320 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 321 |     | <span class='neutral'>     *</span>
 322 |     | <span class='neutral'>     * Might emit an {Approval} event.</span>
 323 |     | <span class='neutral'>     */</span>
 324 | *   | <span class='executed'>    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {</span>
 325 | *   | <span class='executed'>        uint256 currentAllowance = allowance(owner, spender);</span>
 326 | *   | <span class='executed'>        if (currentAllowance != type(uint256).max) {</span>
 327 | *   | <span class='executed'>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 328 |     | <span class='neutral'>            unchecked {</span>
 329 | *   | <span class='executed'>                _approve(owner, spender, currentAllowance - amount);</span>
 330 |     | <span class='neutral'>            }</span>
 331 |     | <span class='neutral'>        }</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>    /**</span>
 335 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 336 |     | <span class='neutral'>     * minting and burning.</span>
 337 |     | <span class='neutral'>     *</span>
 338 |     | <span class='neutral'>     * Calling conditions:</span>
 339 |     | <span class='neutral'>     *</span>
 340 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 341 |     | <span class='neutral'>     * will be transferred to `to`.</span>
 342 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 343 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 344 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 345 |     | <span class='neutral'>     *</span>
 346 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 347 |     | <span class='neutral'>     */</span>
 348 |     | <span class='unexecuted'>    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>    /**</span>
 351 |     | <span class='neutral'>     * @dev Hook that is called after any transfer of tokens. This includes</span>
 352 |     | <span class='neutral'>     * minting and burning.</span>
 353 |     | <span class='neutral'>     *</span>
 354 |     | <span class='neutral'>     * Calling conditions:</span>
 355 |     | <span class='neutral'>     *</span>
 356 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 357 |     | <span class='neutral'>     * has been transferred to `to`.</span>
 358 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens have been minted for `to`.</span>
 359 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens have been burned.</span>
 360 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 361 |     | <span class='neutral'>     *</span>
 362 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 363 |     | <span class='neutral'>     */</span>
 364 |     | <span class='neutral'>    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 365 |     | <span class='neutral'>}</span>
 366 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../ERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../../utils/Context.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev Extension of {ERC20} that allows token holders to destroy both their own</span>
 11 |     | <span class='neutral'> * tokens and those that they have an allowance for, in a way that can be</span>
 12 |     | <span class='neutral'> * recognized off-chain (via event analysis).</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='neutral'>abstract contract ERC20Burnable is Context, ERC20 {</span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from the caller.</span>
 17 |     | <span class='neutral'>     *</span>
 18 |     | <span class='neutral'>     * See {ERC20-_burn}.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='unexecuted'>    function burn(uint256 amount) public virtual {</span>
 21 |     | <span class='unexecuted'>        _burn(_msgSender(), amount);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, deducting from the caller&#39;s</span>
 26 |     | <span class='neutral'>     * allowance.</span>
 27 |     | <span class='neutral'>     *</span>
 28 |     | <span class='neutral'>     * See {ERC20-_burn} and {ERC20-allowance}.</span>
 29 |     | <span class='neutral'>     *</span>
 30 |     | <span class='neutral'>     * Requirements:</span>
 31 |     | <span class='neutral'>     *</span>
 32 |     | <span class='neutral'>     * - the caller must have allowance for ``accounts``&#39;s tokens of at least</span>
 33 |     | <span class='neutral'>     * `amount`.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='unexecuted'>    function burnFrom(address account, uint256 amount) public virtual {</span>
 36 |     | <span class='unexecuted'>        _spendAllowance(account, _msgSender(), amount);</span>
 37 |     | <span class='unexecuted'>        _burn(account, amount);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * _Available since v4.1._</span>
 12 |     | <span class='neutral'> */</span>
 13 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/node_modules/@openzeppelin/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 |     | <span class='neutral'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/EchidnaPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// import &#39;./interfaces/ILimitPool.sol&#39;;</span>
   5 |     | <span class='neutral'>// import &#39;./interfaces/ILimitPoolManager.sol&#39;;</span>
   6 |     | <span class='neutral'>// import &#39;./interfaces/ILimitPoolStructs.sol&#39;;</span>
   7 |     | <span class='neutral'>// import &#39;./base/storage/LimitPoolStorage.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./LimitPool.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./LimitPoolFactory.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./utils/LimitPoolManager.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./test/Token20.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./libraries/utils/SafeTransfers.sol&#39;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>// Fuzz LimitPool functionality</span>
  17 | *r  | <span class='executed'>contract EchidnaPool {</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    event Address(address a);</span>
  20 |     | <span class='neutral'>    event Price(uint160 price);</span>
  21 |     | <span class='neutral'>    event Prices(uint160 price0, uint160 price1);</span>
  22 |     | <span class='neutral'>    event LiquidityGlobal(uint128 liq0Before, uint128 liq1Before, uint128 liq0After, uint128 liq1After);</span>
  23 |     | <span class='neutral'>    event Liquidity(uint128 liq0Before, uint128 liq1Before, uint128 liq0After, uint128 liq1After);</span>
  24 |     | <span class='neutral'>    event LiquidityDelta(int128 liqLowerBefore, int128 liqUpperBefore, int128 liqLowerAfter, int128 liqUperAfter);</span>
  25 |     | <span class='neutral'>    event Amount(uint256 amt);</span>
  26 |     | <span class='neutral'>    event PassedMint();</span>
  27 |     | <span class='neutral'>    event PassedBurn();</span>
  28 |     | <span class='neutral'>    event PositionTicks(int24 lower, int24 upper);</span>
  29 |     | <span class='neutral'>    event BurnTicks(int24 lower, int24 upper, bool positionExists);</span>
  30 |     | <span class='neutral'>    event LiquidityMinted(uint256 amount, uint256 tokenAmount, bool zeroForOne);</span>
  31 |     | <span class='neutral'>    event PositionCreated(bool isCreated);</span>
  32 |     | <span class='neutral'></span>
  33 | *   | <span class='executed'>    LimitPoolFactory public factory;</span>
  34 | *   | <span class='executed'>    address public implementation;</span>
  35 | *   | <span class='executed'>    LimitPoolManager public manager;</span>
  36 | *   | <span class='executed'>    LimitPool public pool;</span>
  37 | *   | <span class='executed'>    Token20 public tokenIn;</span>
  38 | *   | <span class='executed'>    Token20 public tokenOut;</span>
  39 | *r  | <span class='executed'>    Position[] public positions;</span>
  40 |     | <span class='neutral'>    int16 tickSpacing;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    struct LiquidityDeltaValues {</span>
  43 |     | <span class='neutral'>        int128 liquidityDeltaLowerBefore;</span>
  44 |     | <span class='neutral'>        int128 liquidityDeltaUpperBefore;</span>
  45 |     | <span class='neutral'>        int128 liquidityDeltaLowerAfter;</span>
  46 |     | <span class='neutral'>        int128 liquidityDeltaUpperAfter;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    struct PoolValues {</span>
  50 |     | <span class='neutral'>        uint160 price0Before;</span>
  51 |     | <span class='neutral'>        uint128 liquidity0Before;</span>
  52 |     | <span class='neutral'>        uint128 liquidityGlobal0Before;</span>
  53 |     | <span class='neutral'>        uint160 price1Before;</span>
  54 |     | <span class='neutral'>        uint128 liquidity1Before;</span>
  55 |     | <span class='neutral'>        uint128 liquidityGlobal1Before;</span>
  56 |     | <span class='neutral'>        uint160 price0After;</span>
  57 |     | <span class='neutral'>        uint128 liquidity0After;</span>
  58 |     | <span class='neutral'>        uint128 liquidityGlobal0After;</span>
  59 |     | <span class='neutral'>        uint160 price1After;</span>
  60 |     | <span class='neutral'>        uint128 liquidity1After;</span>
  61 |     | <span class='neutral'>        uint128 liquidityGlobal1After;</span>
  62 |     | <span class='neutral'>        </span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    struct SwapCallbackData {</span>
  66 |     | <span class='neutral'>        address sender;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    struct Position {</span>
  70 |     | <span class='neutral'>        address owner;</span>
  71 |     | <span class='neutral'>        int24 lower;</span>
  72 |     | <span class='neutral'>        int24 upper;</span>
  73 |     | <span class='neutral'>        bool zeroForOne;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    modifier tickPreconditions(int24 lower, int24 upper) {</span>
  77 | *r  | <span class='executed'>        require(lower &lt; upper);</span>
  78 | *r  | <span class='executed'>        require(upper &lt; 887272);</span>
  79 | *r  | <span class='executed'>        require(lower &gt; -887272);</span>
  80 | *   | <span class='executed'>        require(lower % tickSpacing == 0);</span>
  81 |     | <span class='unexecuted'>        require(upper % tickSpacing == 0);</span>
  82 |     | <span class='neutral'>        _;</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='unexecuted'>    constructor() {</span>
  85 |     | <span class='unexecuted'>        manager = new LimitPoolManager();</span>
  86 |     | <span class='unexecuted'>        factory = new LimitPoolFactory(address(manager));</span>
  87 |     | <span class='unexecuted'>        implementation = address(new LimitPool(address(factory)));</span>
  88 |     | <span class='unexecuted'>        manager.enableImplementation(bytes32(0x0), address(implementation));</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>        tokenIn = new Token20(&quot;IN&quot;, &quot;IN&quot;, 18);</span>
  91 |     | <span class='unexecuted'>        tokenOut = new Token20(&quot;OUT&quot;, &quot;OUT&quot;, 18);</span>
  92 |     | <span class='unexecuted'>        pool =  LimitPool(factory.createLimitPool(bytes32(0x0), address(tokenIn), address(tokenOut), 10, 79228162514264337593543950336));</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 | *   | <span class='executed'>    function mint(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {</span>
  96 |     | <span class='neutral'>        // PRE CONDITIONS</span>
  97 |     | <span class='unexecuted'>        mintAndApprove();</span>
  98 |     | <span class='unexecuted'>        require(amount &gt; 0);</span>
  99 |     | <span class='neutral'>        PoolValues memory poolValues;</span>
 100 |     | <span class='unexecuted'>        (poolValues.price0Before, poolValues.liquidity0Before, poolValues.liquidityGlobal0Before,,,,) = pool.pool0();</span>
 101 |     | <span class='unexecuted'>        (poolValues.price1Before, poolValues.liquidity1Before, poolValues.liquidityGlobal1Before,,,,) = pool.pool1();</span>
 102 |     | <span class='neutral'>        </span>
 103 |     | <span class='neutral'>            </span>
 104 |     | <span class='neutral'>        ILimitPoolStructs.MintParams memory params;</span>
 105 |     | <span class='unexecuted'>        params.to = msg.sender;</span>
 106 |     | <span class='unexecuted'>        params.refundTo = msg.sender;</span>
 107 |     | <span class='unexecuted'>        params.amount = amount;</span>
 108 |     | <span class='neutral'>        params.mintPercent = 0;</span>
 109 |     | <span class='unexecuted'>        params.lower = lower;</span>
 110 |     | <span class='unexecuted'>        params.upper = upper;</span>
 111 |     | <span class='unexecuted'>        params.zeroForOne = zeroForOne;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        // Get the ticks the position will be minted with rather than what was passed directly by fuzzer</span>
 114 |     | <span class='neutral'>        // This is so the we can properly compare before and after mint states of particular ticks.</span>
 115 |     | <span class='neutral'>        bool posCreated;</span>
 116 |     | <span class='unexecuted'>        (lower, upper, posCreated) = pool.getResizedTicksForMint(params);</span>
 117 |     | <span class='unexecuted'>        emit PositionTicks(lower, upper);</span>
 118 |     | <span class='unexecuted'>        emit PositionCreated(posCreated);</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>        LiquidityDeltaValues memory values;</span>
 121 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 122 |     | <span class='unexecuted'>            (,values.liquidityDeltaLowerBefore) = pool.ticks0(lower);</span>
 123 |     | <span class='unexecuted'>            (,values.liquidityDeltaUpperBefore) = pool.ticks0(upper);</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>        else {</span>
 126 |     | <span class='unexecuted'>            (,values.liquidityDeltaLowerBefore) = pool.ticks1(lower);</span>
 127 |     | <span class='unexecuted'>            (,values.liquidityDeltaUpperBefore) = pool.ticks1(upper);</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        // ACTION </span>
 131 |     | <span class='unexecuted'>        pool.mint(params);</span>
 132 |     | <span class='unexecuted'>        if (posCreated) positions.push(Position(msg.sender, lower, upper, zeroForOne));</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>        (poolValues.price0After, poolValues.liquidity0After, poolValues.liquidityGlobal0After,,,,) = pool.pool0();</span>
 135 |     | <span class='unexecuted'>        (poolValues.price1After, poolValues.liquidity1After, poolValues.liquidityGlobal1After,,,,) = pool.pool1();</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 138 |     | <span class='unexecuted'>            (,values.liquidityDeltaLowerAfter) = pool.ticks0(lower);</span>
 139 |     | <span class='unexecuted'>            (,values.liquidityDeltaUpperAfter) = pool.ticks0(upper);</span>
 140 |     | <span class='neutral'>        }</span>
 141 |     | <span class='neutral'>        else {</span>
 142 |     | <span class='unexecuted'>            (,values.liquidityDeltaLowerAfter) = pool.ticks1(lower);</span>
 143 |     | <span class='unexecuted'>            (,values.liquidityDeltaUpperAfter) = pool.ticks1(upper);</span>
 144 |     | <span class='neutral'>        }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>        emit Prices(poolValues.price0After, poolValues.price1After);</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>        // POST CONDITIONS</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>        // Ensure prices have not crossed</span>
 151 |     | <span class='unexecuted'>        assert(poolValues.price0After &gt;= poolValues.price1After);</span>
 152 |     | <span class='unexecuted'>        if (posCreated) {</span>
 153 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
 154 |     | <span class='unexecuted'>            assert(lower &lt; upper);</span>
 155 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
 156 |     | <span class='unexecuted'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'>        </span>
 159 |     | <span class='neutral'>        </span>
 160 |     | <span class='unexecuted'>        emit LiquidityGlobal(poolValues.liquidityGlobal0Before, poolValues.liquidityGlobal1Before, poolValues.liquidityGlobal0After, poolValues.liquidityGlobal1After);</span>
 161 |     | <span class='unexecuted'>        emit Liquidity(poolValues.liquidity0Before, poolValues.liquidity1Before, poolValues.liquidity0After, poolValues.liquidity1After);</span>
 162 |     | <span class='unexecuted'>        emit LiquidityDelta(values.liquidityDeltaLowerBefore, values.liquidityDeltaUpperBefore, values.liquidityDeltaLowerAfter, values.liquidityDeltaUpperAfter);</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 165 |     | <span class='neutral'>            // Ensure liquidity does not decrease on mint</span>
 166 |     | <span class='unexecuted'>            assert(poolValues.liquidityGlobal0After &gt;= poolValues.liquidityGlobal0Before);</span>
 167 |     | <span class='neutral'>            // Ensure pool.liquity is incremented when undercutting</span>
 168 |     | <span class='unexecuted'>            if (poolValues.price0After &lt; poolValues.price0Before) {</span>
 169 |     | <span class='unexecuted'>                assert(poolValues.liquidity0After &gt; 0);</span>
 170 |     | <span class='neutral'>            }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>            // Doesn&#39;t hold due to insertSingle stashing pool liquidity on tick to save</span>
 173 |     | <span class='neutral'>            // if (posCreated) {</span>
 174 |     | <span class='neutral'>            //     assert(values.liquidityDeltaLowerAfter &gt;= values.liquidityDeltaLowerBefore);</span>
 175 |     | <span class='neutral'>            //     assert(values.liquidityDeltaUpperAfter &lt;= values.liquidityDeltaUpperBefore);</span>
 176 |     | <span class='neutral'>            // }</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>        else {</span>
 179 |     | <span class='neutral'>            // Ensure liquidity does not decrease on mint</span>
 180 |     | <span class='unexecuted'>            assert(poolValues.liquidityGlobal1After &gt;= poolValues.liquidityGlobal1Before);</span>
 181 |     | <span class='neutral'>            // Ensure pool.liquity is incremented when undercutting</span>
 182 |     | <span class='unexecuted'>            if (poolValues.price1After &gt; poolValues.price1Before) {</span>
 183 |     | <span class='unexecuted'>                assert(poolValues.liquidity1After &gt; 0);</span>
 184 |     | <span class='neutral'>            }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>            // if (posCreated) {</span>
 187 |     | <span class='neutral'>            //     assert(values.liquidityDeltaUpperAfter &gt;= values.liquidityDeltaUpperBefore);</span>
 188 |     | <span class='neutral'>            //     assert(values.liquidityDeltaLowerAfter &lt;= values.liquidityDeltaLowerBefore);</span>
 189 |     | <span class='neutral'>            // }</span>
 190 |     | <span class='neutral'>            </span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 | *   | <span class='executed'>    function swap(uint160 priceLimit, uint128 amount, bool exactIn, bool zeroForOne) public {</span>
 195 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 196 | *   | <span class='executed'>        mintAndApprove();</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>        // ACTION</span>
 199 |     | <span class='neutral'>        ILimitPoolStructs.SwapParams memory params;</span>
 200 | *   | <span class='executed'>        params.to = msg.sender;</span>
 201 | *   | <span class='executed'>        params.priceLimit = priceLimit;</span>
 202 | *   | <span class='executed'>        params.amount = amount;</span>
 203 | *   | <span class='executed'>        params.exactIn = exactIn;</span>
 204 | *   | <span class='executed'>        params.zeroForOne = zeroForOne;</span>
 205 | *   | <span class='executed'>        params.callbackData = abi.encodePacked(address(this));</span>
 206 |     | <span class='neutral'></span>
 207 | *   | <span class='executed'>        pool.swap(params);</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>        // POST CONDITIONS</span>
 210 | *   | <span class='executed'>        (uint160 price0,,,,,,) = pool.pool0();</span>
 211 | *   | <span class='executed'>        (uint160 price1,,,,,,) = pool.pool1();</span>
 212 | *   | <span class='executed'>        emit Prices(price0, price1);</span>
 213 | *   | <span class='executed'>        assert(price0 &gt;= price1);</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 | *   | <span class='executed'>    function burn(int24 claim, uint256 positionIndex, uint128 burnPercent) public {</span>
 217 |     | <span class='neutral'>        // PRE CONDITIONS </span>
 218 | *r  | <span class='executed'>        require(positionIndex &lt; positions.length);</span>
 219 |     | <span class='unexecuted'>        Position memory pos = positions[positionIndex];</span>
 220 |     | <span class='unexecuted'>        require(claim &gt;= pos.lower &amp;&amp; claim &lt;= pos.upper);</span>
 221 |     | <span class='unexecuted'>        require(claim % tickSpacing == 0);</span>
 222 |     | <span class='neutral'>        </span>
 223 |     | <span class='neutral'>        ILimitPoolStructs.BurnParams memory params;</span>
 224 |     | <span class='unexecuted'>        params.to = pos.owner;</span>
 225 |     | <span class='neutral'>        // TODO: allow for variable burn percentages</span>
 226 |     | <span class='unexecuted'>        params.burnPercent = burnPercent == 1e38 ? burnPercent : _between(burnPercent, 1e36, 1e38); //1e38;</span>
 227 |     | <span class='unexecuted'>        params.lower = pos.lower;</span>
 228 |     | <span class='unexecuted'>        params.claim = claim;</span>
 229 |     | <span class='unexecuted'>        params.upper = pos.upper;</span>
 230 |     | <span class='unexecuted'>        params.zeroForOne = pos.zeroForOne;</span>
 231 |     | <span class='neutral'>        </span>
 232 |     | <span class='unexecuted'>        emit PositionTicks(pos.lower, pos.upper);</span>
 233 |     | <span class='unexecuted'>        (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);</span>
 234 |     | <span class='unexecuted'>        emit BurnTicks(lower, upper, positionExists);</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>        // ACTION</span>
 237 |     | <span class='unexecuted'>        pool.burn(params);</span>
 238 |     | <span class='unexecuted'>        if (!positionExists) {</span>
 239 |     | <span class='unexecuted'>            positions[positionIndex] = positions[positions.length - 1];</span>
 240 |     | <span class='unexecuted'>            delete positions[positions.length - 1];</span>
 241 |     | <span class='neutral'>        }</span>
 242 |     | <span class='neutral'>        else {</span>
 243 |     | <span class='neutral'>            // Update position data in array if not fully burned</span>
 244 |     | <span class='unexecuted'>            positions[positionIndex] = Position(pos.owner, lower, upper, pos.zeroForOne);</span>
 245 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
 246 |     | <span class='unexecuted'>            assert(lower &lt; upper);</span>
 247 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
 248 |     | <span class='unexecuted'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
 249 |     | <span class='neutral'>        }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>        // POST CONDITIONS</span>
 252 |     | <span class='unexecuted'>        (uint160 price0,,,,,,) = pool.pool0();</span>
 253 |     | <span class='unexecuted'>        (uint160 price1,,,,,,) = pool.pool1();</span>
 254 |     | <span class='unexecuted'>        emit Prices(price0, price1);</span>
 255 |     | <span class='unexecuted'>        assert(price0 &gt;= price1);</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 | *   | <span class='executed'>    function mintThenBurnZeroLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {</span>
 259 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 260 |     | <span class='unexecuted'>        mintAndApprove();</span>
 261 |     | <span class='unexecuted'>        (uint160 price0Before,/*liquidity*/,uint128 liquidityGlobal0Before,,,,) = pool.pool0();</span>
 262 |     | <span class='unexecuted'>        (uint160 price1Before,/*liquidity*/,uint128 liquidityGlobal1Before,,,,) = pool.pool1();</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>        // ACTION </span>
 265 |     | <span class='unexecuted'>        mint(amount, zeroForOne, lower, upper);</span>
 266 |     | <span class='unexecuted'>        emit PassedMint();</span>
 267 |     | <span class='unexecuted'>        burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);</span>
 268 |     | <span class='unexecuted'>        emit PassedBurn();</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>        // POST CONDITIONS</span>
 271 |     | <span class='unexecuted'>        (uint160 price0After,/*liquidity*/,uint128 liquidityGlobal0After,,,,) = pool.pool0();</span>
 272 |     | <span class='unexecuted'>        (uint160 price1After,/*liquidity*/,uint128 liquidityGlobal1After,,,,) = pool.pool1();</span>
 273 |     | <span class='unexecuted'>        emit Prices(price0After, price1After);</span>
 274 |     | <span class='unexecuted'>        assert(price0After &gt;= price1After);</span>
 275 |     | <span class='unexecuted'>        emit LiquidityGlobal(liquidityGlobal0Before, liquidityGlobal1Before, liquidityGlobal0After, liquidityGlobal1After);</span>
 276 |     | <span class='unexecuted'>        assert((liquidityGlobal0After == liquidityGlobal0Before) &amp;&amp; (liquidityGlobal1After == liquidityGlobal1Before));</span>
 277 |     | <span class='neutral'>        </span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 | *   | <span class='executed'>     function poolsharkSwapCallback(</span>
 281 |     | <span class='neutral'>        int256 amount0Delta,</span>
 282 |     | <span class='neutral'>        int256 amount1Delta,</span>
 283 |     | <span class='neutral'>        bytes calldata data</span>
 284 | *   | <span class='executed'>    ) external {</span>
 285 | *   | <span class='executed'>        address token0 = LimitPool(pool).token0();</span>
 286 | *   | <span class='executed'>        address token1 = LimitPool(pool).token1();</span>
 287 |     | <span class='neutral'>        // SwapCallbackData memory _data = abi.decode(data, (SwapCallbackData));</span>
 288 | *   | <span class='executed'>        if (amount0Delta &lt; 0) {</span>
 289 | *   | <span class='executed'>            SafeTransfers.transferInto(token0, address(pool), uint256(-amount0Delta));</span>
 290 |     | <span class='neutral'>        } else {</span>
 291 | *   | <span class='executed'>            SafeTransfers.transferInto(token1, address(pool), uint256(-amount1Delta));</span>
 292 |     | <span class='neutral'>        }</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 | *   | <span class='executed'>    function mintAndApprove() internal {</span>
 296 |     | <span class='neutral'>        // TODO: can make token mints to be in between some range</span>
 297 | *   | <span class='executed'>        tokenIn.mint(msg.sender, 100000000000 ether);</span>
 298 | *   | <span class='executed'>        tokenOut.mint(msg.sender, 100000000000 ether);</span>
 299 | *   | <span class='executed'>        tokenIn.mint(address(this), 100000000000 ether);</span>
 300 | *   | <span class='executed'>        tokenOut.mint(address(this), 100000000000 ether);</span>
 301 | *   | <span class='executed'>        tokenIn.approve(address(pool), type(uint256).max);</span>
 302 | *   | <span class='executed'>        tokenOut.approve(address(pool), type(uint256).max);</span>
 303 |     | <span class='neutral'>    }</span>
 304 |     | <span class='neutral'></span>
 305 | *   | <span class='executed'>    function _between(uint128 val, uint low, uint high) internal pure returns(uint128) {</span>
 306 |     | <span class='unexecuted'>        return uint128(low + (val % (high-low +1))); </span>
 307 |     | <span class='neutral'>    }</span>
 308 |     | <span class='neutral'></span>
 309 | *   | <span class='executed'>    function liquidityMintedBackcalculates(uint128 amount, bool zeroForOne, int24 lower, int24 upper) tickPreconditions(lower, upper) public {</span>
 310 |     | <span class='unexecuted'>        require(amount &gt; 1e5);</span>
 311 |     | <span class='unexecuted'>        ILimitPoolStructs.Immutables memory immutables = pool.immutables();</span>
 312 |     | <span class='unexecuted'>        uint256 priceLower = ConstantProduct.getPriceAtTick(lower, immutables);</span>
 313 |     | <span class='unexecuted'>        uint256 priceUpper = ConstantProduct.getPriceAtTick(upper, immutables);</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='unexecuted'>        uint256 liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
 316 |     | <span class='unexecuted'>            priceLower,</span>
 317 |     | <span class='unexecuted'>            priceUpper,</span>
 318 |     | <span class='unexecuted'>            zeroForOne ? priceLower : priceUpper,</span>
 319 |     | <span class='unexecuted'>            zeroForOne ? 0 : uint256(amount),</span>
 320 |     | <span class='unexecuted'>            zeroForOne ? uint256(amount) : 0</span>
 321 |     | <span class='neutral'>        );</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='unexecuted'>        (uint256 token0Amount, uint256 token1Amount) = ConstantProduct.getAmountsForLiquidity(</span>
 324 |     | <span class='unexecuted'>            priceLower,</span>
 325 |     | <span class='unexecuted'>            priceUpper,</span>
 326 |     | <span class='unexecuted'>            zeroForOne ? priceLower : priceUpper,</span>
 327 |     | <span class='unexecuted'>            liquidityMinted,</span>
 328 |     | <span class='unexecuted'>            true</span>
 329 |     | <span class='neutral'>        );</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='unexecuted'>        if(zeroForOne) {</span>
 332 |     | <span class='unexecuted'>            emit LiquidityMinted(amount, token0Amount, zeroForOne);</span>
 333 |     | <span class='unexecuted'>            assert(isEqualWithinPercentage(amount, token0Amount, 100));</span>
 334 |     | <span class='neutral'>            </span>
 335 |     | <span class='neutral'>        }</span>
 336 |     | <span class='neutral'>        else {</span>
 337 |     | <span class='unexecuted'>            emit LiquidityMinted(amount, token1Amount, zeroForOne);</span>
 338 |     | <span class='unexecuted'>            assert(isEqualWithinPercentage(amount, token1Amount, 100));</span>
 339 |     | <span class='neutral'>        }</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>    }</span>
 342 |     | <span class='neutral'></span>
 343 |     | <span class='unexecuted'>    function isEqualWithinPercentage(uint256 a, uint256 b, uint256 percentage) internal pure returns (bool) {</span>
 344 |     | <span class='unexecuted'>        uint256 diff = a &gt; b ? a - b : b - a;</span>
 345 |     | <span class='unexecuted'>        uint256 maxDiff = a * percentage / 10000; // basis points </span>
 346 |     | <span class='neutral'></span>
 347 |     | <span class='unexecuted'>        return diff &lt;= maxDiff;</span>
 348 |     | <span class='neutral'>}</span>
 349 |     | <span class='neutral'>   </span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/LimitPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./interfaces/ILimitPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./interfaces/ILimitPoolManager.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./base/storage/LimitPoolStorage.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./base/storage/LimitPoolImmutables.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./base/structs/LimitPoolFactoryStructs.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./utils/LimitPoolErrors.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./libraries/pool/SwapCall.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./libraries/pool/QuoteCall.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./libraries/pool/MintCall.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./libraries/pool/BurnCall.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;./libraries/math/ConstantProduct.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;./libraries/solady/LibClone.sol&#39;;</span>
  16 |     | <span class='neutral'>import &#39;./external/openzeppelin/security/ReentrancyGuard.sol&#39;;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>/// @notice Poolshark Cover Pool Implementation</span>
  20 | *   | <span class='executed'>contract LimitPool is</span>
  21 |     | <span class='neutral'>    ILimitPool,</span>
  22 |     | <span class='neutral'>    LimitPoolStorage,</span>
  23 |     | <span class='neutral'>    LimitPoolImmutables,</span>
  24 |     | <span class='neutral'>    LimitPoolFactoryStructs,</span>
  25 |     | <span class='neutral'>    ReentrancyGuard</span>
  26 |     | <span class='neutral'>{</span>
  27 |     | <span class='neutral'>    event SimulateMint(bytes b);</span>
  28 |     | <span class='neutral'>    event SimulateMint(bytes4 b);</span>
  29 |     | <span class='neutral'>    event SimulateMint(bool b);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    modifier ownerOnly() {</span>
  32 |     | <span class='unexecuted'>        _onlyOwner();</span>
  33 |     | <span class='neutral'>        _;</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    modifier factoryOnly() {</span>
  37 |     | <span class='unexecuted'>        _onlyFactory();</span>
  38 |     | <span class='neutral'>        _;</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    modifier canoncialOnly() {</span>
  42 |     | <span class='unexecuted'>        _onlyCanoncialClones();</span>
  43 |     | <span class='unexecuted'>        _;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>    address public immutable original;</span>
  47 |     | <span class='unexecuted'>    address public immutable factory;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    constructor(</span>
  50 |     | <span class='neutral'>        address factory_</span>
  51 |     | <span class='neutral'>    ) {</span>
  52 |     | <span class='unexecuted'>        original = address(this);</span>
  53 |     | <span class='unexecuted'>        factory = factory_;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>    function initialize(</span>
  57 |     | <span class='neutral'>        uint160 startPrice</span>
  58 |     | <span class='neutral'>    ) external override </span>
  59 |     | <span class='neutral'>        nonReentrant</span>
  60 |     | <span class='neutral'>        factoryOnly</span>
  61 |     | <span class='neutral'>        canoncialOnly</span>
  62 |     | <span class='neutral'>    {</span>
  63 |     | <span class='neutral'>        // initialize state</span>
  64 |     | <span class='unexecuted'>        globalState = Ticks.initialize(</span>
  65 |     | <span class='unexecuted'>            tickMap,</span>
  66 |     | <span class='unexecuted'>            pool0,</span>
  67 |     | <span class='unexecuted'>            pool1,</span>
  68 |     | <span class='unexecuted'>            globalState,</span>
  69 |     | <span class='unexecuted'>            immutables(),</span>
  70 |     | <span class='unexecuted'>            startPrice</span>
  71 |     | <span class='neutral'>        );</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    // limitSwap</span>
  75 |     | <span class='unexecuted'>    function mint(</span>
  76 |     | <span class='neutral'>        MintParams memory params</span>
  77 |     | <span class='neutral'>    ) external override</span>
  78 |     | <span class='neutral'>        nonReentrant</span>
  79 |     | <span class='neutral'>        canoncialOnly</span>
  80 |     | <span class='neutral'>    {</span>
  81 |     | <span class='unexecuted'>        MintCache memory cache;</span>
  82 |     | <span class='neutral'>        {</span>
  83 |     | <span class='unexecuted'>            cache.state = globalState;</span>
  84 |     | <span class='unexecuted'>            cache.constants = immutables();</span>
  85 |     | <span class='unexecuted'>            cache.pool = params.zeroForOne ? pool0 : pool1;</span>
  86 |     | <span class='unexecuted'>            cache.swapPool = params.zeroForOne ? pool1 : pool0;</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='unexecuted'>        cache = MintCall.perform(</span>
  89 |     | <span class='neutral'>            params,</span>
  90 |     | <span class='neutral'>            cache,</span>
  91 |     | <span class='unexecuted'>            tickMap,</span>
  92 |     | <span class='unexecuted'>            params.zeroForOne ? pool0 : pool1,</span>
  93 |     | <span class='unexecuted'>            params.zeroForOne ? pool1 : pool0,</span>
  94 |     | <span class='unexecuted'>            params.zeroForOne ? ticks0 : ticks1,</span>
  95 |     | <span class='unexecuted'>            params.zeroForOne ? ticks1 : ticks0,</span>
  96 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1</span>
  97 |     | <span class='neutral'>        );</span>
  98 |     | <span class='unexecuted'>        globalState = cache.state;</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>    function getResizedTicksForMint(</span>
 102 |     | <span class='neutral'>        MintParams memory params</span>
 103 |     | <span class='unexecuted'>    ) external returns (int24 lower, int24 upper, bool positionCreated){</span>
 104 |     | <span class='unexecuted'>        MintCache memory cache;</span>
 105 |     | <span class='neutral'>        {</span>
 106 |     | <span class='unexecuted'>            cache.state = globalState;</span>
 107 |     | <span class='unexecuted'>            cache.constants = immutables();</span>
 108 |     | <span class='unexecuted'>            cache.pool = params.zeroForOne ? pool0 : pool1;</span>
 109 |     | <span class='unexecuted'>            cache.swapPool = params.zeroForOne ? pool1 : pool0;</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>        try MintCall.getResizedTicks(</span>
 113 |     | <span class='neutral'>            params,</span>
 114 |     | <span class='neutral'>            cache,</span>
 115 |     | <span class='unexecuted'>            tickMap,</span>
 116 |     | <span class='unexecuted'>            params.zeroForOne ? pool0 : pool1,</span>
 117 |     | <span class='unexecuted'>            params.zeroForOne ? pool1 : pool0,</span>
 118 |     | <span class='unexecuted'>            params.zeroForOne ? ticks0 : ticks1,</span>
 119 |     | <span class='unexecuted'>            params.zeroForOne ? ticks1 : ticks0,</span>
 120 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1</span>
 121 |     | <span class='neutral'>        ) {</span>
 122 |     | <span class='unexecuted'>        } catch (bytes memory data) {</span>
 123 |     | <span class='unexecuted'>            emit SimulateMint(data);</span>
 124 |     | <span class='neutral'>            bytes4 sig;</span>
 125 |     | <span class='neutral'>            assembly {</span>
 126 |     | <span class='unexecuted'>                sig := mload(add(data, 0x20))</span>
 127 |     | <span class='neutral'>            }</span>
 128 |     | <span class='neutral'>            </span>
 129 |     | <span class='neutral'>            // SimulateMint error</span>
 130 |     | <span class='unexecuted'>            if (sig == hex&quot;5cc1f67b&quot;) {</span>
 131 |     | <span class='unexecuted'>                (, lower, upper, positionCreated) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));</span>
 132 |     | <span class='neutral'>            }</span>
 133 |     | <span class='neutral'>            else {</span>
 134 |     | <span class='unexecuted'>                lower = -8388608;</span>
 135 |     | <span class='unexecuted'>                upper = -8388608;</span>
 136 |     | <span class='unexecuted'>                positionCreated = false;</span>
 137 |     | <span class='neutral'>            }</span>
 138 |     | <span class='neutral'>        }</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='unexecuted'>    function burn(</span>
 142 |     | <span class='neutral'>        BurnParams memory params</span>
 143 |     | <span class='neutral'>    ) external override </span>
 144 |     | <span class='neutral'>        nonReentrant</span>
 145 |     | <span class='neutral'>        canoncialOnly</span>
 146 |     | <span class='neutral'>    {</span>
 147 |     | <span class='unexecuted'>        if (params.to == address(0)) revert CollectToZeroAddress();</span>
 148 |     | <span class='unexecuted'>        BurnCache memory cache = BurnCache({</span>
 149 |     | <span class='neutral'>            state: globalState,</span>
 150 |     | <span class='unexecuted'>            position: params.zeroForOne ? positions0[msg.sender][params.lower][params.upper]</span>
 151 |     | <span class='unexecuted'>                                        : positions1[msg.sender][params.lower][params.upper],</span>
 152 |     | <span class='unexecuted'>            constants: immutables(),</span>
 153 |     | <span class='unexecuted'>            pool: params.zeroForOne ? pool0 : pool1</span>
 154 |     | <span class='neutral'>        });</span>
 155 |     | <span class='unexecuted'>        cache = BurnCall.perform(</span>
 156 |     | <span class='neutral'>            params, </span>
 157 |     | <span class='neutral'>            cache, </span>
 158 |     | <span class='unexecuted'>            tickMap,</span>
 159 |     | <span class='unexecuted'>            params.zeroForOne ? ticks0 : ticks1,</span>
 160 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1</span>
 161 |     | <span class='neutral'>        );</span>
 162 |     | <span class='unexecuted'>        if (params.zeroForOne) {</span>
 163 |     | <span class='unexecuted'>            pool0 = cache.pool;</span>
 164 |     | <span class='neutral'>        } else {</span>
 165 |     | <span class='unexecuted'>            pool1 = cache.pool;</span>
 166 |     | <span class='neutral'>        }</span>
 167 |     | <span class='unexecuted'>        globalState = cache.state;</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>    function getResizedTicksForBurn(</span>
 171 |     | <span class='neutral'>        BurnParams memory params</span>
 172 |     | <span class='unexecuted'>    ) external returns (int24 lower, int24 upper, bool positionExists){</span>
 173 |     | <span class='unexecuted'>        if (params.to == address(0)) revert CollectToZeroAddress();</span>
 174 |     | <span class='unexecuted'>        BurnCache memory cache = BurnCache({</span>
 175 |     | <span class='neutral'>            state: globalState,</span>
 176 |     | <span class='unexecuted'>            position: params.zeroForOne ? positions0[params.to][params.lower][params.upper]</span>
 177 |     | <span class='unexecuted'>                                        : positions1[params.to][params.lower][params.upper],</span>
 178 |     | <span class='unexecuted'>            constants: immutables(),</span>
 179 |     | <span class='unexecuted'>            pool: params.zeroForOne ? pool0 : pool1</span>
 180 |     | <span class='neutral'>        });</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='unexecuted'>        try BurnCall.getResizedTicks(</span>
 183 |     | <span class='neutral'>           params, </span>
 184 |     | <span class='neutral'>            cache, </span>
 185 |     | <span class='unexecuted'>            tickMap,</span>
 186 |     | <span class='unexecuted'>            params.zeroForOne ? ticks0 : ticks1,</span>
 187 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1</span>
 188 |     | <span class='neutral'>        ) {</span>
 189 |     | <span class='neutral'>        } catch (bytes memory data) {</span>
 190 |     | <span class='neutral'>            bytes4 sig;</span>
 191 |     | <span class='neutral'>            assembly {</span>
 192 |     | <span class='unexecuted'>                sig := mload(add(data, 0x20))</span>
 193 |     | <span class='neutral'>            }</span>
 194 |     | <span class='neutral'>            // SimulateBurn error</span>
 195 |     | <span class='unexecuted'>            if (sig == hex&quot;97dd6e0a&quot;) {</span>
 196 |     | <span class='unexecuted'>                (, lower, upper, positionExists) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));</span>
 197 |     | <span class='neutral'>            }</span>
 198 |     | <span class='neutral'>             else {</span>
 199 |     | <span class='neutral'>                lower = -8388608;</span>
 200 |     | <span class='neutral'>                upper = -8388608;</span>
 201 |     | <span class='neutral'>                positionExists = false;</span>
 202 |     | <span class='neutral'>            }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>            </span>
 205 |     | <span class='neutral'>        }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>    function swap(</span>
 211 |     | <span class='neutral'>        SwapParams memory params</span>
 212 |     | <span class='neutral'>    ) public override</span>
 213 |     | <span class='neutral'>        nonReentrant</span>
 214 |     | <span class='neutral'>        canoncialOnly</span>
 215 |     | <span class='neutral'>    returns (</span>
 216 |     | <span class='unexecuted'>        int256,</span>
 217 |     | <span class='unexecuted'>        int256</span>
 218 |     | <span class='neutral'>    ) </span>
 219 |     | <span class='neutral'>    {</span>
 220 |     | <span class='unexecuted'>        SwapCache memory cache;</span>
 221 |     | <span class='unexecuted'>        cache.pool = params.zeroForOne ? pool1 : pool0;</span>
 222 |     | <span class='unexecuted'>        cache.state = globalState;</span>
 223 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='unexecuted'>        return SwapCall.perform(</span>
 226 |     | <span class='unexecuted'>            params,</span>
 227 |     | <span class='unexecuted'>            cache,</span>
 228 |     | <span class='unexecuted'>            tickMap,</span>
 229 |     | <span class='unexecuted'>            params.zeroForOne ? pool1 : pool0,</span>
 230 |     | <span class='unexecuted'>            params.zeroForOne ? ticks1 : ticks0</span>
 231 |     | <span class='neutral'>        );</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='unexecuted'>    function quote(</span>
 235 |     | <span class='neutral'>        QuoteParams memory params</span>
 236 |     | <span class='neutral'>    ) external view override canoncialOnly returns (</span>
 237 |     | <span class='unexecuted'>        uint256 inAmount,</span>
 238 |     | <span class='unexecuted'>        uint256 outAmount,</span>
 239 |     | <span class='unexecuted'>        uint256 priceAfter</span>
 240 |     | <span class='neutral'>    ) {</span>
 241 |     | <span class='unexecuted'>        SwapCache memory cache;</span>
 242 |     | <span class='unexecuted'>        cache.pool = params.zeroForOne ? pool1 : pool0;</span>
 243 |     | <span class='unexecuted'>        cache.state = globalState;</span>
 244 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 245 |     | <span class='unexecuted'>        return QuoteCall.perform(</span>
 246 |     | <span class='unexecuted'>            params,</span>
 247 |     | <span class='unexecuted'>            cache,</span>
 248 |     | <span class='unexecuted'>            tickMap,</span>
 249 |     | <span class='unexecuted'>            params.zeroForOne ? ticks1 : ticks0</span>
 250 |     | <span class='neutral'>        );</span>
 251 |     | <span class='neutral'>    }</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='unexecuted'>    function snapshot(</span>
 254 |     | <span class='neutral'>       SnapshotParams memory params </span>
 255 |     | <span class='neutral'>    ) external view override canoncialOnly returns (</span>
 256 |     | <span class='unexecuted'>        Position memory</span>
 257 |     | <span class='neutral'>    ) {</span>
 258 |     | <span class='unexecuted'>        return Positions.snapshot(</span>
 259 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1,</span>
 260 |     | <span class='unexecuted'>            params.zeroForOne ? ticks0 : ticks1,</span>
 261 |     | <span class='unexecuted'>            tickMap,</span>
 262 |     | <span class='unexecuted'>            globalState,</span>
 263 |     | <span class='unexecuted'>            params.zeroForOne ? pool0 : pool1,</span>
 264 |     | <span class='unexecuted'>            UpdateParams(</span>
 265 |     | <span class='unexecuted'>                params.owner,</span>
 266 |     | <span class='unexecuted'>                params.owner,</span>
 267 |     | <span class='unexecuted'>                params.burnPercent,</span>
 268 |     | <span class='unexecuted'>                params.lower,</span>
 269 |     | <span class='unexecuted'>                params.upper,</span>
 270 |     | <span class='unexecuted'>                params.claim,</span>
 271 |     | <span class='unexecuted'>                params.zeroForOne</span>
 272 |     | <span class='neutral'>            ),</span>
 273 |     | <span class='unexecuted'>            immutables()</span>
 274 |     | <span class='neutral'>        );</span>
 275 |     | <span class='neutral'>    }</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>    function fees(</span>
 278 |     | <span class='neutral'>        uint16 protocolFee0,</span>
 279 |     | <span class='neutral'>        uint16 protocolFee1,</span>
 280 |     | <span class='neutral'>        bool setFees</span>
 281 |     | <span class='neutral'>    ) external override</span>
 282 |     | <span class='neutral'>        ownerOnly</span>
 283 |     | <span class='neutral'>        nonReentrant</span>
 284 |     | <span class='neutral'>        canoncialOnly </span>
 285 |     | <span class='neutral'>    returns (</span>
 286 |     | <span class='unexecuted'>        uint128 token0Fees,</span>
 287 |     | <span class='unexecuted'>        uint128 token1Fees</span>
 288 |     | <span class='unexecuted'>    ) {</span>
 289 |     | <span class='unexecuted'>        if (setFees) {</span>
 290 |     | <span class='unexecuted'>            if (protocolFee0 &gt; 10000 || protocolFee1 &gt; 10000)</span>
 291 |     | <span class='unexecuted'>                revert ProtocolFeeCeilingExceeded();</span>
 292 |     | <span class='unexecuted'>            pool1.protocolFee = protocolFee0;</span>
 293 |     | <span class='unexecuted'>            pool0.protocolFee = protocolFee1;</span>
 294 |     | <span class='neutral'>        }</span>
 295 |     | <span class='unexecuted'>        address feeTo = ILimitPoolManager(owner()).feeTo();</span>
 296 |     | <span class='unexecuted'>        token0Fees = pool1.protocolFees;</span>
 297 |     | <span class='unexecuted'>        token1Fees = pool0.protocolFees;</span>
 298 |     | <span class='unexecuted'>        pool0.protocolFees = 0;</span>
 299 |     | <span class='unexecuted'>        pool1.protocolFees = 0;</span>
 300 |     | <span class='unexecuted'>        if (token0Fees &gt; 0)</span>
 301 |     | <span class='unexecuted'>            SafeTransfers.transferOut(feeTo, token0(), token0Fees);</span>
 302 |     | <span class='unexecuted'>        if (token1Fees &gt; 0)</span>
 303 |     | <span class='unexecuted'>            SafeTransfers.transferOut(feeTo, token1(), token1Fees);</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='unexecuted'>    function immutables() public view returns (</span>
 307 |     | <span class='unexecuted'>        Immutables memory</span>
 308 |     | <span class='neutral'>    ) {</span>
 309 |     | <span class='unexecuted'>        return Immutables(</span>
 310 |     | <span class='unexecuted'>            owner(),</span>
 311 |     | <span class='unexecuted'>            factory,</span>
 312 |     | <span class='unexecuted'>            ConstantProduct.PriceBounds(minPrice(), maxPrice()),</span>
 313 |     | <span class='unexecuted'>            token0(),</span>
 314 |     | <span class='unexecuted'>            token1(),</span>
 315 |     | <span class='unexecuted'>            tickSpacing()</span>
 316 |     | <span class='neutral'>        );</span>
 317 |     | <span class='neutral'>    }</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='unexecuted'>    function priceBounds(int16 tickSpacing) external pure returns (uint160, uint160) {</span>
 320 |     | <span class='unexecuted'>        return ConstantProduct.priceBounds(tickSpacing);</span>
 321 |     | <span class='neutral'>    }</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='unexecuted'>    function _onlyOwner() private view {</span>
 324 |     | <span class='unexecuted'>        if (msg.sender != owner()) revert OwnerOnly();</span>
 325 |     | <span class='neutral'>    }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='unexecuted'>    function _onlyCanoncialClones() private view {</span>
 328 |     | <span class='neutral'>        // compute pool key</span>
 329 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(original, token0(), token1(), tickSpacing()));</span>
 330 |     | <span class='neutral'>        </span>
 331 |     | <span class='neutral'>        // computer canonical pool address</span>
 332 |     | <span class='unexecuted'>        address predictedAddress = LibClone.predictDeterministicAddress(</span>
 333 |     | <span class='unexecuted'>            original,</span>
 334 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 335 |     | <span class='unexecuted'>                owner(),</span>
 336 |     | <span class='unexecuted'>                token0(),</span>
 337 |     | <span class='unexecuted'>                token1(),</span>
 338 |     | <span class='unexecuted'>                minPrice(),</span>
 339 |     | <span class='unexecuted'>                maxPrice(),</span>
 340 |     | <span class='unexecuted'>                tickSpacing()</span>
 341 |     | <span class='neutral'>            ),</span>
 342 |     | <span class='unexecuted'>            key,</span>
 343 |     | <span class='unexecuted'>            factory</span>
 344 |     | <span class='neutral'>        );</span>
 345 |     | <span class='neutral'>        // only allow delegateCall from canonical clones</span>
 346 |     | <span class='unexecuted'>        if (address(this) != predictedAddress) require(false, &#39;NoDelegateCall()&#39;);</span>
 347 |     | <span class='neutral'>    }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='unexecuted'>    function _onlyFactory() private view {</span>
 350 |     | <span class='unexecuted'>        if (msg.sender != factory) revert FactoryOnly();</span>
 351 |     | <span class='neutral'>    }</span>
 352 |     | <span class='neutral'>}</span>
 353 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/LimitPoolFactory.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./LimitPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./interfaces/ILimitPoolFactory.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./base/events/LimitPoolFactoryEvents.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./base/structs/PoolsharkStructs.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./utils/LimitPoolErrors.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./libraries/solady/LibClone.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./libraries/math/ConstantProduct.sol&#39;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>contract LimitPoolFactory is </span>
  13 |     | <span class='neutral'>    ILimitPoolFactory,</span>
  14 |     | <span class='neutral'>    PoolsharkStructs,</span>
  15 |     | <span class='neutral'>    LimitPoolFactoryEvents,</span>
  16 |     | <span class='neutral'>    LimitPoolFactoryErrors</span>
  17 |     | <span class='neutral'>{</span>
  18 |     | <span class='neutral'>    using LibClone for address;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    address immutable public owner;</span>
  21 |     | <span class='unexecuted'>    address immutable public original;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    constructor(</span>
  24 |     | <span class='neutral'>        address owner_</span>
  25 |     | <span class='neutral'>    ) {</span>
  26 |     | <span class='unexecuted'>        owner = owner_;</span>
  27 |     | <span class='unexecuted'>        original = address(this);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    function createLimitPool(</span>
  31 |     | <span class='neutral'>        bytes32 poolType,</span>
  32 |     | <span class='neutral'>        address tokenIn,</span>
  33 |     | <span class='neutral'>        address tokenOut,</span>
  34 |     | <span class='neutral'>        int16  tickSpacing,</span>
  35 |     | <span class='neutral'>        uint160 startPrice</span>
  36 |     | <span class='unexecuted'>    ) external override returns (address pool) {</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>        // validate token pair</span>
  39 |     | <span class='unexecuted'>        if (tokenIn == tokenOut || tokenIn == address(0) || tokenOut == address(0)) {</span>
  40 |     | <span class='unexecuted'>            revert InvalidTokenAddress();</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>        // sort tokens by address</span>
  44 |     | <span class='neutral'>        Immutables memory constants;</span>
  45 |     | <span class='unexecuted'>        (constants.token0, constants.token1) = tokenIn &lt; tokenOut ? (tokenIn,  tokenOut) </span>
  46 |     | <span class='unexecuted'>                                                                  : (tokenOut, tokenIn);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>        // check if tick spacing supported</span>
  49 |     | <span class='unexecuted'>        if (!ILimitPoolManager(owner).tickSpacings(tickSpacing)) revert TickSpacingNotSupported();</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>        // check if pool type supported</span>
  52 |     | <span class='unexecuted'>        address implementation = ILimitPoolManager(owner).implementations(poolType);</span>
  53 |     | <span class='unexecuted'>        if (implementation == address(0)) revert PoolTypeNotSupported();</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>        // generate key for pool</span>
  56 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
  57 |     | <span class='unexecuted'>            implementation,</span>
  58 |     | <span class='unexecuted'>            constants.token0,</span>
  59 |     | <span class='unexecuted'>            constants.token1,</span>
  60 |     | <span class='unexecuted'>            tickSpacing</span>
  61 |     | <span class='neutral'>        ));</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        // check if pool already exists</span>
  64 |     | <span class='unexecuted'>        if (limitPools[key] != address(0)) revert PoolAlreadyExists();</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        // set immutables</span>
  67 |     | <span class='unexecuted'>        constants.owner = owner;</span>
  68 |     | <span class='unexecuted'>        constants.factory = original;</span>
  69 |     | <span class='unexecuted'>        constants.tickSpacing = tickSpacing;</span>
  70 |     | <span class='unexecuted'>        (</span>
  71 |     | <span class='unexecuted'>            constants.bounds.min,</span>
  72 |     | <span class='unexecuted'>            constants.bounds.max</span>
  73 |     | <span class='unexecuted'>        ) = ILimitPool(implementation).priceBounds(constants.tickSpacing);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        // launch pool</span>
  76 |     | <span class='unexecuted'>        pool = implementation.cloneDeterministic({</span>
  77 |     | <span class='unexecuted'>            salt: key,</span>
  78 |     | <span class='unexecuted'>            data: abi.encodePacked(</span>
  79 |     | <span class='unexecuted'>                constants.owner,</span>
  80 |     | <span class='unexecuted'>                constants.token0,</span>
  81 |     | <span class='unexecuted'>                constants.token1,</span>
  82 |     | <span class='unexecuted'>                constants.bounds.min,</span>
  83 |     | <span class='unexecuted'>                constants.bounds.max,</span>
  84 |     | <span class='unexecuted'>                constants.tickSpacing</span>
  85 |     | <span class='neutral'>            )</span>
  86 |     | <span class='neutral'>        });</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        // initialize pool storage</span>
  89 |     | <span class='unexecuted'>        ILimitPool(pool).initialize(startPrice);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        // save pool in mapping</span>
  92 |     | <span class='unexecuted'>        limitPools[key] = pool;</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        emit PoolCreated(</span>
  95 |     | <span class='neutral'>            pool,</span>
  96 |     | <span class='neutral'>            implementation,</span>
  97 |     | <span class='unexecuted'>            constants.token0,</span>
  98 |     | <span class='unexecuted'>            constants.token1,</span>
  99 |     | <span class='neutral'>            tickSpacing</span>
 100 |     | <span class='neutral'>        );</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>    function getLimitPool(</span>
 104 |     | <span class='neutral'>        bytes32 poolType,</span>
 105 |     | <span class='neutral'>        address tokenIn,</span>
 106 |     | <span class='neutral'>        address tokenOut,</span>
 107 |     | <span class='neutral'>        int16 tickSpacing</span>
 108 |     | <span class='unexecuted'>    ) external view override returns (address) {</span>
 109 |     | <span class='neutral'>        // set lexographical token address ordering</span>
 110 |     | <span class='unexecuted'>        address token0 = tokenIn &lt; tokenOut ? tokenIn : tokenOut;</span>
 111 |     | <span class='unexecuted'>        address token1 = tokenIn &lt; tokenOut ? tokenOut : tokenIn;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        // check if tick spacing supported</span>
 114 |     | <span class='unexecuted'>        if (!ILimitPoolManager(owner).tickSpacings(tickSpacing)) revert TickSpacingNotSupported();</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>        // check if pool type supported</span>
 117 |     | <span class='unexecuted'>        address implementation = ILimitPoolManager(owner).implementations(poolType);</span>
 118 |     | <span class='unexecuted'>        if (implementation == address(0)) revert PoolTypeNotSupported();</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>        // generate key for pool</span>
 121 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
 122 |     | <span class='neutral'>            implementation,</span>
 123 |     | <span class='neutral'>            token0,</span>
 124 |     | <span class='neutral'>            token1,</span>
 125 |     | <span class='neutral'>            tickSpacing</span>
 126 |     | <span class='neutral'>        ));</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        return limitPools[key];</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'>}</span>
 131 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/base/events/LimitPoolEvents.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolEvents {</span>
  5 |     | <span class='neutral'>    event Initialize(</span>
  6 |     | <span class='neutral'>        int24 minTick,</span>
  7 |     | <span class='neutral'>        int24 maxTick,</span>
  8 |     | <span class='neutral'>        uint160 startPrice</span>
  9 |     | <span class='neutral'>    );</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    event MintLimit(</span>
 12 |     | <span class='neutral'>        address indexed to,</span>
 13 |     | <span class='neutral'>        int24 lower,</span>
 14 |     | <span class='neutral'>        int24 upper,</span>
 15 |     | <span class='neutral'>        bool zeroForOne,</span>
 16 |     | <span class='neutral'>        uint32 epochLast,</span>
 17 |     | <span class='neutral'>        uint128 amountIn,</span>
 18 |     | <span class='neutral'>        uint128 amountFilled,</span>
 19 |     | <span class='neutral'>        uint128 liquidityMinted</span>
 20 |     | <span class='neutral'>    );</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    event BurnLimit(</span>
 23 |     | <span class='neutral'>        address indexed to,</span>
 24 |     | <span class='neutral'>        int24 lower,</span>
 25 |     | <span class='neutral'>        int24 upper,</span>
 26 |     | <span class='neutral'>        int24 claim,</span>
 27 |     | <span class='neutral'>        bool zeroForOne,</span>
 28 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
 29 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
 30 |     | <span class='neutral'>        uint128 tokenOutBurned</span>
 31 |     | <span class='neutral'>    );</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    event Swap(</span>
 34 |     | <span class='neutral'>        address indexed recipient,</span>
 35 |     | <span class='neutral'>        bool zeroForOne,</span>
 36 |     | <span class='neutral'>        uint256 amountIn,</span>
 37 |     | <span class='neutral'>        uint256 amountOut,</span>
 38 |     | <span class='neutral'>        uint160 price,</span>
 39 |     | <span class='neutral'>        uint128 liquidity,</span>
 40 |     | <span class='neutral'>        int24 tickAtPrice</span>
 41 |     | <span class='neutral'>    );</span>
 42 |     | <span class='neutral'>}</span>
 43 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/base/events/LimitPoolFactoryEvents.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolFactoryEvents {</span>
  5 |     | <span class='neutral'>    event PoolCreated(</span>
  6 |     | <span class='neutral'>        address pool,</span>
  7 |     | <span class='neutral'>        address implementation,</span>
  8 |     | <span class='neutral'>        address indexed token0,</span>
  9 |     | <span class='neutral'>        address indexed token1,</span>
 10 |     | <span class='neutral'>        int16 indexed tickSpacing</span>
 11 |     | <span class='neutral'>    );</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/base/events/LimitPoolManagerEvents.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolManagerEvents {</span>
  5 |     | <span class='neutral'>    event FactoryChanged(address indexed previousFactory, address indexed newFactory);</span>
  6 |     | <span class='neutral'>    event ImplementationEnabled(</span>
  7 |     | <span class='neutral'>        bytes32 key,</span>
  8 |     | <span class='neutral'>        address implementation</span>
  9 |     | <span class='neutral'>    );</span>
 10 |     | <span class='neutral'>    event TickSpacingEnabled(</span>
 11 |     | <span class='neutral'>        int16 tickSpacing</span>
 12 |     | <span class='neutral'>    );</span>
 13 |     | <span class='neutral'>    event FeeToTransfer(address indexed previousFeeTo, address indexed newFeeTo);</span>
 14 |     | <span class='neutral'>    event OwnerTransfer(address indexed previousOwner, address indexed newOwner);</span>
 15 |     | <span class='neutral'>    event ProtocolFeesModified(</span>
 16 |     | <span class='neutral'>        address[] modifyPools,</span>
 17 |     | <span class='neutral'>        uint16[] syncFees,</span>
 18 |     | <span class='neutral'>        uint16[] fillFees,</span>
 19 |     | <span class='neutral'>        bool[] setFees,</span>
 20 |     | <span class='neutral'>        uint128[] token0Fees,</span>
 21 |     | <span class='neutral'>        uint128[] token1Fees</span>
 22 |     | <span class='neutral'>    );</span>
 23 |     | <span class='neutral'>    event ProtocolFeesCollected(</span>
 24 |     | <span class='neutral'>        address[] collectPools,</span>
 25 |     | <span class='neutral'>        uint128[] token0Fees,</span>
 26 |     | <span class='neutral'>        uint128[] token1Fees</span>
 27 |     | <span class='neutral'>    );</span>
 28 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/base/modifiers/LimitPoolModifiers.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../storage/LimitPoolStorage.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../libraries/Ticks.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract LimitPoolModifiers is LimitPoolStorage {</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/base/storage/LimitPoolFactoryStorage.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolFactoryStorage {</span>
  5 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; address) public limitPools;</span>
  6 |     | <span class='neutral'>}</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/base/storage/LimitPoolImmutables.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BSD</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import { Clone } from &quot;../../libraries/solady/Clone.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract LimitPoolImmutables is Clone {</span>
  7 |     | <span class='unexecuted'>    function owner() public pure returns (address) {</span>
  8 |     | <span class='unexecuted'>        return _getArgAddress(0);</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    function token0() public pure returns (address) {</span>
 12 |     | <span class='unexecuted'>        return _getArgAddress(20);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function token1() public pure returns (address) {</span>
 16 |     | <span class='unexecuted'>        return _getArgAddress(40);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function minPrice() public pure returns (uint160) {</span>
 20 |     | <span class='unexecuted'>        return _getArgUint160(60);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function maxPrice() public pure returns (uint160) {</span>
 24 |     | <span class='unexecuted'>        return _getArgUint160(80);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function tickSpacing() public pure returns (int16) {</span>
 28 |     | <span class='unexecuted'>        return int16(_getArgUint16(100));</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/base/storage/LimitPoolStorage.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/ILimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../interfaces/ILimitPoolFactory.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../../utils/LimitPoolErrors.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>abstract contract LimitPoolStorage is ILimitPoolStructs, LimitPoolErrors {</span>
  9 |     | <span class='unexecuted'>    GlobalState public globalState;</span>
 10 |     | <span class='unexecuted'>    PoolState public pool0; /// @dev State for token0 as output</span>
 11 |     | <span class='unexecuted'>    PoolState public pool1; /// @dev State for token1 as output</span>
 12 |     | <span class='unexecuted'>    TickMap public tickMap;</span>
 13 |     | <span class='unexecuted'>    address public feeTo;</span>
 14 |     | <span class='unexecuted'>    mapping(int24 =&gt; Tick) public ticks0; /// @dev Ticks containing token0 as output</span>
 15 |     | <span class='unexecuted'>    mapping(int24 =&gt; Tick) public ticks1; /// @dev Ticks containing token1 as output</span>
 16 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; Position))) public positions0; //positions with token0 deposited</span>
 17 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; Position))) public positions1; //positions with token1 deposited</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/base/structs/CurveMathStructs.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/modules/sources/ITwapSource.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface CurveMathStructs {</span>
  7 |     | <span class='neutral'>    struct PriceBounds {</span>
  8 |     | <span class='neutral'>        uint160 min;</span>
  9 |     | <span class='neutral'>        uint160 max;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/base/structs/LimitPoolFactoryStructs.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolFactoryStructs {</span>
  5 |     | <span class='neutral'>    struct LimitPoolParams {</span>
  6 |     | <span class='neutral'>        address owner;</span>
  7 |     | <span class='neutral'>        address token0;</span>
  8 |     | <span class='neutral'>        address token1;</span>
  9 |     | <span class='neutral'>        uint160 minPrice;</span>
 10 |     | <span class='neutral'>        uint160 maxPrice;</span>
 11 |     | <span class='neutral'>        uint160 startPrice;</span>
 12 |     | <span class='neutral'>        int16   tickSpacing;</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/base/structs/PoolsharkStructs.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface PoolsharkStructs {</span>
  5 |     | <span class='neutral'>    struct SwapParams {</span>
  6 |     | <span class='neutral'>        address to;</span>
  7 |     | <span class='neutral'>        uint160 priceLimit;</span>
  8 |     | <span class='neutral'>        uint128  amount;</span>
  9 |     | <span class='neutral'>        bool exactIn;</span>
 10 |     | <span class='neutral'>        bool zeroForOne;</span>
 11 |     | <span class='neutral'>        bytes callbackData;</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'>    </span>
 14 |     | <span class='neutral'>    struct Immutables {</span>
 15 |     | <span class='neutral'>        address owner;</span>
 16 |     | <span class='neutral'>        address factory;</span>
 17 |     | <span class='neutral'>        PriceBounds bounds;</span>
 18 |     | <span class='neutral'>        address token0;</span>
 19 |     | <span class='neutral'>        address token1;</span>
 20 |     | <span class='neutral'>        int16 tickSpacing;</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    struct PriceBounds {</span>
 24 |     | <span class='neutral'>        uint160 min;</span>
 25 |     | <span class='neutral'>        uint160 max;</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/external/openzeppelin/security/ReentrancyGuard.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Contract module that helps prevent reentrant calls to a function.</span>
  8 |     | <span class='neutral'> *</span>
  9 |     | <span class='neutral'> * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier</span>
 10 |     | <span class='neutral'> * available, which can be applied to functions to make sure there are no nested</span>
 11 |     | <span class='neutral'> * (reentrant) calls to them.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * Note that because there is a single `nonReentrant` guard, functions marked as</span>
 14 |     | <span class='neutral'> * `nonReentrant` may not call one another. This can be worked around by making</span>
 15 |     | <span class='neutral'> * those functions `private`, and then adding `external` `nonReentrant` entry</span>
 16 |     | <span class='neutral'> * points to them.</span>
 17 |     | <span class='neutral'> *</span>
 18 |     | <span class='neutral'> * TIP: If you would like to learn more about reentrancy and alternative ways</span>
 19 |     | <span class='neutral'> * to protect against it, check out our blog post</span>
 20 |     | <span class='neutral'> * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].</span>
 21 |     | <span class='neutral'> */</span>
 22 |     | <span class='neutral'>abstract contract ReentrancyGuard {</span>
 23 |     | <span class='neutral'>    // Booleans are more expensive than uint256 or any type that takes up a full</span>
 24 |     | <span class='neutral'>    // word because each write operation emits an extra SLOAD to first read the</span>
 25 |     | <span class='neutral'>    // slot&#39;s contents, replace the bits taken up by the boolean, and then write</span>
 26 |     | <span class='neutral'>    // back. This is the compiler&#39;s defense against contract upgrades and</span>
 27 |     | <span class='neutral'>    // pointer aliasing, and it cannot be disabled.</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    // The values being non-zero value makes deployment a bit more expensive,</span>
 30 |     | <span class='neutral'>    // but in exchange the refund on every call to nonReentrant will be lower in</span>
 31 |     | <span class='neutral'>    // amount. Since refunds are capped to a percentage of the total</span>
 32 |     | <span class='neutral'>    // transaction&#39;s gas, it is best to keep them low in cases like this one, to</span>
 33 |     | <span class='neutral'>    // increase the likelihood of the full refund coming into effect.</span>
 34 |     | <span class='unexecuted'>    uint256 private constant _NOT_ENTERED = 1;</span>
 35 |     | <span class='unexecuted'>    uint256 private constant _ENTERED = 2;</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    uint256 private _status;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /**</span>
 40 |     | <span class='neutral'>     * @dev Unauthorized reentrant call.</span>
 41 |     | <span class='neutral'>     */</span>
 42 |     | <span class='neutral'>    error ReentrancyGuardReentrantCall();</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    /**</span>
 45 |     | <span class='neutral'>     * @dev Prevents a contract from calling itself, directly or indirectly.</span>
 46 |     | <span class='neutral'>     * Calling a `nonReentrant` function from another `nonReentrant`</span>
 47 |     | <span class='neutral'>     * function is not supported. It is possible to prevent this from happening</span>
 48 |     | <span class='neutral'>     * by making the `nonReentrant` function external, and making it call a</span>
 49 |     | <span class='neutral'>     * `private` function that does the actual work.</span>
 50 |     | <span class='neutral'>     */</span>
 51 |     | <span class='neutral'>    modifier nonReentrant() {</span>
 52 |     | <span class='unexecuted'>        _nonReentrantBefore();</span>
 53 |     | <span class='neutral'>        _;</span>
 54 |     | <span class='unexecuted'>        _nonReentrantAfter();</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>    function _nonReentrantBefore() private {</span>
 58 |     | <span class='neutral'>        // On the first call to nonReentrant, _status will be _NOT_ENTERED</span>
 59 |     | <span class='unexecuted'>        if (_status == _ENTERED) {</span>
 60 |     | <span class='unexecuted'>            revert ReentrancyGuardReentrantCall();</span>
 61 |     | <span class='neutral'>        }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>        // Any calls to nonReentrant after this point will fail</span>
 64 |     | <span class='unexecuted'>        _status = _ENTERED;</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>    function _nonReentrantAfter() private {</span>
 68 |     | <span class='neutral'>        // By storing the original value once again, a refund is triggered (see</span>
 69 |     | <span class='neutral'>        // https://eips.ethereum.org/EIPS/eip-2200)</span>
 70 |     | <span class='unexecuted'>        _status = _NOT_ENTERED;</span>
 71 |     | <span class='neutral'>    }</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='neutral'>    /**</span>
 74 |     | <span class='neutral'>     * @dev Returns true if the reentrancy guard is currently set to &quot;entered&quot;, which indicates there is a</span>
 75 |     | <span class='neutral'>     * `nonReentrant` function in the call stack.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function _reentrancyGuardEntered() internal view returns (bool) {</span>
 78 |     | <span class='neutral'>        return _status == _ENTERED;</span>
 79 |     | <span class='neutral'>    }</span>
 80 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/interfaces/IERC20Minimal.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IERC20Minimal {</span>
  5 |     | <span class='neutral'>    /// @notice Returns the balance of a token</span>
  6 |     | <span class='neutral'>    /// @param account The address for which to look up the balance for</span>
  7 |     | <span class='neutral'>    /// @return amount of tokens held by the account</span>
  8 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
  9 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/interfaces/ILimitPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./ILimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../base/structs/LimitPoolFactoryStructs.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface ILimitPool is ILimitPoolStructs {</span>
  8 |     | <span class='neutral'>    function initialize(</span>
  9 |     | <span class='neutral'>        uint160 startPrice</span>
 10 |     | <span class='neutral'>    ) external;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function mint(</span>
 13 |     | <span class='neutral'>        MintParams memory params</span>
 14 |     | <span class='neutral'>    ) external;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function burn(</span>
 17 |     | <span class='neutral'>        BurnParams memory params</span>
 18 |     | <span class='neutral'>    ) external;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function swap(</span>
 21 |     | <span class='neutral'>        SwapParams memory params</span>
 22 |     | <span class='neutral'>    ) external returns (</span>
 23 |     | <span class='neutral'>        int256 amount0,</span>
 24 |     | <span class='neutral'>        int256 amount1</span>
 25 |     | <span class='neutral'>    );</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function quote(</span>
 28 |     | <span class='neutral'>        QuoteParams memory params</span>
 29 |     | <span class='neutral'>    ) external view returns (</span>
 30 |     | <span class='neutral'>        uint256 inAmount,</span>
 31 |     | <span class='neutral'>        uint256 outAmount,</span>
 32 |     | <span class='neutral'>        uint256 priceAfter</span>
 33 |     | <span class='neutral'>    );</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function snapshot(</span>
 36 |     | <span class='neutral'>        SnapshotParams memory params</span>
 37 |     | <span class='neutral'>    ) external view returns (</span>
 38 |     | <span class='neutral'>        Position memory</span>
 39 |     | <span class='neutral'>    );</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    function fees(</span>
 42 |     | <span class='neutral'>        uint16 syncFee,</span>
 43 |     | <span class='neutral'>        uint16 fillFee,</span>
 44 |     | <span class='neutral'>        bool setFees</span>
 45 |     | <span class='neutral'>    ) external returns (</span>
 46 |     | <span class='neutral'>        uint128 token0Fees,</span>
 47 |     | <span class='neutral'>        uint128 token1Fees</span>
 48 |     | <span class='neutral'>    );</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function priceBounds(</span>
 51 |     | <span class='neutral'>        int16 tickSpacing</span>
 52 |     | <span class='neutral'>    ) external pure returns (</span>
 53 |     | <span class='neutral'>        uint160 minPrice,</span>
 54 |     | <span class='neutral'>        uint160 maxPrice</span>
 55 |     | <span class='neutral'>    );</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/interfaces/ILimitPoolFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'>import &#39;../base/storage/LimitPoolFactoryStorage.sol&#39;;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>abstract contract ILimitPoolFactory is LimitPoolFactoryStorage {</span>
  6 |     | <span class='neutral'>    function createLimitPool(</span>
  7 |     | <span class='neutral'>        bytes32 poolType,</span>
  8 |     | <span class='neutral'>        address tokenIn,</span>
  9 |     | <span class='neutral'>        address tokenOut,</span>
 10 |     | <span class='neutral'>        int16  tickSpacing,</span>
 11 |     | <span class='neutral'>        uint160 startPrice</span>
 12 |     | <span class='neutral'>    ) external virtual returns (address pool);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function getLimitPool(</span>
 15 |     | <span class='neutral'>        bytes32 poolType,</span>
 16 |     | <span class='neutral'>        address tokenIn,</span>
 17 |     | <span class='neutral'>        address tokenOut,</span>
 18 |     | <span class='neutral'>        int16  tickSpacing</span>
 19 |     | <span class='neutral'>    ) external view virtual returns (address);</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/interfaces/ILimitPoolManager.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice LimitPoolManager interface</span>
  5 |     | <span class='neutral'>interface ILimitPoolManager {</span>
  6 |     | <span class='neutral'>    function owner() external view returns (address);</span>
  7 |     | <span class='neutral'>    function feeTo() external view returns (address);</span>
  8 |     | <span class='neutral'>    function implementations(</span>
  9 |     | <span class='neutral'>        bytes32 poolType</span>
 10 |     | <span class='neutral'>    ) external view returns (</span>
 11 |     | <span class='neutral'>        address</span>
 12 |     | <span class='neutral'>    );</span>
 13 |     | <span class='neutral'>    function tickSpacings(</span>
 14 |     | <span class='neutral'>        int16 tickSpacing</span>
 15 |     | <span class='neutral'>    ) external view returns (</span>
 16 |     | <span class='neutral'>        bool</span>
 17 |     | <span class='neutral'>    );</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/interfaces/ILimitPoolStructs.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../libraries/math/ConstantProduct.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./modules/sources/ITwapSource.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>interface ILimitPoolStructs {</span>
   8 |     | <span class='neutral'>    struct GlobalState {</span>
   9 |     | <span class='neutral'>        uint8   unlocked;</span>
  10 |     | <span class='neutral'>    }</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    struct PoolState {</span>
  13 |     | <span class='neutral'>        uint160 price; /// @dev Starting price current</span>
  14 |     | <span class='neutral'>        uint128 liquidity; /// @dev Liquidity currently active</span>
  15 |     | <span class='neutral'>        uint128 liquidityGlobal;</span>
  16 |     | <span class='neutral'>        uint128 protocolFees;</span>
  17 |     | <span class='neutral'>        uint32  swapEpoch;</span>
  18 |     | <span class='neutral'>        uint16 protocolFee;</span>
  19 |     | <span class='neutral'>        int24 tickAtPrice;</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    struct TickMap {</span>
  23 |     | <span class='neutral'>        uint256 blocks;                     /// @dev - sets of words</span>
  24 |     | <span class='neutral'>        mapping(uint256 =&gt; uint256) words;  /// @dev - sets to words</span>
  25 |     | <span class='neutral'>        mapping(uint256 =&gt; uint256) ticks;  /// @dev - words to ticks</span>
  26 |     | <span class='neutral'>        mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256))) epochs; /// @dev - ticks to epochs</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    struct Tick {</span>
  30 |     | <span class='neutral'>        uint160 priceAt;</span>
  31 |     | <span class='neutral'>        int128 liquidityDelta;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    struct Position {</span>
  35 |     | <span class='neutral'>        uint160 claimPriceLast; // highest price claimed at</span>
  36 |     | <span class='neutral'>        uint128 liquidity; // expected amount to be used not actual</span>
  37 |     | <span class='neutral'>        uint128 amountIn; // token amount already claimed; balance</span>
  38 |     | <span class='neutral'>        uint128 amountOut; // necessary for non-custodial positions</span>
  39 |     | <span class='neutral'>        uint32  epochLast;  // last epoch this position was updated at</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    struct PriceBounds {</span>
  43 |     | <span class='neutral'>        uint160 min;</span>
  44 |     | <span class='neutral'>        uint160 max;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    struct Immutables {</span>
  48 |     | <span class='neutral'>        address owner;</span>
  49 |     | <span class='neutral'>        address factory;</span>
  50 |     | <span class='neutral'>        ConstantProduct.PriceBounds bounds;</span>
  51 |     | <span class='neutral'>        address token0;</span>
  52 |     | <span class='neutral'>        address token1;</span>
  53 |     | <span class='neutral'>        int16 tickSpacing;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    struct MintParams {</span>
  57 |     | <span class='neutral'>        address to;</span>
  58 |     | <span class='neutral'>        address refundTo;</span>
  59 |     | <span class='neutral'>        uint128 amount;</span>
  60 |     | <span class='neutral'>        uint96 mintPercent;</span>
  61 |     | <span class='neutral'>        int24 lower;</span>
  62 |     | <span class='neutral'>        int24 upper;</span>
  63 |     | <span class='neutral'>        bool zeroForOne;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    struct BurnParams {</span>
  67 |     | <span class='neutral'>        address to;</span>
  68 |     | <span class='neutral'>        uint128 burnPercent;</span>
  69 |     | <span class='neutral'>        int24 lower;</span>
  70 |     | <span class='neutral'>        int24 claim;</span>
  71 |     | <span class='neutral'>        int24 upper;</span>
  72 |     | <span class='neutral'>        bool zeroForOne;</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    struct SwapParams {</span>
  76 |     | <span class='neutral'>        address to;</span>
  77 |     | <span class='neutral'>        uint160 priceLimit;</span>
  78 |     | <span class='neutral'>        uint128  amount;</span>
  79 |     | <span class='neutral'>        bool exactIn;</span>
  80 |     | <span class='neutral'>        bool zeroForOne;</span>
  81 |     | <span class='neutral'>        bytes callbackData;</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    struct QuoteParams {</span>
  85 |     | <span class='neutral'>        uint160 priceLimit;</span>
  86 |     | <span class='neutral'>        uint128 amount;</span>
  87 |     | <span class='neutral'>        bool exactIn;</span>
  88 |     | <span class='neutral'>        bool zeroForOne;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    struct SnapshotParams {</span>
  92 |     | <span class='neutral'>        address owner;</span>
  93 |     | <span class='neutral'>        uint128 burnPercent;</span>
  94 |     | <span class='neutral'>        int24 lower;</span>
  95 |     | <span class='neutral'>        int24 upper;</span>
  96 |     | <span class='neutral'>        int24 claim;</span>
  97 |     | <span class='neutral'>        bool zeroForOne;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    struct UpdateParams {</span>
 101 |     | <span class='neutral'>        address owner;</span>
 102 |     | <span class='neutral'>        address to;</span>
 103 |     | <span class='neutral'>        uint128 amount;</span>
 104 |     | <span class='neutral'>        int24 lower;</span>
 105 |     | <span class='neutral'>        int24 upper;</span>
 106 |     | <span class='neutral'>        int24 claim;</span>
 107 |     | <span class='neutral'>        bool zeroForOne;</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    struct MintCache {</span>
 111 |     | <span class='neutral'>        GlobalState state;</span>
 112 |     | <span class='neutral'>        Position position;</span>
 113 |     | <span class='neutral'>        Immutables constants;</span>
 114 |     | <span class='neutral'>        PoolState pool;</span>
 115 |     | <span class='neutral'>        PoolState swapPool;</span>
 116 |     | <span class='neutral'>        SwapCache swapCache;</span>
 117 |     | <span class='neutral'>        uint256 liquidityMinted;</span>
 118 |     | <span class='neutral'>        uint256 mintSize;</span>
 119 |     | <span class='neutral'>        uint256 priceLimit;</span>
 120 |     | <span class='neutral'>        int256 amountIn;</span>
 121 |     | <span class='neutral'>        uint256 amountOut;</span>
 122 |     | <span class='neutral'>        uint256 priceLower;</span>
 123 |     | <span class='neutral'>        uint256 priceUpper;</span>
 124 |     | <span class='neutral'>        int24 tickLimit;</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    struct BurnCache {</span>
 128 |     | <span class='neutral'>        GlobalState state;</span>
 129 |     | <span class='neutral'>        Position position;</span>
 130 |     | <span class='neutral'>        Immutables constants;</span>
 131 |     | <span class='neutral'>        PoolState pool;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    struct SwapCache {</span>
 135 |     | <span class='neutral'>        GlobalState state;</span>
 136 |     | <span class='neutral'>        Immutables constants;</span>
 137 |     | <span class='neutral'>        PoolState pool;</span>
 138 |     | <span class='neutral'>        uint256 price;</span>
 139 |     | <span class='neutral'>        uint256 liquidity;</span>
 140 |     | <span class='neutral'>        uint256 amountLeft;</span>
 141 |     | <span class='neutral'>        uint256 input;</span>
 142 |     | <span class='neutral'>        uint256 output;</span>
 143 |     | <span class='neutral'>        uint160 crossPrice;</span>
 144 |     | <span class='neutral'>        int24 crossTick;</span>
 145 |     | <span class='neutral'>        bool exactIn;</span>
 146 |     | <span class='neutral'>        bool cross;</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    struct UpdateCache {</span>
 150 |     | <span class='neutral'>        PoolState pool;</span>
 151 |     | <span class='neutral'>        Tick claimTick;</span>
 152 |     | <span class='neutral'>        Position position;</span>
 153 |     | <span class='neutral'>        uint160 priceLower;</span>
 154 |     | <span class='neutral'>        uint160 priceClaim;</span>
 155 |     | <span class='neutral'>        uint160 priceUpper;</span>
 156 |     | <span class='neutral'>        bool earlyReturn;</span>
 157 |     | <span class='neutral'>        bool removeLower;</span>
 158 |     | <span class='neutral'>        bool removeUpper;</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    struct InsertSingleLocals {</span>
 162 |     | <span class='neutral'>        int24 previousFullTick;</span>
 163 |     | <span class='neutral'>        int24 nextFullTick;</span>
 164 |     | <span class='neutral'>        uint256 priceNext;</span>
 165 |     | <span class='neutral'>        uint256 pricePrevious;</span>
 166 |     | <span class='neutral'>        uint256 amountInExact;</span>
 167 |     | <span class='neutral'>        uint256 amountOutExact;</span>
 168 |     | <span class='neutral'>        uint256 amountToCross;</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    struct GetDeltasLocals {</span>
 172 |     | <span class='neutral'>        int24 previousFullTick;</span>
 173 |     | <span class='neutral'>        uint256 pricePrevious;</span>
 174 |     | <span class='neutral'>        uint256 priceNext;</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'>}</span>
 177 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/interfaces/IPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../base/structs/PoolsharkStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IPool is PoolsharkStructs {</span>
  7 |     | <span class='neutral'>    function immutables() external view returns (Immutables memory);</span>
  8 |     | <span class='neutral'>    function swap(</span>
  9 |     | <span class='neutral'>        SwapParams memory params</span>
 10 |     | <span class='neutral'>    ) external returns (</span>
 11 |     | <span class='neutral'>        int256 amount0,</span>
 12 |     | <span class='neutral'>        int256 amount1</span>
 13 |     | <span class='neutral'>    );</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/interfaces/callbacks/IPoolsharkSwapCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for swaps</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls the `swap` function must implement this interface.</span>
  6 |     | <span class='neutral'>interface IPoolsharkSwapCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after executing a swap.</span>
  8 |     | <span class='neutral'>    /// @dev In the implementation you must pay the pool tokens owed for the swap.</span>
  9 |     | <span class='neutral'>    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.</span>
 10 |     | <span class='neutral'>    /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.</span>
 11 |     | <span class='neutral'>    /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.</span>
 12 |     | <span class='neutral'>    function poolsharkSwapCallback(</span>
 13 |     | <span class='neutral'>        int256 amount0Delta,</span>
 14 |     | <span class='neutral'>        int256 amount1Delta,</span>
 15 |     | <span class='neutral'>        bytes calldata data</span>
 16 |     | <span class='neutral'>    ) external;</span>
 17 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/interfaces/modules/curves/ICurveMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./IDyDxMath.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./ITickMath.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface ICurveMath is </span>
  8 |     | <span class='neutral'>    IDyDxMath,</span>
  9 |     | <span class='neutral'>    ITickMath</span>
 10 |     | <span class='neutral'>{}</span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/interfaces/modules/curves/IDyDxMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../../interfaces/ILimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../../base/structs/CurveMathStructs.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IDyDxMath {</span>
  8 |     | <span class='neutral'>    function getDy(</span>
  9 |     | <span class='neutral'>        uint256 liquidity,</span>
 10 |     | <span class='neutral'>        uint256 priceLower,</span>
 11 |     | <span class='neutral'>        uint256 priceUpper,</span>
 12 |     | <span class='neutral'>        bool roundUp</span>
 13 |     | <span class='neutral'>    ) external pure returns (</span>
 14 |     | <span class='neutral'>        uint256 dy</span>
 15 |     | <span class='neutral'>    );</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function getDx(</span>
 18 |     | <span class='neutral'>        uint256 liquidity,</span>
 19 |     | <span class='neutral'>        uint256 priceLower,</span>
 20 |     | <span class='neutral'>        uint256 priceUpper,</span>
 21 |     | <span class='neutral'>        bool roundUp</span>
 22 |     | <span class='neutral'>    ) external pure returns (</span>
 23 |     | <span class='neutral'>        uint256 dx</span>
 24 |     | <span class='neutral'>    );</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    function getLiquidityForAmounts(</span>
 27 |     | <span class='neutral'>        uint256 priceLower,</span>
 28 |     | <span class='neutral'>        uint256 priceUpper,</span>
 29 |     | <span class='neutral'>        uint256 currentPrice,</span>
 30 |     | <span class='neutral'>        uint256 dy,</span>
 31 |     | <span class='neutral'>        uint256 dx</span>
 32 |     | <span class='neutral'>    ) external pure returns (</span>
 33 |     | <span class='neutral'>        uint256 liquidity</span>
 34 |     | <span class='neutral'>    );</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function getAmountsForLiquidity(</span>
 37 |     | <span class='neutral'>        uint256 priceLower,</span>
 38 |     | <span class='neutral'>        uint256 priceUpper,</span>
 39 |     | <span class='neutral'>        uint256 price,</span>
 40 |     | <span class='neutral'>        uint256 liquidity,</span>
 41 |     | <span class='neutral'>        bool roundUp</span>
 42 |     | <span class='neutral'>    ) external pure returns (</span>
 43 |     | <span class='neutral'>        uint128 token0amount,</span>
 44 |     | <span class='neutral'>        uint128 token1amount</span>
 45 |     | <span class='neutral'>    );</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    function getNewPrice(</span>
 48 |     | <span class='neutral'>        uint256 price,</span>
 49 |     | <span class='neutral'>        uint256 liquidity,</span>
 50 |     | <span class='neutral'>        uint256 input,</span>
 51 |     | <span class='neutral'>        bool zeroForOne</span>
 52 |     | <span class='neutral'>    ) external pure returns (</span>
 53 |     | <span class='neutral'>        uint256 newPrice</span>
 54 |     | <span class='neutral'>    );</span>
 55 |     | <span class='neutral'>}</span>
 56 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/interfaces/modules/curves/ITickMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../../interfaces/ILimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../../base/structs/CurveMathStructs.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface ITickMath {</span>
  8 |     | <span class='neutral'>    struct PriceBounds {</span>
  9 |     | <span class='neutral'>        uint160 min;</span>
 10 |     | <span class='neutral'>        uint160 max;</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function getPriceAtTick(</span>
 14 |     | <span class='neutral'>        int24 tick,</span>
 15 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory</span>
 16 |     | <span class='neutral'>    ) external pure returns (</span>
 17 |     | <span class='neutral'>        uint160 price</span>
 18 |     | <span class='neutral'>    );</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function getTickAtPrice(</span>
 21 |     | <span class='neutral'>        uint160 price,</span>
 22 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory</span>
 23 |     | <span class='neutral'>    ) external view returns (</span>
 24 |     | <span class='neutral'>        int24 tick</span>
 25 |     | <span class='neutral'>    );</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function minTick(</span>
 28 |     | <span class='neutral'>        int16 tickSpacing</span>
 29 |     | <span class='neutral'>    ) external pure returns (</span>
 30 |     | <span class='neutral'>        int24 tick</span>
 31 |     | <span class='neutral'>    );</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function maxTick(</span>
 34 |     | <span class='neutral'>        int16 tickSpacing</span>
 35 |     | <span class='neutral'>    ) external pure returns (</span>
 36 |     | <span class='neutral'>        int24 tick</span>
 37 |     | <span class='neutral'>    );</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function minPrice(</span>
 40 |     | <span class='neutral'>        int16 tickSpacing</span>
 41 |     | <span class='neutral'>    ) external pure returns (</span>
 42 |     | <span class='neutral'>        uint160 minPrice</span>
 43 |     | <span class='neutral'>    );</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    function maxPrice(</span>
 46 |     | <span class='neutral'>        int16 tickSpacing</span>
 47 |     | <span class='neutral'>    ) external pure returns (</span>
 48 |     | <span class='neutral'>        uint160 maxPrice</span>
 49 |     | <span class='neutral'>    );</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    function checkTicks(</span>
 52 |     | <span class='neutral'>        int24 lower,</span>
 53 |     | <span class='neutral'>        int24 upper,</span>
 54 |     | <span class='neutral'>        int16 tickSpacing</span>
 55 |     | <span class='neutral'>    ) external pure;</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    function checkPrice(</span>
 58 |     | <span class='neutral'>        uint160 price,</span>
 59 |     | <span class='neutral'>        PriceBounds memory bounds</span>
 60 |     | <span class='neutral'>    ) external pure;</span>
 61 |     | <span class='neutral'>}</span>
 62 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/interfaces/modules/sources/ITwapSource.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../ILimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface ITwapSource {</span>
  7 |     | <span class='neutral'>    function initialize(</span>
  8 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
  9 |     | <span class='neutral'>    ) external returns (</span>
 10 |     | <span class='neutral'>        uint8 initializable,</span>
 11 |     | <span class='neutral'>        int24 startingTick</span>
 12 |     | <span class='neutral'>    );</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function calculateAverageTick(</span>
 15 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
 16 |     | <span class='neutral'>    ) external view returns (</span>
 17 |     | <span class='neutral'>        int24 averageTick</span>
 18 |     | <span class='neutral'>    );</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function getPool(</span>
 21 |     | <span class='neutral'>        address tokenA,</span>
 22 |     | <span class='neutral'>        address tokenB,</span>
 23 |     | <span class='neutral'>        uint16 feeTier</span>
 24 |     | <span class='neutral'>    ) external view returns (</span>
 25 |     | <span class='neutral'>        address pool</span>
 26 |     | <span class='neutral'>    );</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    function feeTierTickSpacing(</span>
 29 |     | <span class='neutral'>        uint16 feeTier</span>
 30 |     | <span class='neutral'>    ) external view returns (</span>
 31 |     | <span class='neutral'>        int24 tickSpacing</span>
 32 |     | <span class='neutral'>    );</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function factory()</span>
 35 |     | <span class='neutral'>    external view returns (address);</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/Claims.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../interfaces/ILimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../interfaces/modules/curves/ICurveMath.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./TickMap.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./utils/String.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./utils/SafeCast.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>library Claims {</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>    function validate(</span>
  16 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.Position)))</span>
  17 |     | <span class='neutral'>            storage positions,</span>
  18 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
  19 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
  20 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool,</span>
  21 |     | <span class='neutral'>        ILimitPoolStructs.UpdateParams memory params,</span>
  22 |     | <span class='neutral'>        ILimitPoolStructs.UpdateCache memory cache,</span>
  23 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
  24 |     | <span class='neutral'>    ) internal view returns (</span>
  25 |     | <span class='neutral'>        ILimitPoolStructs.UpdateParams memory,</span>
  26 |     | <span class='unexecuted'>        ILimitPoolStructs.UpdateCache memory</span>
  27 |     | <span class='neutral'>    ) {</span>
  28 |     | <span class='neutral'>        // validate position liquidity</span>
  29 |     | <span class='unexecuted'>        if (params.amount &gt; cache.position.liquidity) require (false, &#39;NotEnoughPositionLiquidity()&#39;);</span>
  30 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
  31 |     | <span class='unexecuted'>            require(false, &#39;NoPositionLiquidityFound()&#39;);</span>
  32 |     | <span class='neutral'>        }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>        // if the position has not been crossed into at all</span>
  35 |     | <span class='unexecuted'>        else if (cache.position.claimPriceLast == 0 &amp;&amp;</span>
  36 |     | <span class='unexecuted'>                 (params.zeroForOne ? (params.claim == params.lower &amp;&amp;</span>
  37 |     | <span class='unexecuted'>                                        EpochMap.get(params.lower, tickMap, constants) &lt;= cache.position.epochLast)</span>
  38 |     | <span class='unexecuted'>                                    : (params.claim == params.upper &amp;&amp;</span>
  39 |     | <span class='unexecuted'>                                        EpochMap.get(params.upper, tickMap, constants) &lt;= cache.position.epochLast))</span>
  40 |     | <span class='neutral'>        ) {</span>
  41 |     | <span class='unexecuted'>            cache.earlyReturn = true;</span>
  42 |     | <span class='unexecuted'>            return (params, cache);</span>
  43 |     | <span class='neutral'>        }</span>
  44 |     | <span class='neutral'>        </span>
  45 |     | <span class='unexecuted'>        if (params.claim &lt; params.lower || params.claim &gt; params.upper) require (false, &#39;InvalidClaimTick()&#39;);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>        uint32 claimTickEpoch = EpochMap.get(params.claim, tickMap, constants);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>        if (params.zeroForOne){</span>
  50 |     | <span class='unexecuted'>            if (pool.price &gt;= cache.priceClaim) {</span>
  51 |     | <span class='unexecuted'>                if (pool.price &lt;= cache.priceUpper) {</span>
  52 |     | <span class='unexecuted'>                    cache.priceClaim = pool.price;</span>
  53 |     | <span class='unexecuted'>                    params.claim = TickMap.roundBack(pool.tickAtPrice, constants, params.zeroForOne, cache.priceClaim);</span>
  54 |     | <span class='unexecuted'>                    claimTickEpoch = pool.swapEpoch;</span>
  55 |     | <span class='neutral'>                } else {</span>
  56 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceUpper;</span>
  57 |     | <span class='unexecuted'>                    params.claim = params.upper;</span>
  58 |     | <span class='unexecuted'>                    cache.claimTick = ticks[params.upper];</span>
  59 |     | <span class='neutral'>                }</span>
  60 |     | <span class='unexecuted'>                claimTickEpoch = pool.swapEpoch;</span>
  61 |     | <span class='unexecuted'>            } else if (params.claim % constants.tickSpacing != 0) {</span>
  62 |     | <span class='unexecuted'>                if (cache.claimTick.priceAt == 0) {</span>
  63 |     | <span class='unexecuted'>                    require (false, &#39;WrongTickClaimedAt1()&#39;);</span>
  64 |     | <span class='neutral'>                }</span>
  65 |     | <span class='unexecuted'>                cache.priceClaim = cache.claimTick.priceAt;</span>
  66 |     | <span class='neutral'>            }</span>
  67 |     | <span class='neutral'>        } else {</span>
  68 |     | <span class='unexecuted'>            if (pool.price &lt;= cache.priceClaim) {</span>
  69 |     | <span class='unexecuted'>                if (pool.price &gt;= cache.priceLower) {</span>
  70 |     | <span class='unexecuted'>                    cache.priceClaim = pool.price;</span>
  71 |     | <span class='unexecuted'>                    params.claim = TickMap.roundBack(pool.tickAtPrice, constants, params.zeroForOne, cache.priceClaim);</span>
  72 |     | <span class='neutral'>                    claimTickEpoch = pool.swapEpoch;</span>
  73 |     | <span class='neutral'>                } else {</span>
  74 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceLower;</span>
  75 |     | <span class='unexecuted'>                    params.claim = params.lower;</span>
  76 |     | <span class='unexecuted'>                    cache.claimTick = ticks[params.upper];</span>
  77 |     | <span class='neutral'>                }</span>
  78 |     | <span class='unexecuted'>                claimTickEpoch = pool.swapEpoch;</span>
  79 |     | <span class='unexecuted'>            } else if (params.claim % constants.tickSpacing != 0) {</span>
  80 |     | <span class='unexecuted'>                if (cache.claimTick.priceAt == 0) {</span>
  81 |     | <span class='unexecuted'>                    require (false, &#39;WrongTickClaimedAt2()&#39;);</span>
  82 |     | <span class='neutral'>                }</span>
  83 |     | <span class='unexecuted'>                cache.priceClaim = cache.claimTick.priceAt;</span>
  84 |     | <span class='neutral'>            }</span>
  85 |     | <span class='neutral'>        }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        // validate claim tick</span>
  88 |     | <span class='unexecuted'>        if (params.claim == (params.zeroForOne ? params.upper : params.lower)) {</span>
  89 |     | <span class='unexecuted'>             if (claimTickEpoch &lt;= cache.position.epochLast)</span>
  90 |     | <span class='unexecuted'>                require (false, &#39;WrongTickClaimedAt3()&#39;);</span>
  91 |     | <span class='unexecuted'>        } else if (params.amount &gt; 0) {</span>
  92 |     | <span class='neutral'>            /// @dev - partway claim is valid as long as liquidity is not being removed</span>
  93 |     | <span class='unexecuted'>            int24 claimTickNext = params.zeroForOne</span>
  94 |     | <span class='unexecuted'>                ? TickMap.next(tickMap, params.claim, constants.tickSpacing, false)</span>
  95 |     | <span class='unexecuted'>                : TickMap.previous(tickMap, params.claim, constants.tickSpacing, false);</span>
  96 |     | <span class='neutral'>            // if we cleared the final tick of their position, this is the wrong claim tick</span>
  97 |     | <span class='unexecuted'>            if (params.zeroForOne ? claimTickNext &gt; params.upper</span>
  98 |     | <span class='unexecuted'>                                  : claimTickNext &lt; params.lower) {</span>
  99 |     | <span class='unexecuted'>                require (false, &#39;WrongTickClaimedAt4()&#39;);</span>
 100 |     | <span class='neutral'>            }</span>
 101 |     | <span class='neutral'>            // zero fill or partial fill</span>
 102 |     | <span class='neutral'>            /// @dev - if the next tick was crossed after position creation, the claim tick is incorrect</span>
 103 |     | <span class='neutral'>            /// @dev - we can cycle to find the right claim tick for the user</span>
 104 |     | <span class='unexecuted'>            uint32 claimTickNextAccumEpoch = EpochMap.get(claimTickNext, tickMap, constants);</span>
 105 |     | <span class='neutral'>            ///@dev - next swapEpoch should not be greater</span>
 106 |     | <span class='unexecuted'>            if (claimTickNextAccumEpoch &gt; cache.position.epochLast) {</span>
 107 |     | <span class='unexecuted'>                require (false, &#39;WrongTickClaimedAt5()&#39;);</span>
 108 |     | <span class='neutral'>            }</span>
 109 |     | <span class='neutral'>        }</span>
 110 |     | <span class='unexecuted'>        if (params.claim != params.upper &amp;&amp; params.claim != params.lower) {</span>
 111 |     | <span class='neutral'>            // check epochLast on claim tick</span>
 112 |     | <span class='unexecuted'>            if (claimTickEpoch &lt;= cache.position.epochLast)</span>
 113 |     | <span class='unexecuted'>                require (false, &#39;WrongTickClaimedAt6()&#39;);</span>
 114 |     | <span class='neutral'>            // prevent position overwriting at claim tick</span>
 115 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 116 |     | <span class='unexecuted'>                if (positions[params.owner][params.lower][params.claim].liquidity &gt; 0) {</span>
 117 |     | <span class='unexecuted'>                    require (false, string.concat(&#39;UpdatePositionFirstAt(&#39;, String.from(params.lower), &#39;, &#39;, String.from(params.claim), &#39;)&#39;));</span>
 118 |     | <span class='neutral'>                }</span>
 119 |     | <span class='neutral'>            } else {</span>
 120 |     | <span class='unexecuted'>                if (positions[params.owner][params.claim][params.upper].liquidity &gt; 0) {</span>
 121 |     | <span class='unexecuted'>                    require (false, string.concat(&#39;UpdatePositionFirstAt(&#39;, String.from(params.lower), &#39;, &#39;, String.from(params.claim), &#39;)&#39;));</span>
 122 |     | <span class='neutral'>                }</span>
 123 |     | <span class='neutral'>            }</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>        // early return if no update and amount burned is 0</span>
 127 |     | <span class='neutral'>        //TODO: after we&#39;ve cycled through claim ticks and there are no position updates just revert - DONE</span>
 128 |     | <span class='unexecuted'>        if (params.zeroForOne ? params.claim == params.lower</span>
 129 |     | <span class='unexecuted'>                              : params.claim == params.upper) {</span>
 130 |     | <span class='unexecuted'>            if (params.amount == 0)</span>
 131 |     | <span class='unexecuted'>                require(false, &#39;NoPositionUpdates()&#39;);</span>
 132 |     | <span class='neutral'>        }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>        return (params, cache);</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='unexecuted'>    function getDeltas(</span>
 138 |     | <span class='neutral'>        ILimitPoolStructs.UpdateCache memory cache,</span>
 139 |     | <span class='neutral'>        ILimitPoolStructs.UpdateParams memory params,</span>
 140 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
 141 |     | <span class='neutral'>    ) internal pure returns (</span>
 142 |     | <span class='unexecuted'>        ILimitPoolStructs.UpdateCache memory</span>
 143 |     | <span class='neutral'>    ) {</span>
 144 |     | <span class='neutral'>        // if half tick priceAt &gt; 0 add amountOut to amountOutClaimed</span>
 145 |     | <span class='neutral'>        // set claimPriceLast if zero</span>
 146 |     | <span class='unexecuted'>        if (cache.position.claimPriceLast == 0) {</span>
 147 |     | <span class='unexecuted'>            cache.position.claimPriceLast = params.zeroForOne ? cache.priceLower</span>
 148 |     | <span class='unexecuted'>                                                              : cache.priceUpper;</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='unexecuted'>        ILimitPoolStructs.GetDeltasLocals memory locals;</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='unexecuted'>        if (params.claim % constants.tickSpacing != 0)</span>
 153 |     | <span class='neutral'>        // this should pass price at the claim tick</span>
 154 |     | <span class='unexecuted'>            locals.previousFullTick = TickMap.roundBack(params.claim, constants, params.zeroForOne, ConstantProduct.getPriceAtTick(params.claim, constants));</span>
 155 |     | <span class='neutral'>        else</span>
 156 |     | <span class='unexecuted'>            locals.previousFullTick = params.claim;</span>
 157 |     | <span class='unexecuted'>        locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);</span>
 158 |     | <span class='unexecuted'>        if (params.zeroForOne ? locals.previousFullTick &gt; params.lower</span>
 159 |     | <span class='unexecuted'>                              : locals.previousFullTick &lt; params.upper) {</span>
 160 |     | <span class='neutral'>            </span>
 161 |     | <span class='neutral'>            // claim amounts up to latest full tick crossed</span>
 162 |     | <span class='unexecuted'>            cache.position.amountIn += uint128(params.zeroForOne ? ConstantProduct.getDy(cache.position.liquidity, cache.priceLower, locals.pricePrevious, false)</span>
 163 |     | <span class='unexecuted'>                                                                 : ConstantProduct.getDx(cache.position.liquidity, locals.pricePrevious, cache.priceUpper, false));</span>
 164 |     | <span class='unexecuted'>            cache.position.claimPriceLast = locals.pricePrevious.toUint160();</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='unexecuted'>        if (params.amount &gt; 0) {</span>
 167 |     | <span class='neutral'>           // if tick hasn&#39;t been set back calculate amountIn</span>
 168 |     | <span class='unexecuted'>            if (params.zeroForOne ? cache.priceClaim &gt; locals.pricePrevious</span>
 169 |     | <span class='unexecuted'>                                  : cache.priceClaim &lt; locals.pricePrevious) {</span>
 170 |     | <span class='neutral'>                // allow partial tick claim if removing liquidity</span>
 171 |     | <span class='unexecuted'>                cache.position.amountIn += uint128(params.zeroForOne ? ConstantProduct.getDy(params.amount, locals.pricePrevious, cache.priceClaim, false)</span>
 172 |     | <span class='unexecuted'>                                                                     : ConstantProduct.getDx(params.amount, cache.priceClaim, locals.pricePrevious, false));</span>
 173 |     | <span class='neutral'>            }</span>
 174 |     | <span class='neutral'>            // use priceClaim if tick hasn&#39;t been set back</span>
 175 |     | <span class='neutral'>            // else use claimPriceLast to calculate amountOut</span>
 176 |     | <span class='unexecuted'>            if (params.claim != (params.zeroForOne ? params.upper : params.lower)) {</span>
 177 |     | <span class='unexecuted'>                cache.position.amountOut += uint128(params.zeroForOne ? ConstantProduct.getDx(params.amount, cache.priceClaim, cache.priceUpper, false)</span>
 178 |     | <span class='unexecuted'>                                                                      : ConstantProduct.getDy(params.amount, cache.priceLower, cache.priceClaim, false));</span>
 179 |     | <span class='neutral'>            }</span>
 180 |     | <span class='neutral'>        }</span>
 181 |     | <span class='neutral'>        // take protocol fee if needed</span>
 182 |     | <span class='unexecuted'>        if (cache.pool.protocolFee &gt; 0 &amp;&amp; cache.position.amountIn &gt; 0) {</span>
 183 |     | <span class='unexecuted'>            uint128 protocolFeeAmount = cache.position.amountIn * cache.pool.protocolFee / 1e6;</span>
 184 |     | <span class='unexecuted'>            cache.position.amountIn -= protocolFeeAmount;</span>
 185 |     | <span class='unexecuted'>            cache.pool.protocolFees += protocolFeeAmount;</span>
 186 |     | <span class='neutral'>        }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='unexecuted'>        return cache;</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/EchidnaAssertions.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library EchidnaAssertions {</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>    event LiquidityGlobalUnderflow(uint128 liquidityGlobal, uint128 amount, string location);</span>
  7 |     | <span class='neutral'>    event LiquidityUnderflow(uint128 liquidity, uint128 amount, string location);</span>
  8 |     | <span class='neutral'>    event LiquidityUnlock(int128 liquidity);</span>
  9 |     | <span class='neutral'>    event PoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount);</span>
 10 |     | <span class='neutral'>    event LiquidityDelta(int128 liquidityDelta);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    function assertLiquidityGlobalUnderflows(uint128 liquidityGlobal, uint128 amount, string memory location) internal {</span>
 13 |     | <span class='unexecuted'>        emit LiquidityGlobalUnderflow(liquidityGlobal, amount, location);</span>
 14 |     | <span class='neutral'>        assert(liquidityGlobal &gt;= amount);</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function assertLiquidityUnderflows(uint128 liquidity, uint128 amount, string memory location) internal {</span>
 18 |     | <span class='unexecuted'>        emit LiquidityUnderflow(liquidity, amount, location);</span>
 19 |     | <span class='unexecuted'>        assert(liquidity &gt;= amount);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function assertPositiveLiquidityOnUnlock(int128 liquidity) internal {</span>
 23 |     | <span class='unexecuted'>        emit LiquidityUnlock(liquidity);</span>
 24 |     | <span class='unexecuted'>        assert(liquidity &gt;= 0);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function assertPoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount) internal {</span>
 28 |     | <span class='unexecuted'>        emit PoolBalanceExceeded(poolBalance, outputAmount);</span>
 29 |     | <span class='unexecuted'>        assert(poolBalance &gt;= outputAmount);</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function assertLiquidityDeltaZeroOnUnlock(int128 liquidity) internal {</span>
 33 |     | <span class='unexecuted'>        emit LiquidityDelta(liquidity);</span>
 34 |     | <span class='unexecuted'>        assert(liquidity == 0);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/EpochMap.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./math/ConstantProduct.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../interfaces/ILimitPoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='unexecuted'>library EpochMap {</span>
   8 |     | <span class='unexecuted'>    function set(</span>
   9 |     | <span class='neutral'>        int24  tick,</span>
  10 |     | <span class='neutral'>        uint256 epoch,</span>
  11 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
  12 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
  13 |     | <span class='neutral'>    ) internal {</span>
  14 |     | <span class='unexecuted'>        (</span>
  15 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  16 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  17 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
  18 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
  19 |     | <span class='unexecuted'>        ) = getIndices(tick, constants);</span>
  20 |     | <span class='neutral'>        // assert epoch isn&#39;t bigger than max uint32</span>
  21 |     | <span class='unexecuted'>        uint256 epochValue = tickMap.epochs[volumeIndex][blockIndex][wordIndex];</span>
  22 |     | <span class='neutral'>        // clear previous value</span>
  23 |     | <span class='unexecuted'>        epochValue &amp;=  ~(((1 &lt;&lt; 9) - 1) &lt;&lt; ((tickIndex &amp; 0x7) * 32));</span>
  24 |     | <span class='neutral'>        // add new value to word</span>
  25 |     | <span class='unexecuted'>        epochValue |= epoch &lt;&lt; ((tickIndex &amp; 0x7) * 32);</span>
  26 |     | <span class='neutral'>        // store word in map</span>
  27 |     | <span class='unexecuted'>        tickMap.epochs[volumeIndex][blockIndex][wordIndex] = epochValue;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function unset(</span>
  31 |     | <span class='neutral'>        int24 tick,</span>
  32 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
  33 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
  34 |     | <span class='neutral'>    ) internal {</span>
  35 |     | <span class='neutral'>        (</span>
  36 |     | <span class='neutral'>            uint256 tickIndex,</span>
  37 |     | <span class='neutral'>            uint256 wordIndex,</span>
  38 |     | <span class='neutral'>            uint256 blockIndex,</span>
  39 |     | <span class='neutral'>            uint256 volumeIndex</span>
  40 |     | <span class='neutral'>        ) = getIndices(tick, constants);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>        uint256 epochValue = tickMap.epochs[volumeIndex][blockIndex][wordIndex];</span>
  43 |     | <span class='neutral'>        // clear previous value</span>
  44 |     | <span class='neutral'>        epochValue &amp;= ~(1 &lt;&lt; (tickIndex &amp; 0x7 * 32) - 1);</span>
  45 |     | <span class='neutral'>        // store word in map</span>
  46 |     | <span class='neutral'>        tickMap.epochs[volumeIndex][blockIndex][wordIndex] = epochValue;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function get(</span>
  50 |     | <span class='neutral'>        int24 tick,</span>
  51 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
  52 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
  53 |     | <span class='neutral'>    ) internal view returns (</span>
  54 |     | <span class='unexecuted'>        uint32 epoch</span>
  55 |     | <span class='neutral'>    ) {</span>
  56 |     | <span class='unexecuted'>        (</span>
  57 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  58 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  59 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
  60 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
  61 |     | <span class='unexecuted'>        ) = getIndices(tick, constants);</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>        uint256 epochValue = tickMap.epochs[volumeIndex][blockIndex][wordIndex];</span>
  64 |     | <span class='neutral'>        // right shift so first 8 bits are epoch value</span>
  65 |     | <span class='unexecuted'>        epochValue &gt;&gt;= ((tickIndex &amp; 0x7) * 32);</span>
  66 |     | <span class='neutral'>        // clear other bits</span>
  67 |     | <span class='unexecuted'>        epochValue &amp;= ((1 &lt;&lt; 32) - 1);</span>
  68 |     | <span class='neutral'>        return uint32(epochValue);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>    function getIndices(</span>
  72 |     | <span class='neutral'>        int24 tick,</span>
  73 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
  74 |     | <span class='neutral'>    ) internal pure returns (</span>
  75 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  76 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  77 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
  78 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
  79 |     | <span class='neutral'>        )</span>
  80 |     | <span class='neutral'>    {</span>
  81 |     | <span class='neutral'>        unchecked {</span>
  82 |     | <span class='unexecuted'>            if (tick &gt; ConstantProduct.maxTick(constants.tickSpacing)) require (false, &#39;TickIndexOverflow()&#39;);</span>
  83 |     | <span class='unexecuted'>            if (tick &lt; ConstantProduct.minTick(constants.tickSpacing)) require (false, &#39;TickIndexUnderflow()&#39;);</span>
  84 |     | <span class='unexecuted'>            if (tick % (constants.tickSpacing / 2) != 0) {</span>
  85 |     | <span class='unexecuted'>                require (false, &#39;TickIndexInvalid()&#39;);</span>
  86 |     | <span class='neutral'>            } </span>
  87 |     | <span class='unexecuted'>            tickIndex = uint256(int256((_round(tick, constants.tickSpacing / 2) </span>
  88 |     | <span class='unexecuted'>                                        - _round(ConstantProduct.MIN_TICK, constants.tickSpacing / 2)) </span>
  89 |     | <span class='unexecuted'>                                        / (constants.tickSpacing / 2)));</span>
  90 |     | <span class='unexecuted'>            wordIndex = tickIndex &gt;&gt; 3;        // 2^3 epochs per word</span>
  91 |     | <span class='unexecuted'>            blockIndex = tickIndex &gt;&gt; 11;      // 2^8 words per block</span>
  92 |     | <span class='unexecuted'>            volumeIndex = tickIndex &gt;&gt; 19;     // 2^8 blocks per volume</span>
  93 |     | <span class='unexecuted'>            if (blockIndex &gt; 2046) require (false, &#39;BlockIndexOverflow()&#39;);</span>
  94 |     | <span class='neutral'>        }</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    function _tick (</span>
  98 |     | <span class='neutral'>        uint256 tickIndex,</span>
  99 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
 100 |     | <span class='neutral'>    ) internal pure returns (</span>
 101 |     | <span class='neutral'>        int24 tick</span>
 102 |     | <span class='neutral'>    ) {</span>
 103 |     | <span class='neutral'>        unchecked {</span>
 104 |     | <span class='neutral'>            if (tickIndex &gt; uint24(_round(ConstantProduct.MAX_TICK, constants.tickSpacing) * 2) * 2) </span>
 105 |     | <span class='neutral'>                require(false, &#39;TickIndexOverflow()&#39;);</span>
 106 |     | <span class='neutral'>            tick = int24(int256(tickIndex) * (constants.tickSpacing / 2) + _round(ConstantProduct.MIN_TICK, constants.tickSpacing / 2));</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>    function _round(</span>
 111 |     | <span class='neutral'>        int24 tick,</span>
 112 |     | <span class='neutral'>        int24 tickSpacing</span>
 113 |     | <span class='neutral'>    ) internal pure returns (</span>
 114 |     | <span class='unexecuted'>        int24 roundedTick</span>
 115 |     | <span class='neutral'>    ) {</span>
 116 |     | <span class='unexecuted'>        return tick / tickSpacing * tickSpacing;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'>}</span>
 119 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/Positions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../interfaces/modules/curves/ICurveMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./Ticks.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../interfaces/ILimitPoolStructs.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./math/OverflowMath.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../interfaces/modules/curves/ICurveMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./Claims.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./utils/SafeCast.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./pool/SwapCall.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./EchidnaAssertions.sol&#39;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>/// @notice Position management library for ranged liquidity.</span>
  16 |     | <span class='unexecuted'>library Positions {</span>
  17 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    event BurnLimit(</span>
  20 |     | <span class='neutral'>        address indexed to,</span>
  21 |     | <span class='neutral'>        int24 lower,</span>
  22 |     | <span class='neutral'>        int24 upper,</span>
  23 |     | <span class='neutral'>        int24 claim,</span>
  24 |     | <span class='neutral'>        bool zeroForOne,</span>
  25 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  26 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
  27 |     | <span class='neutral'>        uint128 tokenOutBurned</span>
  28 |     | <span class='neutral'>    );</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    function resize(</span>
  31 |     | <span class='neutral'>        ILimitPoolStructs.MintParams memory params,</span>
  32 |     | <span class='neutral'>        ILimitPoolStructs.MintCache memory cache,</span>
  33 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
  34 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage swapTicks</span>
  35 |     | <span class='neutral'>    ) internal returns (</span>
  36 |     | <span class='neutral'>        ILimitPoolStructs.MintParams memory,</span>
  37 |     | <span class='unexecuted'>        ILimitPoolStructs.MintCache memory</span>
  38 |     | <span class='neutral'>    )</span>
  39 |     | <span class='neutral'>    {</span>
  40 |     | <span class='unexecuted'>        ConstantProduct.checkTicks(params.lower, params.upper, cache.constants.tickSpacing);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>        cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
  43 |     | <span class='unexecuted'>        cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>        // cannot mint empty position</span>
  46 |     | <span class='unexecuted'>        if (params.amount == 0) require (false, &#39;PositionAmountZero()&#39;);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>        cache.mintSize = uint256(params.mintPercent) * uint256(params.amount) / 1e28;</span>
  49 |     | <span class='neutral'>        // calculate L constant</span>
  50 |     | <span class='unexecuted'>        cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
  51 |     | <span class='unexecuted'>            cache.priceLower,</span>
  52 |     | <span class='unexecuted'>            cache.priceUpper,</span>
  53 |     | <span class='unexecuted'>            params.zeroForOne ? cache.priceLower : cache.priceUpper,</span>
  54 |     | <span class='unexecuted'>            params.zeroForOne ? 0 : uint256(params.amount),</span>
  55 |     | <span class='unexecuted'>            params.zeroForOne ? uint256(params.amount) : 0</span>
  56 |     | <span class='neutral'>        );</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>        if (cache.liquidityMinted == 0) require (false, &#39;PositionLiquidityZero()&#39;);</span>
  59 |     | <span class='neutral'>        // calculate price limit by using half of input</span>
  60 |     | <span class='neutral'>        {</span>
  61 |     | <span class='unexecuted'>            cache.priceLimit = params.zeroForOne ? ConstantProduct.getNewPrice(cache.priceUpper, cache.liquidityMinted, params.amount / 2, true, true)</span>
  62 |     | <span class='unexecuted'>                                                 : ConstantProduct.getNewPrice(cache.priceLower, cache.liquidityMinted, params.amount / 2, false, true);</span>
  63 |     | <span class='unexecuted'>            if (cache.priceLimit == 0) require (false, &#39;PriceLimitZero()&#39;);</span>
  64 |     | <span class='neutral'>            // get tick at price</span>
  65 |     | <span class='unexecuted'>            cache.tickLimit = ConstantProduct.getTickAtPrice(cache.priceLimit.toUint160(), cache.constants);</span>
  66 |     | <span class='neutral'>            // round to nearest tick spacing</span>
  67 |     | <span class='unexecuted'>            cache.priceLimit = ConstantProduct.getPriceAtTick(cache.tickLimit, cache.constants);</span>
  68 |     | <span class='neutral'>        }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>        ILimitPoolStructs.SwapCache memory swapCache;</span>
  71 |     | <span class='unexecuted'>        swapCache.pool = cache.swapPool;</span>
  72 |     | <span class='unexecuted'>        swapCache.state = cache.state;</span>
  73 |     | <span class='unexecuted'>        swapCache.constants = cache.constants;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        // sync up pool epochs for position epoch stamping</span>
  76 |     | <span class='unexecuted'>        if (cache.pool.swapEpoch &lt; cache.swapPool.swapEpoch)</span>
  77 |     | <span class='unexecuted'>            cache.pool.swapEpoch = cache.swapPool.swapEpoch;</span>
  78 |     | <span class='unexecuted'>        else if (cache.swapPool.swapEpoch &lt; cache.pool.swapEpoch)</span>
  79 |     | <span class='unexecuted'>            cache.swapPool.swapEpoch = cache.pool.swapEpoch;</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        // only swap if priceLimit is beyond current pool price</span>
  82 |     | <span class='unexecuted'>        if (params.zeroForOne ? cache.priceLimit &lt; cache.swapPool.price</span>
  83 |     | <span class='unexecuted'>                              : cache.priceLimit &gt; cache.swapPool.price) {</span>
  84 |     | <span class='neutral'>            // swap and save the pool state</span>
  85 |     | <span class='unexecuted'>            (cache.swapPool, swapCache) = Ticks.swap(</span>
  86 |     | <span class='unexecuted'>                swapTicks,</span>
  87 |     | <span class='unexecuted'>                tickMap,</span>
  88 |     | <span class='unexecuted'>                ILimitPoolStructs.SwapParams({</span>
  89 |     | <span class='unexecuted'>                    to: params.to,</span>
  90 |     | <span class='unexecuted'>                    priceLimit: cache.priceLimit.toUint160(),</span>
  91 |     | <span class='unexecuted'>                    amount: params.amount,</span>
  92 |     | <span class='neutral'>                    //TODO: handle exactOut</span>
  93 |     | <span class='unexecuted'>                    exactIn: true,</span>
  94 |     | <span class='unexecuted'>                    zeroForOne: params.zeroForOne,</span>
  95 |     | <span class='unexecuted'>                    callbackData: abi.encodePacked(bytes1(0x0))</span>
  96 |     | <span class='neutral'>                }),</span>
  97 |     | <span class='unexecuted'>                swapCache,</span>
  98 |     | <span class='unexecuted'>                cache.swapPool</span>
  99 |     | <span class='neutral'>            );</span>
 100 |     | <span class='neutral'>            // subtract from remaining input amount</span>
 101 |     | <span class='unexecuted'>            params.amount -= uint128(swapCache.input);</span>
 102 |     | <span class='neutral'>        }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>        if (params.amount &lt; cache.mintSize) params.amount = 0;</span>
 105 |     | <span class='neutral'>        // move start tick based on amount filled in swap</span>
 106 |     | <span class='unexecuted'>        if ((params.amount &gt; 0 &amp;&amp; swapCache.input &gt; 0) ||</span>
 107 |     | <span class='unexecuted'>            (params.zeroForOne ? cache.priceLower &lt; cache.swapPool.price</span>
 108 |     | <span class='unexecuted'>                               : cache.priceUpper &gt; cache.swapPool.price)</span>
 109 |     | <span class='neutral'>        ) {</span>
 110 |     | <span class='neutral'>            // move the tick limit based on pool.tickAtPrice</span>
 111 |     | <span class='unexecuted'>            if (params.zeroForOne ? cache.priceLower &lt; cache.swapPool.price</span>
 112 |     | <span class='unexecuted'>                                  : cache.priceUpper &gt; cache.swapPool.price) {</span>
 113 |     | <span class='unexecuted'>                cache.tickLimit = cache.swapPool.tickAtPrice;</span>
 114 |     | <span class='neutral'>            }</span>
 115 |     | <span class='neutral'>            // round ahead tickLimit to avoid crossing epochs</span>
 116 |     | <span class='unexecuted'>            cache.tickLimit = TickMap.roundAhead(cache.tickLimit, cache.constants, params.zeroForOne, cache.swapPool.price);</span>
 117 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 118 |     | <span class='unexecuted'>                if (cache.priceLower &lt; cache.swapPool.price) {</span>
 119 |     | <span class='neutral'>                    // if rounding goes past limit trim position</span>
 120 |     | <span class='neutral'>                    /// @dev - if swap didn&#39;t go to limit user would be 100% filled</span>
 121 |     | <span class='unexecuted'>                    params.lower = cache.tickLimit;</span>
 122 |     | <span class='unexecuted'>                    cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 123 |     | <span class='neutral'>                }</span>
 124 |     | <span class='unexecuted'>                if (params.lower == params.upper &amp;&amp; params.upper &lt; ConstantProduct.maxTick(cache.constants.tickSpacing)) {</span>
 125 |     | <span class='unexecuted'>                    params.upper += cache.constants.tickSpacing;</span>
 126 |     | <span class='neutral'>                }</span>
 127 |     | <span class='unexecuted'>                cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 128 |     | <span class='neutral'>            } else {</span>
 129 |     | <span class='unexecuted'>                if (cache.priceUpper &gt; cache.swapPool.price) {</span>
 130 |     | <span class='neutral'>                    // if rounding goes past limit trim position</span>
 131 |     | <span class='unexecuted'>                    params.upper = cache.tickLimit;</span>
 132 |     | <span class='unexecuted'>                    cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 133 |     | <span class='neutral'>                }</span>
 134 |     | <span class='unexecuted'>                if (params.upper == params.lower &amp;&amp; params.lower &gt; ConstantProduct.minTick(cache.constants.tickSpacing)) {</span>
 135 |     | <span class='unexecuted'>                    params.lower -= cache.constants.tickSpacing;</span>
 136 |     | <span class='neutral'>                }</span>
 137 |     | <span class='unexecuted'>                cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 138 |     | <span class='neutral'>            }</span>
 139 |     | <span class='unexecuted'>            if (params.amount &gt; 0 &amp;&amp; params.lower &lt; params.upper)</span>
 140 |     | <span class='unexecuted'>                cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
 141 |     | <span class='unexecuted'>                    cache.priceLower,</span>
 142 |     | <span class='unexecuted'>                    cache.priceUpper,</span>
 143 |     | <span class='unexecuted'>                    params.zeroForOne ? cache.priceLower : cache.priceUpper,</span>
 144 |     | <span class='unexecuted'>                    params.zeroForOne ? 0 : uint256(params.amount),</span>
 145 |     | <span class='unexecuted'>                    params.zeroForOne ? uint256(params.amount) : 0</span>
 146 |     | <span class='neutral'>                );</span>
 147 |     | <span class='neutral'>            else</span>
 148 |     | <span class='neutral'>                /// @auditor unnecessary since params.amount is 0</span>
 149 |     | <span class='unexecuted'>                cache.liquidityMinted = 0;</span>
 150 |     | <span class='unexecuted'>            cache.pool.swapEpoch += 1;</span>
 151 |     | <span class='neutral'>        }</span>
 152 |     | <span class='neutral'>        // save swapCache</span>
 153 |     | <span class='unexecuted'>        cache.swapCache = swapCache;</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>        return (</span>
 156 |     | <span class='unexecuted'>            params,</span>
 157 |     | <span class='neutral'>            cache</span>
 158 |     | <span class='neutral'>        );</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>    function add(</span>
 162 |     | <span class='neutral'>        ILimitPoolStructs.MintCache memory cache,</span>
 163 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 164 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 165 |     | <span class='neutral'>        ILimitPoolStructs.MintParams memory params</span>
 166 |     | <span class='neutral'>    ) internal returns (</span>
 167 |     | <span class='unexecuted'>        ILimitPoolStructs.PoolState memory,</span>
 168 |     | <span class='unexecuted'>        ILimitPoolStructs.Position memory</span>
 169 |     | <span class='neutral'>    ) {</span>
 170 |     | <span class='unexecuted'>        if (cache.liquidityMinted == 0) return (cache.pool, cache.position);</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 173 |     | <span class='unexecuted'>            cache.position.epochLast = cache.pool.swapEpoch;</span>
 174 |     | <span class='neutral'>        } else {</span>
 175 |     | <span class='neutral'>            // safety check in case we somehow get here</span>
 176 |     | <span class='unexecuted'>            if (</span>
 177 |     | <span class='unexecuted'>                params.zeroForOne</span>
 178 |     | <span class='unexecuted'>                    ? EpochMap.get(params.lower, tickMap, cache.constants)</span>
 179 |     | <span class='unexecuted'>                            &gt; cache.position.epochLast</span>
 180 |     | <span class='unexecuted'>                    : EpochMap.get(params.upper, tickMap, cache.constants)</span>
 181 |     | <span class='unexecuted'>                            &gt; cache.position.epochLast</span>
 182 |     | <span class='neutral'>            ) {</span>
 183 |     | <span class='unexecuted'>                require (false, string.concat(&#39;UpdatePositionFirstAt(&#39;, String.from(params.lower), &#39;, &#39;, String.from(params.upper), &#39;)&#39;));</span>
 184 |     | <span class='neutral'>            }</span>
 185 |     | <span class='neutral'>            /// @auditor maybe this shouldn&#39;t be a revert but rather just not mint the position?</span>
 186 |     | <span class='neutral'>        }</span>
 187 |     | <span class='neutral'>        </span>
 188 |     | <span class='neutral'>        // add liquidity to ticks</span>
 189 |     | <span class='unexecuted'>        Ticks.insert(</span>
 190 |     | <span class='unexecuted'>            ticks,</span>
 191 |     | <span class='unexecuted'>            tickMap,</span>
 192 |     | <span class='unexecuted'>            cache,</span>
 193 |     | <span class='unexecuted'>            params</span>
 194 |     | <span class='neutral'>        );</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>        // update liquidity global</span>
 197 |     | <span class='unexecuted'>        cache.pool.liquidityGlobal += uint128(cache.liquidityMinted);</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='unexecuted'>        cache.position.liquidity += uint128(cache.liquidityMinted);</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='unexecuted'>        return (cache.pool, cache.position);</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>    function remove(</span>
 205 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.Position)))</span>
 206 |     | <span class='neutral'>            storage positions,</span>
 207 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 208 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 209 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool,</span>
 210 |     | <span class='neutral'>        ILimitPoolStructs.UpdateParams memory params,</span>
 211 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
 212 |     | <span class='neutral'>    ) internal returns (</span>
 213 |     | <span class='unexecuted'>        ILimitPoolStructs.PoolState memory,</span>
 214 |     | <span class='unexecuted'>        ILimitPoolStructs.Position memory</span>
 215 |     | <span class='neutral'>    ) {</span>
 216 |     | <span class='neutral'>        // initialize cache</span>
 217 |     | <span class='unexecuted'>        ILimitPoolStructs.UpdateCache memory cache;</span>
 218 |     | <span class='unexecuted'>        cache.position = positions[msg.sender][params.lower][params.upper];</span>
 219 |     | <span class='unexecuted'>        cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, constants);</span>
 220 |     | <span class='unexecuted'>        cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, constants);</span>
 221 |     | <span class='unexecuted'>        cache.removeLower = true; cache.removeUpper = true;</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>        // convert percentage to liquidity amount</span>
 224 |     | <span class='unexecuted'>        params.amount = _convert(cache.position.liquidity, params.amount);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>        // early return if no liquidity to remove</span>
 227 |     | <span class='unexecuted'>        if (params.amount == 0) return (pool, cache.position);</span>
 228 |     | <span class='unexecuted'>        if (params.amount &gt; cache.position.liquidity) {</span>
 229 |     | <span class='unexecuted'>            require (false, &#39;NotEnoughPositionLiquidity()&#39;);</span>
 230 |     | <span class='neutral'>        }</span>
 231 |     | <span class='neutral'>        /// @dev - validate position has not been crossed into</span>
 232 |     | <span class='unexecuted'>        if (params.zeroForOne) {</span>
 233 |     | <span class='unexecuted'>            if (EpochMap.get(params.lower, tickMap, constants)</span>
 234 |     | <span class='unexecuted'>                        &gt; cache.position.epochLast) {</span>
 235 |     | <span class='unexecuted'>                int24 nextTick = TickMap.next(tickMap, params.lower, constants.tickSpacing, false);</span>
 236 |     | <span class='unexecuted'>                if (pool.price &gt; cache.priceLower ||</span>
 237 |     | <span class='unexecuted'>                    EpochMap.get(nextTick, tickMap, constants)</span>
 238 |     | <span class='unexecuted'>                        &gt; cache.position.epochLast) {</span>
 239 |     | <span class='unexecuted'>                    require (false, &#39;WrongTickClaimedAt7()&#39;);            </span>
 240 |     | <span class='neutral'>                }</span>
 241 |     | <span class='unexecuted'>                if (pool.price == cache.priceLower) {</span>
 242 |     | <span class='unexecuted'>                    EchidnaAssertions.assertLiquidityUnderflows(pool.liquidity, params.amount, &quot;PLU-1&quot;);</span>
 243 |     | <span class='unexecuted'>                    pool.liquidity -= params.amount;</span>
 244 |     | <span class='neutral'>                }</span>
 245 |     | <span class='neutral'>            }</span>
 246 |     | <span class='neutral'>            // if pool price is further along</span>
 247 |     | <span class='neutral'>            // OR next tick has a greater epoch</span>
 248 |     | <span class='neutral'>        } else {</span>
 249 |     | <span class='unexecuted'>            if (EpochMap.get(params.upper, tickMap, constants)</span>
 250 |     | <span class='unexecuted'>                        &gt; cache.position.epochLast) {</span>
 251 |     | <span class='unexecuted'>                int24 previousTick = TickMap.previous(tickMap, params.upper, constants.tickSpacing, false);</span>
 252 |     | <span class='unexecuted'>                if (pool.price &lt; cache.priceUpper ||</span>
 253 |     | <span class='unexecuted'>                    EpochMap.get(previousTick, tickMap, constants)</span>
 254 |     | <span class='unexecuted'>                        &gt; cache.position.epochLast) {</span>
 255 |     | <span class='unexecuted'>                    require (false, &#39;WrongTickClaimedAt8()&#39;);            </span>
 256 |     | <span class='neutral'>                }</span>
 257 |     | <span class='unexecuted'>                if (pool.price == cache.priceUpper) {</span>
 258 |     | <span class='unexecuted'>                    EchidnaAssertions.assertLiquidityUnderflows(pool.liquidity, params.amount, &quot;PLU-2&quot;);</span>
 259 |     | <span class='unexecuted'>                    pool.liquidity -= params.amount;</span>
 260 |     | <span class='neutral'>                }</span>
 261 |     | <span class='neutral'>            }</span>
 262 |     | <span class='neutral'>        }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='unexecuted'>        Ticks.remove(</span>
 265 |     | <span class='unexecuted'>            ticks,</span>
 266 |     | <span class='unexecuted'>            tickMap,</span>
 267 |     | <span class='unexecuted'>            cache,</span>
 268 |     | <span class='unexecuted'>            params,</span>
 269 |     | <span class='unexecuted'>            constants</span>
 270 |     | <span class='neutral'>        );</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>        // update liquidity global</span>
 273 |     | <span class='unexecuted'>        EchidnaAssertions.assertLiquidityGlobalUnderflows(pool.liquidityGlobal, params.amount, &quot;LGU-1&quot;);</span>
 274 |     | <span class='unexecuted'>        pool.liquidityGlobal -= params.amount;</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='unexecuted'>        cache.position.amountOut += uint128(</span>
 277 |     | <span class='unexecuted'>            params.zeroForOne</span>
 278 |     | <span class='unexecuted'>                ? ConstantProduct.getDx(params.amount, cache.priceLower, cache.priceUpper, false)</span>
 279 |     | <span class='unexecuted'>                : ConstantProduct.getDy(params.amount, cache.priceLower, cache.priceUpper, false)</span>
 280 |     | <span class='neutral'>        );</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='unexecuted'>        cache.position.liquidity -= uint128(params.amount);</span>
 283 |     | <span class='unexecuted'>        positions[msg.sender][params.lower][params.upper] = cache.position;</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='unexecuted'>        if (params.amount &gt; 0) {</span>
 286 |     | <span class='unexecuted'>            emit BurnLimit(</span>
 287 |     | <span class='unexecuted'>                    params.to,</span>
 288 |     | <span class='unexecuted'>                    params.lower,</span>
 289 |     | <span class='unexecuted'>                    params.upper,</span>
 290 |     | <span class='unexecuted'>                    params.zeroForOne ? params.lower : params.upper,</span>
 291 |     | <span class='unexecuted'>                    params.zeroForOne,</span>
 292 |     | <span class='unexecuted'>                    params.amount,</span>
 293 |     | <span class='unexecuted'>                    0,</span>
 294 |     | <span class='unexecuted'>                    cache.position.amountOut</span>
 295 |     | <span class='neutral'>            );</span>
 296 |     | <span class='neutral'>        }</span>
 297 |     | <span class='unexecuted'>        return (pool, cache.position);</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='unexecuted'>    function update(</span>
 301 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.Position)))</span>
 302 |     | <span class='neutral'>            storage positions,</span>
 303 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 304 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 305 |     | <span class='neutral'>        ILimitPoolStructs.GlobalState memory state,</span>
 306 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool,</span>
 307 |     | <span class='neutral'>        ILimitPoolStructs.UpdateParams memory params,</span>
 308 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
 309 |     | <span class='neutral'>    ) internal returns (</span>
 310 |     | <span class='neutral'>        ILimitPoolStructs.GlobalState memory,</span>
 311 |     | <span class='unexecuted'>        ILimitPoolStructs.PoolState memory,</span>
 312 |     | <span class='unexecuted'>        ILimitPoolStructs.Position memory,</span>
 313 |     | <span class='unexecuted'>        int24</span>
 314 |     | <span class='neutral'>    )</span>
 315 |     | <span class='neutral'>    {</span>
 316 |     | <span class='unexecuted'>        ILimitPoolStructs.UpdateCache memory cache;</span>
 317 |     | <span class='unexecuted'>        (</span>
 318 |     | <span class='neutral'>            params,</span>
 319 |     | <span class='neutral'>            cache,</span>
 320 |     | <span class='neutral'>            state</span>
 321 |     | <span class='unexecuted'>        ) = _deltas(</span>
 322 |     | <span class='unexecuted'>            positions,</span>
 323 |     | <span class='unexecuted'>            ticks,</span>
 324 |     | <span class='unexecuted'>            tickMap,</span>
 325 |     | <span class='unexecuted'>            state,</span>
 326 |     | <span class='unexecuted'>            pool,</span>
 327 |     | <span class='unexecuted'>            params,</span>
 328 |     | <span class='unexecuted'>            constants</span>
 329 |     | <span class='neutral'>        );</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='unexecuted'>        if (cache.earlyReturn)</span>
 332 |     | <span class='unexecuted'>            return (state, pool, cache.position, params.claim);</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>        // update pool liquidity</span>
 335 |     | <span class='unexecuted'>        if (cache.priceClaim == pool.price &amp;&amp; params.amount &gt; 0) {</span>
 336 |     | <span class='neutral'>            // handle pool.price at edge of range</span>
 337 |     | <span class='unexecuted'>            if (params.zeroForOne ? cache.priceClaim &lt; cache.priceUpper</span>
 338 |     | <span class='unexecuted'>                                  : cache.priceClaim &gt; cache.priceLower) {</span>
 339 |     | <span class='unexecuted'>                EchidnaAssertions.assertLiquidityUnderflows(pool.liquidity, params.amount, &quot;PLU-3&quot;);</span>
 340 |     | <span class='unexecuted'>                pool.liquidity -= params.amount;</span>
 341 |     | <span class='neutral'>            }</span>
 342 |     | <span class='neutral'>        }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='unexecuted'>        if (params.amount &gt; 0) {</span>
 346 |     | <span class='unexecuted'>            if (params.claim == (params.zeroForOne ? params.upper : params.lower)) {</span>
 347 |     | <span class='neutral'>                // only remove once if final tick of position</span>
 348 |     | <span class='unexecuted'>                cache.removeLower = false;</span>
 349 |     | <span class='unexecuted'>                cache.removeUpper = false;</span>
 350 |     | <span class='neutral'>            } else {</span>
 351 |     | <span class='unexecuted'>                params.zeroForOne ? cache.removeUpper = true </span>
 352 |     | <span class='unexecuted'>                                  : cache.removeLower = true;</span>
 353 |     | <span class='neutral'>            }</span>
 354 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 355 |     | <span class='unexecuted'>                if (params.claim == params.lower &amp;&amp; </span>
 356 |     | <span class='unexecuted'>                    cache.pool.price &lt; cache.priceLower</span>
 357 |     | <span class='neutral'>                ) {</span>
 358 |     | <span class='unexecuted'>                    cache.removeLower = true;</span>
 359 |     | <span class='unexecuted'>                } else if (params.claim % constants.tickSpacing != 0 &amp;&amp; </span>
 360 |     | <span class='unexecuted'>                    cache.pool.price &lt; cache.priceClaim)</span>
 361 |     | <span class='unexecuted'>                    cache.removeLower = true;</span>
 362 |     | <span class='neutral'>            } else {</span>
 363 |     | <span class='unexecuted'>                if (params.claim == params.upper &amp;&amp;</span>
 364 |     | <span class='unexecuted'>                    cache.pool.price &gt; cache.priceUpper</span>
 365 |     | <span class='neutral'>                )</span>
 366 |     | <span class='unexecuted'>                    cache.removeUpper = true;</span>
 367 |     | <span class='unexecuted'>                else if (params.claim % constants.tickSpacing != 0 &amp;&amp;</span>
 368 |     | <span class='unexecuted'>                            cache.pool.price &gt; cache.priceClaim)</span>
 369 |     | <span class='unexecuted'>                    cache.removeUpper = true;</span>
 370 |     | <span class='neutral'>            }</span>
 371 |     | <span class='unexecuted'>            Ticks.remove(</span>
 372 |     | <span class='unexecuted'>                ticks,</span>
 373 |     | <span class='unexecuted'>                tickMap,</span>
 374 |     | <span class='unexecuted'>                cache,</span>
 375 |     | <span class='unexecuted'>                params,</span>
 376 |     | <span class='unexecuted'>                constants</span>
 377 |     | <span class='neutral'>            );</span>
 378 |     | <span class='neutral'>            // update position liquidity</span>
 379 |     | <span class='unexecuted'>            cache.position.liquidity -= uint128(params.amount);</span>
 380 |     | <span class='neutral'>            // update global liquidity</span>
 381 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityGlobalUnderflows(pool.liquidityGlobal, params.amount, &quot;LGU-2&quot;);</span>
 382 |     | <span class='unexecuted'>            pool.liquidityGlobal -= params.amount;</span>
 383 |     | <span class='neutral'>        }</span>
 384 |     | <span class='unexecuted'>        if (params.zeroForOne ? params.claim == params.upper</span>
 385 |     | <span class='unexecuted'>                              : params.claim == params.lower) {</span>
 386 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityGlobalUnderflows(pool.liquidityGlobal, cache.position.liquidity, &quot;LGU-3&quot;);</span>
 387 |     | <span class='unexecuted'>            pool.liquidityGlobal -= cache.position.liquidity;</span>
 388 |     | <span class='unexecuted'>            cache.position.liquidity = 0;</span>
 389 |     | <span class='neutral'>        }</span>
 390 |     | <span class='neutral'>        // clear out old position</span>
 391 |     | <span class='unexecuted'>        if (params.zeroForOne ? params.claim != params.lower </span>
 392 |     | <span class='unexecuted'>                              : params.claim != params.upper) {</span>
 393 |     | <span class='neutral'>            </span>
 394 |     | <span class='neutral'>            /// @dev - this also clears out position end claims</span>
 395 |     | <span class='unexecuted'>            if (params.zeroForOne ? params.claim == params.lower </span>
 396 |     | <span class='unexecuted'>                                  : params.claim == params.upper) {</span>
 397 |     | <span class='neutral'>                // subtract remaining position liquidity out from global</span>
 398 |     | <span class='unexecuted'>                EchidnaAssertions.assertLiquidityGlobalUnderflows(pool.liquidityGlobal, cache.position.liquidity, &quot;LGU-4&quot;);</span>
 399 |     | <span class='unexecuted'>                pool.liquidityGlobal -= cache.position.liquidity;</span>
 400 |     | <span class='neutral'>            }</span>
 401 |     | <span class='unexecuted'>            delete positions[msg.sender][params.lower][params.upper];</span>
 402 |     | <span class='neutral'>        }</span>
 403 |     | <span class='neutral'>        // clear position if empty</span>
 404 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 405 |     | <span class='unexecuted'>            cache.position.epochLast = 0;</span>
 406 |     | <span class='unexecuted'>            cache.position.claimPriceLast = 0;</span>
 407 |     | <span class='neutral'>        }</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'>        // round back claim tick for storage</span>
 410 |     | <span class='unexecuted'>        if (params.claim % constants.tickSpacing != 0)</span>
 411 |     | <span class='unexecuted'>            params.claim = TickMap.roundBack(params.claim, constants, params.zeroForOne, cache.priceClaim);</span>
 412 |     | <span class='neutral'>        </span>
 413 |     | <span class='unexecuted'>        emit BurnLimit(</span>
 414 |     | <span class='unexecuted'>            params.to,</span>
 415 |     | <span class='unexecuted'>            params.lower,</span>
 416 |     | <span class='unexecuted'>            params.upper,</span>
 417 |     | <span class='unexecuted'>            params.claim,</span>
 418 |     | <span class='unexecuted'>            params.zeroForOne,</span>
 419 |     | <span class='unexecuted'>            params.amount,</span>
 420 |     | <span class='unexecuted'>            cache.position.amountIn,</span>
 421 |     | <span class='unexecuted'>            cache.position.amountOut</span>
 422 |     | <span class='neutral'>        );</span>
 423 |     | <span class='neutral'>        // return cached position in memory and transfer out</span>
 424 |     | <span class='unexecuted'>        return (state, pool, cache.position, params.claim);</span>
 425 |     | <span class='neutral'>    }</span>
 426 |     | <span class='neutral'></span>
 427 |     | <span class='unexecuted'>    function snapshot(</span>
 428 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.Position)))</span>
 429 |     | <span class='neutral'>            storage positions,</span>
 430 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 431 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 432 |     | <span class='neutral'>        ILimitPoolStructs.GlobalState memory state,</span>
 433 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool,</span>
 434 |     | <span class='neutral'>        ILimitPoolStructs.UpdateParams memory params,</span>
 435 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
 436 |     | <span class='neutral'>    ) internal view returns (</span>
 437 |     | <span class='unexecuted'>        ILimitPoolStructs.Position memory</span>
 438 |     | <span class='neutral'>    ) {</span>
 439 |     | <span class='unexecuted'>        ILimitPoolStructs.UpdateCache memory cache;</span>
 440 |     | <span class='unexecuted'>        (</span>
 441 |     | <span class='neutral'>            params,</span>
 442 |     | <span class='neutral'>            cache,</span>
 443 |     | <span class='neutral'>            state</span>
 444 |     | <span class='unexecuted'>        ) = _deltas(</span>
 445 |     | <span class='unexecuted'>            positions,</span>
 446 |     | <span class='unexecuted'>            ticks,</span>
 447 |     | <span class='unexecuted'>            tickMap,</span>
 448 |     | <span class='unexecuted'>            state,</span>
 449 |     | <span class='unexecuted'>            pool,</span>
 450 |     | <span class='unexecuted'>            params,</span>
 451 |     | <span class='unexecuted'>            constants</span>
 452 |     | <span class='neutral'>        );</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='unexecuted'>        if (cache.earlyReturn)</span>
 455 |     | <span class='unexecuted'>            return (cache.position);</span>
 456 |     | <span class='neutral'></span>
 457 |     | <span class='unexecuted'>        if (params.amount &gt; 0) {</span>
 458 |     | <span class='unexecuted'>            cache.position.liquidity -= uint128(params.amount);</span>
 459 |     | <span class='neutral'>        }</span>
 460 |     | <span class='neutral'>        </span>
 461 |     | <span class='neutral'>        // clear position values if empty</span>
 462 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 463 |     | <span class='unexecuted'>            cache.position.epochLast = 0;</span>
 464 |     | <span class='unexecuted'>            cache.position.claimPriceLast = 0;</span>
 465 |     | <span class='neutral'>        }    </span>
 466 |     | <span class='unexecuted'>        return cache.position;</span>
 467 |     | <span class='neutral'>    }</span>
 468 |     | <span class='neutral'></span>
 469 |     | <span class='unexecuted'>    function _convert(</span>
 470 |     | <span class='neutral'>        uint128 liquidity,</span>
 471 |     | <span class='neutral'>        uint128 percent</span>
 472 |     | <span class='neutral'>    ) internal pure returns (</span>
 473 |     | <span class='unexecuted'>        uint128</span>
 474 |     | <span class='neutral'>    ) {</span>
 475 |     | <span class='neutral'>        // convert percentage to liquidity amount</span>
 476 |     | <span class='unexecuted'>        if (percent &gt; 1e38) percent = 1e38;</span>
 477 |     | <span class='unexecuted'>        if (liquidity == 0 &amp;&amp; percent &gt; 0) require (false, &#39;NotEnoughPositionLiquidity()&#39;);</span>
 478 |     | <span class='unexecuted'>        return uint128(uint256(liquidity) * uint256(percent) / 1e38);</span>
 479 |     | <span class='neutral'>    }</span>
 480 |     | <span class='neutral'></span>
 481 |     | <span class='unexecuted'>    function _deltas(</span>
 482 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.Position)))</span>
 483 |     | <span class='neutral'>            storage positions,</span>
 484 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 485 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 486 |     | <span class='neutral'>        ILimitPoolStructs.GlobalState memory state,</span>
 487 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool,</span>
 488 |     | <span class='neutral'>        ILimitPoolStructs.UpdateParams memory params,</span>
 489 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
 490 |     | <span class='neutral'>    ) internal view returns (</span>
 491 |     | <span class='neutral'>        ILimitPoolStructs.UpdateParams memory,</span>
 492 |     | <span class='unexecuted'>        ILimitPoolStructs.UpdateCache memory,</span>
 493 |     | <span class='neutral'>        ILimitPoolStructs.GlobalState memory</span>
 494 |     | <span class='neutral'>    ) {</span>
 495 |     | <span class='unexecuted'>        ILimitPoolStructs.UpdateCache memory cache = ILimitPoolStructs.UpdateCache({</span>
 496 |     | <span class='unexecuted'>            position: positions[params.owner][params.lower][params.upper],</span>
 497 |     | <span class='unexecuted'>            pool: pool,</span>
 498 |     | <span class='unexecuted'>            priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),</span>
 499 |     | <span class='unexecuted'>            priceClaim: ConstantProduct.getPriceAtTick(params.claim, constants),</span>
 500 |     | <span class='unexecuted'>            priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),</span>
 501 |     | <span class='unexecuted'>            claimTick: ticks[params.claim],</span>
 502 |     | <span class='unexecuted'>            earlyReturn: false,</span>
 503 |     | <span class='unexecuted'>            removeLower: false,</span>
 504 |     | <span class='unexecuted'>            removeUpper: false</span>
 505 |     | <span class='neutral'>        });</span>
 506 |     | <span class='neutral'></span>
 507 |     | <span class='unexecuted'>        params.amount = _convert(cache.position.liquidity, params.amount);</span>
 508 |     | <span class='neutral'></span>
 509 |     | <span class='neutral'>        // check claim is valid</span>
 510 |     | <span class='unexecuted'>        (params, cache) = Claims.validate(</span>
 511 |     | <span class='unexecuted'>            positions,</span>
 512 |     | <span class='unexecuted'>            ticks,</span>
 513 |     | <span class='unexecuted'>            tickMap,</span>
 514 |     | <span class='unexecuted'>            cache.pool,</span>
 515 |     | <span class='neutral'>            params,</span>
 516 |     | <span class='neutral'>            cache,</span>
 517 |     | <span class='unexecuted'>            constants</span>
 518 |     | <span class='neutral'>        );</span>
 519 |     | <span class='unexecuted'>        if (cache.earlyReturn) {</span>
 520 |     | <span class='unexecuted'>            return (params, cache, state);</span>
 521 |     | <span class='neutral'>        }</span>
 522 |     | <span class='neutral'>        // calculate position deltas</span>
 523 |     | <span class='unexecuted'>        cache = Claims.getDeltas(cache, params, constants);</span>
 524 |     | <span class='neutral'></span>
 525 |     | <span class='unexecuted'>        return (params, cache, state);</span>
 526 |     | <span class='neutral'>    }</span>
 527 |     | <span class='neutral'>}</span>
 528 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/TickMap.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./math/ConstantProduct.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../interfaces/ILimitPool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../interfaces/ILimitPoolStructs.sol&#39;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>library TickMap {</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>    error TickIndexOverflow();</span>
  11 |     | <span class='neutral'>    error TickIndexUnderflow();</span>
  12 |     | <span class='neutral'>    error TickIndexBadSpacing();</span>
  13 |     | <span class='neutral'>    error BlockIndexOverflow();</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    function get(</span>
  16 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
  17 |     | <span class='neutral'>        int24 tick,</span>
  18 |     | <span class='neutral'>        int24 tickSpacing</span>
  19 |     | <span class='neutral'>    ) internal view returns (</span>
  20 |     | <span class='neutral'>        bool exists</span>
  21 |     | <span class='neutral'>    ) {</span>
  22 |     | <span class='neutral'>        (</span>
  23 |     | <span class='neutral'>            uint256 tickIndex,</span>
  24 |     | <span class='neutral'>            uint256 wordIndex,</span>
  25 |     | <span class='neutral'>        ) = getIndices(tick, tickSpacing);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>        // check if bit is already set</span>
  28 |     | <span class='neutral'>        uint256 word = tickMap.ticks[wordIndex] | 1 &lt;&lt; (tickIndex &amp; 0xFF);</span>
  29 |     | <span class='neutral'>        if (word == tickMap.ticks[wordIndex]) {</span>
  30 |     | <span class='neutral'>            return true;</span>
  31 |     | <span class='neutral'>        }</span>
  32 |     | <span class='neutral'>        return false;</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function set(</span>
  36 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
  37 |     | <span class='neutral'>        int24 tick,</span>
  38 |     | <span class='neutral'>        int24 tickSpacing</span>
  39 |     | <span class='neutral'>    ) internal returns (</span>
  40 |     | <span class='unexecuted'>        bool exists</span>
  41 |     | <span class='neutral'>    ) {</span>
  42 |     | <span class='unexecuted'>        (</span>
  43 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  44 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  45 |     | <span class='unexecuted'>            uint256 blockIndex</span>
  46 |     | <span class='unexecuted'>        ) = getIndices(tick, tickSpacing);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>        // check if bit is already set</span>
  49 |     | <span class='unexecuted'>        uint256 word = tickMap.ticks[wordIndex] | 1 &lt;&lt; (tickIndex &amp; 0xFF);</span>
  50 |     | <span class='unexecuted'>        if (word == tickMap.ticks[wordIndex]) {</span>
  51 |     | <span class='unexecuted'>            return true;</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>        tickMap.ticks[wordIndex]     = word; </span>
  55 |     | <span class='unexecuted'>        tickMap.words[blockIndex]   |= 1 &lt;&lt; (wordIndex &amp; 0xFF); // same as modulus 255</span>
  56 |     | <span class='unexecuted'>        tickMap.blocks              |= 1 &lt;&lt; blockIndex;</span>
  57 |     | <span class='neutral'>        return false;</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>    function unset(</span>
  61 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
  62 |     | <span class='neutral'>        int24 tick,</span>
  63 |     | <span class='neutral'>        int16 tickSpacing</span>
  64 |     | <span class='unexecuted'>    ) internal {</span>
  65 |     | <span class='unexecuted'>        (</span>
  66 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  67 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  68 |     | <span class='unexecuted'>            uint256 blockIndex</span>
  69 |     | <span class='unexecuted'>        ) = getIndices(tick, tickSpacing);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>        tickMap.ticks[wordIndex] &amp;= ~(1 &lt;&lt; (tickIndex &amp; 0xFF));</span>
  72 |     | <span class='unexecuted'>        if (tickMap.ticks[wordIndex] == 0) {</span>
  73 |     | <span class='unexecuted'>            tickMap.words[blockIndex] &amp;= ~(1 &lt;&lt; (wordIndex &amp; 0xFF));</span>
  74 |     | <span class='unexecuted'>            if (tickMap.words[blockIndex] == 0) {</span>
  75 |     | <span class='unexecuted'>                tickMap.blocks &amp;= ~(1 &lt;&lt; blockIndex);</span>
  76 |     | <span class='neutral'>            }</span>
  77 |     | <span class='neutral'>        }</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>    function previous(</span>
  81 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
  82 |     | <span class='neutral'>        int24 tick,</span>
  83 |     | <span class='neutral'>        int16 tickSpacing,</span>
  84 |     | <span class='neutral'>        bool inclusive</span>
  85 |     | <span class='neutral'>    ) internal view returns (</span>
  86 |     | <span class='unexecuted'>        int24 previousTick</span>
  87 |     | <span class='neutral'>    ) {</span>
  88 |     | <span class='neutral'>        unchecked {</span>
  89 |     | <span class='neutral'>            // rounds up to ensure relative position</span>
  90 |     | <span class='unexecuted'>            if (tick % (tickSpacing / 2) != 0 || inclusive) {</span>
  91 |     | <span class='unexecuted'>                if (tick &lt; (ConstantProduct.maxTick(tickSpacing) - tickSpacing / 2)) {</span>
  92 |     | <span class='neutral'>                    /// @dev - ensures we cross when tick &gt;= 0</span>
  93 |     | <span class='unexecuted'>                    if (tick &gt;= 0) {</span>
  94 |     | <span class='unexecuted'>                        tick += tickSpacing / 2;</span>
  95 |     | <span class='unexecuted'>                    } else if (inclusive &amp;&amp; tick % (tickSpacing / 2) == 0) {</span>
  96 |     | <span class='neutral'>                    /// @dev - ensures we cross when tick == tickAtPrice</span>
  97 |     | <span class='unexecuted'>                        tick += tickSpacing / 2;</span>
  98 |     | <span class='neutral'>                    }</span>
  99 |     | <span class='neutral'>                }</span>
 100 |     | <span class='neutral'>            }</span>
 101 |     | <span class='unexecuted'>            (</span>
 102 |     | <span class='unexecuted'>              uint256 tickIndex,</span>
 103 |     | <span class='unexecuted'>              uint256 wordIndex,</span>
 104 |     | <span class='unexecuted'>              uint256 blockIndex</span>
 105 |     | <span class='unexecuted'>            ) = getIndices(tick, tickSpacing);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>            uint256 word = tickMap.ticks[wordIndex] &amp; ((1 &lt;&lt; (tickIndex &amp; 0xFF)) - 1);</span>
 108 |     | <span class='unexecuted'>            if (word == 0) {</span>
 109 |     | <span class='unexecuted'>                uint256 block_ = tickMap.words[blockIndex] &amp; ((1 &lt;&lt; (wordIndex &amp; 0xFF)) - 1);</span>
 110 |     | <span class='unexecuted'>                if (block_ == 0) {</span>
 111 |     | <span class='unexecuted'>                    uint256 blockMap = tickMap.blocks &amp; ((1 &lt;&lt; blockIndex) - 1);</span>
 112 |     | <span class='unexecuted'>                    if (blockMap == 0) return tick;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>                    blockIndex = _msb(blockMap);</span>
 115 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex];</span>
 116 |     | <span class='neutral'>                }</span>
 117 |     | <span class='unexecuted'>                wordIndex = (blockIndex &lt;&lt; 8) | _msb(block_);</span>
 118 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex];</span>
 119 |     | <span class='neutral'>            }</span>
 120 |     | <span class='unexecuted'>            previousTick = _tick((wordIndex &lt;&lt; 8) | _msb(word), tickSpacing);</span>
 121 |     | <span class='neutral'>        }</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>    function next(</span>
 125 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 126 |     | <span class='neutral'>        int24 tick,</span>
 127 |     | <span class='neutral'>        int16 tickSpacing,</span>
 128 |     | <span class='neutral'>        bool inclusive</span>
 129 |     | <span class='neutral'>    ) internal view returns (</span>
 130 |     | <span class='unexecuted'>        int24 nextTick</span>
 131 |     | <span class='neutral'>    ) {</span>
 132 |     | <span class='unexecuted'>        unchecked {</span>
 133 |     | <span class='neutral'>            /// @dev - handles tickAtPrice being past tickSpacing / 2</span>
 134 |     | <span class='unexecuted'>            if (inclusive &amp;&amp; tick % tickSpacing != 0) {</span>
 135 |     | <span class='unexecuted'>                tick -= 1;</span>
 136 |     | <span class='neutral'>            }</span>
 137 |     | <span class='neutral'>            /// @dev - handles negative ticks rounding up</span>
 138 |     | <span class='unexecuted'>            if (tick % (tickSpacing / 2) != 0) {</span>
 139 |     | <span class='unexecuted'>                if (tick &lt; 0)</span>
 140 |     | <span class='unexecuted'>                    if (tick &gt; (ConstantProduct.minTick(tickSpacing) + tickSpacing / 2))</span>
 141 |     | <span class='unexecuted'>                        tick -= tickSpacing / 2;</span>
 142 |     | <span class='neutral'>            }</span>
 143 |     | <span class='unexecuted'>            (</span>
 144 |     | <span class='unexecuted'>              uint256 tickIndex,</span>
 145 |     | <span class='unexecuted'>              uint256 wordIndex,</span>
 146 |     | <span class='unexecuted'>              uint256 blockIndex</span>
 147 |     | <span class='unexecuted'>            ) = getIndices(tick, tickSpacing);</span>
 148 |     | <span class='unexecuted'>            uint256 word;</span>
 149 |     | <span class='unexecuted'>            if ((tickIndex &amp; 0xFF) != 255) {</span>
 150 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex] &amp; ~((1 &lt;&lt; ((tickIndex &amp; 0xFF) + 1)) - 1);</span>
 151 |     | <span class='neutral'>            }</span>
 152 |     | <span class='unexecuted'>            if (word == 0) {</span>
 153 |     | <span class='unexecuted'>                uint256 block_;</span>
 154 |     | <span class='unexecuted'>                if ((blockIndex &amp; 0xFF) != 255) {</span>
 155 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex] &amp; ~((1 &lt;&lt; ((wordIndex &amp; 0xFF) + 1)) - 1);</span>
 156 |     | <span class='neutral'>                }</span>
 157 |     | <span class='unexecuted'>                if (block_ == 0) {</span>
 158 |     | <span class='unexecuted'>                    uint256 blockMap = tickMap.blocks &amp; ~((1 &lt;&lt; blockIndex + 1) - 1);</span>
 159 |     | <span class='unexecuted'>                    if (blockMap == 0) return tick;</span>
 160 |     | <span class='unexecuted'>                    blockIndex = _lsb(blockMap);</span>
 161 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex];</span>
 162 |     | <span class='neutral'>                }</span>
 163 |     | <span class='unexecuted'>                wordIndex = (blockIndex &lt;&lt; 8) | _lsb(block_);</span>
 164 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex];</span>
 165 |     | <span class='neutral'>            }</span>
 166 |     | <span class='unexecuted'>            nextTick = _tick((wordIndex &lt;&lt; 8) | _lsb(word), tickSpacing);</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>    function getIndices(</span>
 171 |     | <span class='neutral'>        int24 tick,</span>
 172 |     | <span class='neutral'>        int24 tickSpacing</span>
 173 |     | <span class='neutral'>    ) internal pure returns (</span>
 174 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
 175 |     | <span class='neutral'>            uint256 wordIndex,</span>
 176 |     | <span class='neutral'>            uint256 blockIndex</span>
 177 |     | <span class='neutral'>        )</span>
 178 |     | <span class='neutral'>    {</span>
 179 |     | <span class='neutral'>        unchecked {</span>
 180 |     | <span class='unexecuted'>            if (tick &gt; ConstantProduct.MAX_TICK) require(false, &#39; TickIndexOverflow()&#39;);</span>
 181 |     | <span class='unexecuted'>            if (tick &lt; ConstantProduct.MIN_TICK) require(false, &#39;TickIndexUnderflow()&#39;);</span>
 182 |     | <span class='unexecuted'>            if (tick % (tickSpacing / 2) != 0) tick = round(tick, tickSpacing / 2);</span>
 183 |     | <span class='unexecuted'>            tickIndex = uint256(int256((round(tick, tickSpacing / 2) </span>
 184 |     | <span class='unexecuted'>                                        - round(ConstantProduct.MIN_TICK, tickSpacing / 2)) </span>
 185 |     | <span class='unexecuted'>                                        / (tickSpacing / 2)));</span>
 186 |     | <span class='unexecuted'>            wordIndex = tickIndex &gt;&gt; 8;   // 2^8 ticks per word</span>
 187 |     | <span class='unexecuted'>            blockIndex = tickIndex &gt;&gt; 16; // 2^8 words per block</span>
 188 |     | <span class='unexecuted'>            if (blockIndex &gt; 255) require(false, &#39;BlockIndexOverflow()&#39;);</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='unexecuted'>    function _tick (</span>
 195 |     | <span class='neutral'>        uint256 tickIndex,</span>
 196 |     | <span class='neutral'>        int24 tickSpacing</span>
 197 |     | <span class='neutral'>    ) internal pure returns (</span>
 198 |     | <span class='unexecuted'>        int24 tick</span>
 199 |     | <span class='neutral'>    ) {</span>
 200 |     | <span class='neutral'>        unchecked {</span>
 201 |     | <span class='unexecuted'>            if (tickIndex &gt; uint24(round(ConstantProduct.MAX_TICK, tickSpacing) * 2) * 2) </span>
 202 |     | <span class='unexecuted'>                require(false, &#39;TickIndexOverflow()&#39;);</span>
 203 |     | <span class='unexecuted'>            tick = int24(int256(tickIndex) * (tickSpacing / 2) + round(ConstantProduct.MIN_TICK, tickSpacing / 2));</span>
 204 |     | <span class='neutral'>        }</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='unexecuted'>    function _msb(</span>
 208 |     | <span class='neutral'>        uint256 x</span>
 209 |     | <span class='neutral'>    ) internal pure returns (</span>
 210 |     | <span class='unexecuted'>        uint8 r</span>
 211 |     | <span class='neutral'>    ) {</span>
 212 |     | <span class='neutral'>        unchecked {</span>
 213 |     | <span class='unexecuted'>            assert(x &gt; 0);</span>
 214 |     | <span class='unexecuted'>            if (x &gt;= 0x100000000000000000000000000000000) {</span>
 215 |     | <span class='unexecuted'>                x &gt;&gt;= 128;</span>
 216 |     | <span class='unexecuted'>                r += 128;</span>
 217 |     | <span class='neutral'>            }</span>
 218 |     | <span class='unexecuted'>            if (x &gt;= 0x10000000000000000) {</span>
 219 |     | <span class='unexecuted'>                x &gt;&gt;= 64;</span>
 220 |     | <span class='unexecuted'>                r += 64;</span>
 221 |     | <span class='neutral'>            }</span>
 222 |     | <span class='unexecuted'>            if (x &gt;= 0x100000000) {</span>
 223 |     | <span class='unexecuted'>                x &gt;&gt;= 32;</span>
 224 |     | <span class='unexecuted'>                r += 32;</span>
 225 |     | <span class='neutral'>            }</span>
 226 |     | <span class='unexecuted'>            if (x &gt;= 0x10000) {</span>
 227 |     | <span class='unexecuted'>                x &gt;&gt;= 16;</span>
 228 |     | <span class='unexecuted'>                r += 16;</span>
 229 |     | <span class='neutral'>            }</span>
 230 |     | <span class='unexecuted'>            if (x &gt;= 0x100) {</span>
 231 |     | <span class='unexecuted'>                x &gt;&gt;= 8;</span>
 232 |     | <span class='unexecuted'>                r += 8;</span>
 233 |     | <span class='neutral'>            }</span>
 234 |     | <span class='unexecuted'>            if (x &gt;= 0x10) {</span>
 235 |     | <span class='unexecuted'>                x &gt;&gt;= 4;</span>
 236 |     | <span class='unexecuted'>                r += 4;</span>
 237 |     | <span class='neutral'>            }</span>
 238 |     | <span class='unexecuted'>            if (x &gt;= 0x4) {</span>
 239 |     | <span class='unexecuted'>                x &gt;&gt;= 2;</span>
 240 |     | <span class='unexecuted'>                r += 2;</span>
 241 |     | <span class='neutral'>            }</span>
 242 |     | <span class='unexecuted'>            if (x &gt;= 0x2) r += 1;</span>
 243 |     | <span class='neutral'>        }</span>
 244 |     | <span class='neutral'>    }</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='unexecuted'>    function _lsb(</span>
 247 |     | <span class='neutral'>        uint256 x</span>
 248 |     | <span class='neutral'>    ) internal pure returns (</span>
 249 |     | <span class='unexecuted'>        uint8 r</span>
 250 |     | <span class='neutral'>    ) {</span>
 251 |     | <span class='neutral'>        unchecked {</span>
 252 |     | <span class='unexecuted'>            assert(x &gt; 0); // if x is 0 return 0</span>
 253 |     | <span class='unexecuted'>            r = 255;</span>
 254 |     | <span class='unexecuted'>            if (x &amp; type(uint128).max &gt; 0) {</span>
 255 |     | <span class='unexecuted'>                r -= 128;</span>
 256 |     | <span class='neutral'>            } else {</span>
 257 |     | <span class='unexecuted'>                x &gt;&gt;= 128;</span>
 258 |     | <span class='neutral'>            }</span>
 259 |     | <span class='unexecuted'>            if (x &amp; type(uint64).max &gt; 0) {</span>
 260 |     | <span class='unexecuted'>                r -= 64;</span>
 261 |     | <span class='neutral'>            } else {</span>
 262 |     | <span class='unexecuted'>                x &gt;&gt;= 64;</span>
 263 |     | <span class='neutral'>            }</span>
 264 |     | <span class='unexecuted'>            if (x &amp; type(uint32).max &gt; 0) {</span>
 265 |     | <span class='unexecuted'>                r -= 32;</span>
 266 |     | <span class='neutral'>            } else {</span>
 267 |     | <span class='unexecuted'>                x &gt;&gt;= 32;</span>
 268 |     | <span class='neutral'>            }</span>
 269 |     | <span class='unexecuted'>            if (x &amp; type(uint16).max &gt; 0) {</span>
 270 |     | <span class='unexecuted'>                r -= 16;</span>
 271 |     | <span class='neutral'>            } else {</span>
 272 |     | <span class='unexecuted'>                x &gt;&gt;= 16;</span>
 273 |     | <span class='neutral'>            }</span>
 274 |     | <span class='unexecuted'>            if (x &amp; type(uint8).max &gt; 0) {</span>
 275 |     | <span class='unexecuted'>                r -= 8;</span>
 276 |     | <span class='neutral'>            } else {</span>
 277 |     | <span class='unexecuted'>                x &gt;&gt;= 8;</span>
 278 |     | <span class='neutral'>            }</span>
 279 |     | <span class='unexecuted'>            if (x &amp; 0xf &gt; 0) {</span>
 280 |     | <span class='unexecuted'>                r -= 4;</span>
 281 |     | <span class='neutral'>            } else {</span>
 282 |     | <span class='unexecuted'>                x &gt;&gt;= 4;</span>
 283 |     | <span class='neutral'>            }</span>
 284 |     | <span class='unexecuted'>            if (x &amp; 0x3 &gt; 0) {</span>
 285 |     | <span class='unexecuted'>                r -= 2;</span>
 286 |     | <span class='neutral'>            } else {</span>
 287 |     | <span class='unexecuted'>                x &gt;&gt;= 2;</span>
 288 |     | <span class='neutral'>            }</span>
 289 |     | <span class='unexecuted'>            if (x &amp; 0x1 &gt; 0) r -= 1;</span>
 290 |     | <span class='neutral'>        }</span>
 291 |     | <span class='neutral'>    }</span>
 292 |     | <span class='neutral'></span>
 293 |     | <span class='neutral'>    function round(</span>
 294 |     | <span class='neutral'>        int24 tick,</span>
 295 |     | <span class='neutral'>        int24 tickSpacing</span>
 296 |     | <span class='neutral'>    ) internal pure returns (</span>
 297 |     | <span class='neutral'>        int24 roundedTick</span>
 298 |     | <span class='neutral'>    ) {</span>
 299 |     | <span class='neutral'>        return tick / tickSpacing * tickSpacing;</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='unexecuted'>    function roundHalf(</span>
 303 |     | <span class='neutral'>        int24 tick,</span>
 304 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants,</span>
 305 |     | <span class='neutral'>        uint256 price</span>
 306 |     | <span class='neutral'>    ) internal pure returns (</span>
 307 |     | <span class='unexecuted'>        int24 roundedTick,</span>
 308 |     | <span class='neutral'>        uint160 roundedTickPrice</span>
 309 |     | <span class='neutral'>    ) {</span>
 310 |     | <span class='neutral'>        //pool.tickAtPrice -99.5</span>
 311 |     | <span class='neutral'>        //pool.tickAtPrice -100</span>
 312 |     | <span class='neutral'>        //-105</span>
 313 |     | <span class='neutral'>        //-95</span>
 314 |     | <span class='unexecuted'>        roundedTick = tick / constants.tickSpacing * constants.tickSpacing;</span>
 315 |     | <span class='unexecuted'>        roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);</span>
 316 |     | <span class='unexecuted'>        if (price == roundedTickPrice)</span>
 317 |     | <span class='unexecuted'>            return (roundedTick, roundedTickPrice);</span>
 318 |     | <span class='unexecuted'>        if (roundedTick &gt; 0) {</span>
 319 |     | <span class='unexecuted'>            roundedTick += constants.tickSpacing / 2;</span>
 320 |     | <span class='unexecuted'>        } else if (roundedTick &lt; 0) {</span>
 321 |     | <span class='unexecuted'>            if (roundedTickPrice &lt; price)</span>
 322 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing / 2;</span>
 323 |     | <span class='neutral'>            else</span>
 324 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing / 2;</span>
 325 |     | <span class='neutral'>        } else {</span>
 326 |     | <span class='unexecuted'>            if (price &gt; roundedTickPrice) {</span>
 327 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing / 2;</span>
 328 |     | <span class='unexecuted'>            } else if (price &lt; roundedTickPrice) {</span>
 329 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing / 2;</span>
 330 |     | <span class='neutral'>            }</span>
 331 |     | <span class='neutral'>        }</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>    function roundAhead(</span>
 335 |     | <span class='neutral'>        int24 tick,</span>
 336 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants,</span>
 337 |     | <span class='neutral'>        bool zeroForOne,</span>
 338 |     | <span class='neutral'>        uint256 price</span>
 339 |     | <span class='neutral'>    ) internal pure returns (</span>
 340 |     | <span class='unexecuted'>        int24 roundedTick</span>
 341 |     | <span class='unexecuted'>    ) {</span>
 342 |     | <span class='unexecuted'>        roundedTick = tick / constants.tickSpacing * constants.tickSpacing;</span>
 343 |     | <span class='unexecuted'>        uint160 roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);</span>
 344 |     | <span class='unexecuted'>        if (price == roundedTickPrice)</span>
 345 |     | <span class='unexecuted'>            return roundedTick;</span>
 346 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 347 |     | <span class='neutral'>            // round up if positive</span>
 348 |     | <span class='unexecuted'>            if (roundedTick &gt; 0 || (roundedTick == 0 &amp;&amp; tick &gt;= 0))</span>
 349 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing;</span>
 350 |     | <span class='unexecuted'>            else if (tick % constants.tickSpacing == 0) {</span>
 351 |     | <span class='neutral'>                // handle price at -99.5 and tickAtPrice == -100</span>
 352 |     | <span class='unexecuted'>                if (tick &lt; 0 &amp;&amp; roundedTickPrice &lt; price) {</span>
 353 |     | <span class='unexecuted'>                    roundedTick += constants.tickSpacing;</span>
 354 |     | <span class='neutral'>                }</span>
 355 |     | <span class='neutral'>            }</span>
 356 |     | <span class='neutral'>        } else {</span>
 357 |     | <span class='neutral'>            // round down if negative</span>
 358 |     | <span class='unexecuted'>            if (roundedTick &lt; 0 || (roundedTick == 0 &amp;&amp; tick &lt; 0))</span>
 359 |     | <span class='neutral'>            /// @dev - strictly less due to TickMath always rounding to lesser values</span>
 360 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing;</span>
 361 |     | <span class='neutral'>        }</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='unexecuted'>    function roundBack(</span>
 365 |     | <span class='neutral'>        int24 tick,</span>
 366 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants,</span>
 367 |     | <span class='neutral'>        bool zeroForOne,</span>
 368 |     | <span class='neutral'>        uint256 price</span>
 369 |     | <span class='neutral'>    ) internal pure returns (</span>
 370 |     | <span class='unexecuted'>        int24 roundedTick</span>
 371 |     | <span class='unexecuted'>    ) {</span>
 372 |     | <span class='unexecuted'>        roundedTick = tick / constants.tickSpacing * constants.tickSpacing;</span>
 373 |     | <span class='unexecuted'>        uint160 roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);</span>
 374 |     | <span class='unexecuted'>        if (price == roundedTickPrice)</span>
 375 |     | <span class='unexecuted'>            return roundedTick;</span>
 376 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 377 |     | <span class='neutral'>            // round down if negative</span>
 378 |     | <span class='unexecuted'>            if (roundedTick &lt; 0 || (roundedTick == 0 &amp;&amp; tick &lt; 0))</span>
 379 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing;</span>
 380 |     | <span class='neutral'>        } else {</span>
 381 |     | <span class='neutral'>            // round up if positive</span>
 382 |     | <span class='unexecuted'>            if (roundedTick &gt; 0 || (roundedTick == 0 &amp;&amp; tick &gt;= 0))</span>
 383 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing;</span>
 384 |     | <span class='unexecuted'>            else if (tick % constants.tickSpacing == 0) {</span>
 385 |     | <span class='neutral'>                // handle price at -99.5 and tickAtPrice == -100</span>
 386 |     | <span class='unexecuted'>                if (tick &lt; 0 &amp;&amp; roundedTickPrice &lt; price) {</span>
 387 |     | <span class='unexecuted'>                    roundedTick += constants.tickSpacing;</span>
 388 |     | <span class='neutral'>                }</span>
 389 |     | <span class='neutral'>            }</span>
 390 |     | <span class='neutral'>        }</span>
 391 |     | <span class='neutral'>    }</span>
 392 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/Ticks.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../interfaces/ILimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../interfaces/ILimitPoolFactory.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../base/structs/LimitPoolFactoryStructs.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/ILimitPool.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./math/ConstantProduct.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./Positions.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./math/OverflowMath.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./TickMap.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./utils/SafeCast.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;./EchidnaAssertions.sol&#39;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>/// @notice Tick management library</span>
  17 |     | <span class='unexecuted'>library Ticks {</span>
  18 |     | <span class='neutral'>    error LiquidityOverflow();</span>
  19 |     | <span class='neutral'>    error LiquidityUnderflow();</span>
  20 |     | <span class='neutral'>    error InvalidLowerTick();</span>
  21 |     | <span class='neutral'>    error InvalidUpperTick();</span>
  22 |     | <span class='neutral'>    error InvalidPositionAmount();</span>
  23 |     | <span class='neutral'>    error InvalidPositionBounds();</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    event Initialize(</span>
  28 |     | <span class='neutral'>        int24 minTick,</span>
  29 |     | <span class='neutral'>        int24 maxTick,</span>
  30 |     | <span class='neutral'>        uint160 startPrice</span>
  31 |     | <span class='neutral'>    );</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    event Swap(</span>
  34 |     | <span class='neutral'>        address indexed recipient,</span>
  35 |     | <span class='neutral'>        bool zeroForOne,</span>
  36 |     | <span class='neutral'>        uint256 amountIn,</span>
  37 |     | <span class='neutral'>        uint256 amountOut,</span>
  38 |     | <span class='neutral'>        uint160 price,</span>
  39 |     | <span class='neutral'>        uint128 liquidity,</span>
  40 |     | <span class='neutral'>        int24 tickAtPrice</span>
  41 |     | <span class='neutral'>    );</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    function initialize(</span>
  46 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
  47 |     | <span class='neutral'>        ILimitPoolStructs.PoolState storage pool0,</span>
  48 |     | <span class='neutral'>        ILimitPoolStructs.PoolState storage pool1,</span>
  49 |     | <span class='neutral'>        ILimitPoolStructs.GlobalState memory state,</span>
  50 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants,</span>
  51 |     | <span class='neutral'>        uint160 startPrice</span>
  52 |     | <span class='neutral'>    ) internal returns (</span>
  53 |     | <span class='neutral'>        ILimitPoolStructs.GlobalState memory</span>
  54 |     | <span class='neutral'>    ) {</span>
  55 |     | <span class='neutral'>        // state should only be initialized once</span>
  56 |     | <span class='unexecuted'>        if (pool0.price &gt; 0) require (false, &#39;PoolAlreadyInitialized()&#39;);</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>        // initialize epoch</span>
  59 |     | <span class='unexecuted'>        pool0.swapEpoch = 1;</span>
  60 |     | <span class='unexecuted'>        pool1.swapEpoch = 1;</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        // check price bounds</span>
  63 |     | <span class='unexecuted'>        if (startPrice &lt; constants.bounds.min || startPrice &gt;= constants.bounds.max) require(false, &#39;StartPriceInvalid()&#39;);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>        // initialize ticks</span>
  66 |     | <span class='unexecuted'>        TickMap.set(tickMap, ConstantProduct.minTick(constants.tickSpacing), constants.tickSpacing);</span>
  67 |     | <span class='unexecuted'>        TickMap.set(tickMap, ConstantProduct.maxTick(constants.tickSpacing), constants.tickSpacing);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        // initialize price</span>
  70 |     | <span class='unexecuted'>        pool0.price = startPrice;</span>
  71 |     | <span class='unexecuted'>        pool1.price = startPrice;</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        int24 startTick = ConstantProduct.getTickAtPrice(startPrice, constants);</span>
  74 |     | <span class='unexecuted'>        pool0.tickAtPrice = startTick;</span>
  75 |     | <span class='unexecuted'>        pool1.tickAtPrice = startTick;</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        // emit event</span>
  78 |     | <span class='unexecuted'>        emit Initialize(</span>
  79 |     | <span class='unexecuted'>            ConstantProduct.minTick(constants.tickSpacing),</span>
  80 |     | <span class='unexecuted'>            ConstantProduct.maxTick(constants.tickSpacing),</span>
  81 |     | <span class='unexecuted'>            pool0.price</span>
  82 |     | <span class='neutral'>        );</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        return state;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    function validate(</span>
  88 |     | <span class='neutral'>        int24 lower,</span>
  89 |     | <span class='neutral'>        int24 upper,</span>
  90 |     | <span class='neutral'>        int24 tickSpacing</span>
  91 |     | <span class='neutral'>    ) internal pure {</span>
  92 |     | <span class='neutral'>        if (lower % tickSpacing != 0) require(false, &#39;InvalidLowerTick()&#39;);</span>
  93 |     | <span class='neutral'>        if (lower &lt;= ConstantProduct.MIN_TICK) require(false, &#39;InvalidLowerTick()&#39;);</span>
  94 |     | <span class='neutral'>        if (upper % tickSpacing != 0) require(false, &#39;InvalidUpperTick()&#39;);</span>
  95 |     | <span class='neutral'>        if (upper &gt;= ConstantProduct.MAX_TICK) require(false, &#39;InvalidUpperTick()&#39;);</span>
  96 |     | <span class='neutral'>        if (lower &gt;= upper) require(false, &#39;InvalidPositionBounds()&#39;);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    function swap(</span>
 100 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 101 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 102 |     | <span class='neutral'>        ILimitPoolStructs.SwapParams memory params,</span>
 103 |     | <span class='neutral'>        ILimitPoolStructs.SwapCache memory cache,</span>
 104 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool</span>
 105 |     | <span class='neutral'>    ) internal returns (</span>
 106 |     | <span class='unexecuted'>            ILimitPoolStructs.PoolState memory,</span>
 107 |     | <span class='unexecuted'>            ILimitPoolStructs.SwapCache memory</span>
 108 |     | <span class='neutral'>        )</span>
 109 |     | <span class='neutral'>    {</span>
 110 |     | <span class='unexecuted'>        (cache.crossTick,) = TickMap.roundHalf(pool.tickAtPrice, cache.constants, pool.price);</span>
 111 |     | <span class='unexecuted'>        cache = ILimitPoolStructs.SwapCache({</span>
 112 |     | <span class='unexecuted'>            state: cache.state,</span>
 113 |     | <span class='unexecuted'>            constants: cache.constants,</span>
 114 |     | <span class='unexecuted'>            pool: cache.pool,</span>
 115 |     | <span class='unexecuted'>            price: pool.price,</span>
 116 |     | <span class='unexecuted'>            liquidity: pool.liquidity,</span>
 117 |     | <span class='unexecuted'>            cross: true,</span>
 118 |     | <span class='unexecuted'>            crossTick: params.zeroForOne ? TickMap.previous(tickMap, cache.crossTick, cache.constants.tickSpacing, true) </span>
 119 |     | <span class='unexecuted'>                                         : TickMap.next(tickMap, cache.crossTick, cache.constants.tickSpacing, true),</span>
 120 |     | <span class='unexecuted'>            crossPrice: 0,</span>
 121 |     | <span class='unexecuted'>            input:  0,</span>
 122 |     | <span class='unexecuted'>            output: 0,</span>
 123 |     | <span class='unexecuted'>            exactIn: params.exactIn,</span>
 124 |     | <span class='unexecuted'>            amountLeft: params.amount</span>
 125 |     | <span class='neutral'>        });</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>        // increment swap epoch</span>
 128 |     | <span class='unexecuted'>        cache.pool.swapEpoch += 1;</span>
 129 |     | <span class='neutral'>        // grab latest sample and store in cache for _cross</span>
 130 |     | <span class='unexecuted'>        while (cache.cross) {</span>
 131 |     | <span class='unexecuted'>            cache.crossPrice = ticks[cache.crossTick].priceAt == 0 ? </span>
 132 |     | <span class='unexecuted'>                                    ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)</span>
 133 |     | <span class='unexecuted'>                                  : ticks[cache.crossTick].priceAt;</span>
 134 |     | <span class='neutral'>            // handle price being at cross tick</span>
 135 |     | <span class='unexecuted'>            if (params.zeroForOne &amp;&amp; pool.price == cache.crossPrice) {</span>
 136 |     | <span class='unexecuted'>                cache.crossTick = TickMap.previous(tickMap, pool.tickAtPrice, cache.constants.tickSpacing, false);</span>
 137 |     | <span class='unexecuted'>                cache.crossPrice = ticks[cache.crossTick].priceAt == 0 ? </span>
 138 |     | <span class='unexecuted'>                                    ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)</span>
 139 |     | <span class='unexecuted'>                                  : ticks[cache.crossTick].priceAt;</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>            }</span>
 142 |     | <span class='unexecuted'>            (pool, cache) = _quoteSingle(pool, cache, params.priceLimit, params.zeroForOne);</span>
 143 |     | <span class='unexecuted'>            if (cache.cross) {</span>
 144 |     | <span class='unexecuted'>                (pool, cache) = _cross(</span>
 145 |     | <span class='unexecuted'>                    ticks,</span>
 146 |     | <span class='unexecuted'>                    tickMap,</span>
 147 |     | <span class='unexecuted'>                    pool,</span>
 148 |     | <span class='unexecuted'>                    cache,</span>
 149 |     | <span class='unexecuted'>                    params.zeroForOne</span>
 150 |     | <span class='neutral'>                );</span>
 151 |     | <span class='neutral'>            }</span>
 152 |     | <span class='neutral'>        }</span>
 153 |     | <span class='unexecuted'>        pool.price = cache.price.toUint160();</span>
 154 |     | <span class='unexecuted'>        pool.liquidity = cache.liquidity.toUint128();</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>        if (cache.price != cache.crossPrice) {</span>
 157 |     | <span class='unexecuted'>            pool.tickAtPrice = ConstantProduct.getTickAtPrice(pool.price, cache.constants);</span>
 158 |     | <span class='neutral'>        } else {</span>
 159 |     | <span class='unexecuted'>            pool.tickAtPrice = cache.crossTick;</span>
 160 |     | <span class='neutral'>        }</span>
 161 |     | <span class='unexecuted'>        emit Swap(</span>
 162 |     | <span class='unexecuted'>            params.to,</span>
 163 |     | <span class='unexecuted'>            params.zeroForOne,</span>
 164 |     | <span class='unexecuted'>            cache.input,</span>
 165 |     | <span class='unexecuted'>            cache.output, /// @dev - subgraph will do math to compute fee amount</span>
 166 |     | <span class='unexecuted'>            pool.price,</span>
 167 |     | <span class='unexecuted'>            pool.liquidity,</span>
 168 |     | <span class='unexecuted'>            pool.tickAtPrice</span>
 169 |     | <span class='neutral'>        );</span>
 170 |     | <span class='unexecuted'>        return (pool, cache);</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>    function quote(</span>
 174 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 175 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 176 |     | <span class='neutral'>        ILimitPoolStructs.QuoteParams memory params,</span>
 177 |     | <span class='neutral'>        ILimitPoolStructs.SwapCache memory cache,</span>
 178 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool</span>
 179 |     | <span class='neutral'>    ) internal view returns (</span>
 180 |     | <span class='unexecuted'>        uint256,</span>
 181 |     | <span class='unexecuted'>        uint256,</span>
 182 |     | <span class='unexecuted'>        uint160</span>
 183 |     | <span class='neutral'>    ) {</span>
 184 |     | <span class='unexecuted'>        (cache.crossTick,) = TickMap.roundHalf(pool.tickAtPrice, cache.constants, pool.price);</span>
 185 |     | <span class='unexecuted'>        cache = ILimitPoolStructs.SwapCache({</span>
 186 |     | <span class='unexecuted'>            state: cache.state,</span>
 187 |     | <span class='unexecuted'>            constants: cache.constants,</span>
 188 |     | <span class='unexecuted'>            pool: cache.pool,</span>
 189 |     | <span class='unexecuted'>            price: pool.price,</span>
 190 |     | <span class='unexecuted'>            liquidity: pool.liquidity,</span>
 191 |     | <span class='unexecuted'>            cross: true,</span>
 192 |     | <span class='unexecuted'>            crossTick: params.zeroForOne ? TickMap.previous(tickMap, cache.crossTick, cache.constants.tickSpacing, true) </span>
 193 |     | <span class='unexecuted'>                                         : TickMap.next(tickMap, cache.crossTick, cache.constants.tickSpacing, true),</span>
 194 |     | <span class='unexecuted'>            crossPrice: 0,</span>
 195 |     | <span class='unexecuted'>            input:  0,</span>
 196 |     | <span class='unexecuted'>            output: 0,</span>
 197 |     | <span class='unexecuted'>            exactIn: params.exactIn,</span>
 198 |     | <span class='unexecuted'>            amountLeft: params.amount</span>
 199 |     | <span class='neutral'>        });</span>
 200 |     | <span class='unexecuted'>        while (cache.cross) {</span>
 201 |     | <span class='unexecuted'>            cache.crossPrice = ticks[cache.crossTick].priceAt == 0 ? </span>
 202 |     | <span class='unexecuted'>                                 ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)</span>
 203 |     | <span class='unexecuted'>                               : ticks[cache.crossTick].priceAt;</span>
 204 |     | <span class='neutral'>            // handle price being at cross tick</span>
 205 |     | <span class='unexecuted'>            if (params.zeroForOne &amp;&amp; pool.price == cache.crossPrice) {</span>
 206 |     | <span class='unexecuted'>                cache.crossTick = TickMap.previous(tickMap, pool.tickAtPrice, cache.constants.tickSpacing, false);</span>
 207 |     | <span class='unexecuted'>                cache.crossPrice = ticks[cache.crossTick].priceAt == 0 ? </span>
 208 |     | <span class='unexecuted'>                                    ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)</span>
 209 |     | <span class='unexecuted'>                                  : ticks[cache.crossTick].priceAt;</span>
 210 |     | <span class='neutral'>            }</span>
 211 |     | <span class='unexecuted'>            (pool, cache) = _quoteSingle(pool, cache, params.priceLimit, params.zeroForOne);</span>
 212 |     | <span class='unexecuted'>            if (cache.cross) {</span>
 213 |     | <span class='unexecuted'>                (pool, cache) = _pass(</span>
 214 |     | <span class='unexecuted'>                    ticks,</span>
 215 |     | <span class='unexecuted'>                    tickMap,</span>
 216 |     | <span class='unexecuted'>                    pool,</span>
 217 |     | <span class='unexecuted'>                    cache,</span>
 218 |     | <span class='unexecuted'>                    params.zeroForOne</span>
 219 |     | <span class='neutral'>                );</span>
 220 |     | <span class='neutral'>            }</span>
 221 |     | <span class='neutral'>        }</span>
 222 |     | <span class='neutral'>        return (</span>
 223 |     | <span class='unexecuted'>            cache.input,</span>
 224 |     | <span class='unexecuted'>            cache.output,</span>
 225 |     | <span class='unexecuted'>            uint160(cache.price)</span>
 226 |     | <span class='neutral'>        );</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>    function _quoteSingle(</span>
 230 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool,</span>
 231 |     | <span class='neutral'>        ILimitPoolStructs.SwapCache memory cache,</span>
 232 |     | <span class='neutral'>        uint160 priceLimit,</span>
 233 |     | <span class='neutral'>        bool zeroForOne</span>
 234 |     | <span class='neutral'>    ) internal pure returns (</span>
 235 |     | <span class='unexecuted'>        ILimitPoolStructs.PoolState memory,</span>
 236 |     | <span class='unexecuted'>        ILimitPoolStructs.SwapCache memory</span>
 237 |     | <span class='neutral'>    ) {</span>
 238 |     | <span class='unexecuted'>        if ((zeroForOne ? priceLimit &gt;= cache.price</span>
 239 |     | <span class='unexecuted'>                        : priceLimit &lt;= cache.price) ||</span>
 240 |     | <span class='unexecuted'>            (zeroForOne &amp;&amp; cache.price == cache.constants.bounds.min) ||</span>
 241 |     | <span class='unexecuted'>            (!zeroForOne &amp;&amp; cache.price == cache.constants.bounds.max) ||</span>
 242 |     | <span class='unexecuted'>            cache.amountLeft == 0)</span>
 243 |     | <span class='neutral'>        {</span>
 244 |     | <span class='unexecuted'>            cache.cross = false;</span>
 245 |     | <span class='unexecuted'>            return (pool, cache);</span>
 246 |     | <span class='neutral'>        }</span>
 247 |     | <span class='unexecuted'>        uint256 nextPrice = cache.crossPrice;</span>
 248 |     | <span class='neutral'>        uint256 amountOut;</span>
 249 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 250 |     | <span class='neutral'>            // Trading token 0 (x) for token 1 (y).</span>
 251 |     | <span class='neutral'>            // price  is decreasing.</span>
 252 |     | <span class='unexecuted'>            if (nextPrice &lt; priceLimit) {</span>
 253 |     | <span class='unexecuted'>                nextPrice = priceLimit;</span>
 254 |     | <span class='neutral'>            }</span>
 255 |     | <span class='unexecuted'>            uint256 amountMax = cache.exactIn ? ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true)</span>
 256 |     | <span class='unexecuted'>                                              : ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);</span>
 257 |     | <span class='unexecuted'>            if (cache.amountLeft &lt; amountMax) {</span>
 258 |     | <span class='neutral'>                // We can swap within the current range.</span>
 259 |     | <span class='unexecuted'>                uint256 liquidityPadded = uint256(cache.liquidity) &lt;&lt; 96;</span>
 260 |     | <span class='neutral'>                // calculate price after swap</span>
 261 |     | <span class='unexecuted'>                uint256 newPrice;</span>
 262 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 263 |     | <span class='unexecuted'>                    newPrice = OverflowMath.mulDivRoundingUp(</span>
 264 |     | <span class='unexecuted'>                        liquidityPadded,</span>
 265 |     | <span class='unexecuted'>                        cache.price,</span>
 266 |     | <span class='unexecuted'>                        liquidityPadded + uint256(cache.price) * uint256(cache.amountLeft)</span>
 267 |     | <span class='neutral'>                    );</span>
 268 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDy(cache.liquidity, newPrice, uint256(cache.price), false);</span>
 269 |     | <span class='unexecuted'>                    cache.input += cache.amountLeft;</span>
 270 |     | <span class='neutral'>                } else {</span>
 271 |     | <span class='unexecuted'>                    newPrice = cache.price - </span>
 272 |     | <span class='unexecuted'>                        OverflowMath.divRoundingUp(cache.amountLeft &lt;&lt; 96, cache.liquidity);</span>
 273 |     | <span class='unexecuted'>                    amountOut = cache.amountLeft;</span>
 274 |     | <span class='unexecuted'>                    cache.input += ConstantProduct.getDx(cache.liquidity, newPrice, uint256(cache.price), true);</span>
 275 |     | <span class='neutral'>                }</span>
 276 |     | <span class='unexecuted'>                cache.amountLeft = 0;</span>
 277 |     | <span class='unexecuted'>                cache.cross = false;</span>
 278 |     | <span class='unexecuted'>                cache.price = uint160(newPrice);</span>
 279 |     | <span class='neutral'>            } else {</span>
 280 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 281 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);</span>
 282 |     | <span class='unexecuted'>                    cache.input += amountMax;</span>
 283 |     | <span class='neutral'>                } else {</span>
 284 |     | <span class='unexecuted'>                    amountOut = amountMax;</span>
 285 |     | <span class='unexecuted'>                    cache.input += ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true);</span>
 286 |     | <span class='neutral'>                }</span>
 287 |     | <span class='unexecuted'>                cache.amountLeft -= amountMax;</span>
 288 |     | <span class='unexecuted'>                if (nextPrice == cache.crossPrice) { cache.cross = true; }</span>
 289 |     | <span class='unexecuted'>                else cache.cross = false;</span>
 290 |     | <span class='unexecuted'>                cache.price = uint160(nextPrice);</span>
 291 |     | <span class='neutral'>            }</span>
 292 |     | <span class='unexecuted'>        } else {</span>
 293 |     | <span class='neutral'>            // Price is increasing.</span>
 294 |     | <span class='unexecuted'>            if (nextPrice &gt; priceLimit) {</span>
 295 |     | <span class='unexecuted'>                nextPrice = priceLimit;</span>
 296 |     | <span class='neutral'>            }</span>
 297 |     | <span class='unexecuted'>            uint256 amountMax = cache.exactIn ? ConstantProduct.getDy(cache.liquidity, uint256(cache.price), nextPrice, true)</span>
 298 |     | <span class='unexecuted'>                                              : ConstantProduct.getDx(cache.liquidity, uint256(cache.price), nextPrice, false);</span>
 299 |     | <span class='unexecuted'>            if (cache.amountLeft &lt; amountMax) {</span>
 300 |     | <span class='unexecuted'>                uint256 newPrice;</span>
 301 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 302 |     | <span class='unexecuted'>                    newPrice = cache.price +</span>
 303 |     | <span class='unexecuted'>                        OverflowMath.mulDiv(cache.amountLeft, Q96, cache.liquidity);</span>
 304 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDx(cache.liquidity, cache.price, newPrice, false);</span>
 305 |     | <span class='unexecuted'>                    cache.input += cache.amountLeft;</span>
 306 |     | <span class='neutral'>                } else {</span>
 307 |     | <span class='unexecuted'>                    uint256 liquidityPadded = uint256(cache.liquidity) &lt;&lt; 96;</span>
 308 |     | <span class='unexecuted'>                    newPrice = OverflowMath.mulDivRoundingUp(</span>
 309 |     | <span class='neutral'>                        liquidityPadded, </span>
 310 |     | <span class='unexecuted'>                        cache.price,</span>
 311 |     | <span class='unexecuted'>                        liquidityPadded - uint256(cache.price) * cache.amountLeft</span>
 312 |     | <span class='neutral'>                    );</span>
 313 |     | <span class='unexecuted'>                    amountOut = cache.amountLeft;</span>
 314 |     | <span class='unexecuted'>                    cache.input += ConstantProduct.getDy(cache.liquidity, cache.price, newPrice, true);</span>
 315 |     | <span class='neutral'>                }</span>
 316 |     | <span class='unexecuted'>                cache.amountLeft = 0;</span>
 317 |     | <span class='unexecuted'>                cache.cross = false;</span>
 318 |     | <span class='unexecuted'>                cache.price = uint160(newPrice);</span>
 319 |     | <span class='neutral'>            } else {</span>
 320 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 321 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDx(cache.liquidity, cache.price, nextPrice, false);</span>
 322 |     | <span class='unexecuted'>                    cache.input += amountMax;</span>
 323 |     | <span class='neutral'>                } else {</span>
 324 |     | <span class='unexecuted'>                    amountOut = amountMax;</span>
 325 |     | <span class='unexecuted'>                    cache.input += ConstantProduct.getDy(cache.liquidity, cache.price, nextPrice, true);</span>
 326 |     | <span class='neutral'>                }</span>
 327 |     | <span class='unexecuted'>                cache.amountLeft -= amountMax;</span>
 328 |     | <span class='unexecuted'>                if (nextPrice == cache.crossPrice) { cache.cross = true; }</span>
 329 |     | <span class='unexecuted'>                else cache.cross = false;</span>
 330 |     | <span class='unexecuted'>                cache.price = uint160(nextPrice);</span>
 331 |     | <span class='neutral'>            }</span>
 332 |     | <span class='neutral'>        }</span>
 333 |     | <span class='unexecuted'>        cache.output += amountOut;</span>
 334 |     | <span class='unexecuted'>        return (pool, cache);</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='unexecuted'>    function unlock(</span>
 338 |     | <span class='neutral'>        ILimitPoolStructs.MintCache memory cache,</span>
 339 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool,</span>
 340 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 341 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 342 |     | <span class='neutral'>        bool zeroForOne</span>
 343 |     | <span class='neutral'>    ) internal returns (</span>
 344 |     | <span class='unexecuted'>        ILimitPoolStructs.MintCache memory,</span>
 345 |     | <span class='unexecuted'>        ILimitPoolStructs.PoolState memory</span>
 346 |     | <span class='neutral'>    )</span>
 347 |     | <span class='neutral'>    {</span>
 348 |     | <span class='unexecuted'>        if (pool.liquidity &gt; 0) return (cache, pool);</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='unexecuted'>        (int24 startTick,) = TickMap.roundHalf(pool.tickAtPrice, cache.constants, pool.price);</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 353 |     | <span class='unexecuted'>            pool.tickAtPrice = TickMap.next(tickMap, startTick, cache.constants.tickSpacing, true);</span>
 354 |     | <span class='unexecuted'>            if (pool.tickAtPrice &lt; ConstantProduct.maxTick(cache.constants.tickSpacing)) {</span>
 355 |     | <span class='unexecuted'>                EpochMap.set(pool.tickAtPrice, pool.swapEpoch, tickMap, cache.constants);</span>
 356 |     | <span class='neutral'>            }</span>
 357 |     | <span class='neutral'>        } else {</span>
 358 |     | <span class='neutral'>            /// @dev - roundedUp true since liquidity could be equal to the current pool tickAtPrice</span>
 359 |     | <span class='unexecuted'>            pool.tickAtPrice = TickMap.previous(tickMap, startTick, cache.constants.tickSpacing, true);</span>
 360 |     | <span class='unexecuted'>            if (pool.tickAtPrice &gt; ConstantProduct.minTick(cache.constants.tickSpacing)) {</span>
 361 |     | <span class='unexecuted'>                EpochMap.set(pool.tickAtPrice, pool.swapEpoch, tickMap, cache.constants);</span>
 362 |     | <span class='neutral'>            }</span>
 363 |     | <span class='neutral'>        }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>        // increment pool liquidity</span>
 366 |     | <span class='unexecuted'>        EchidnaAssertions.assertPositiveLiquidityOnUnlock(ticks[pool.tickAtPrice].liquidityDelta);</span>
 367 |     | <span class='unexecuted'>        EchidnaAssertions.assertLiquidityDeltaZeroOnUnlock(ticks[pool.tickAtPrice].liquidityDelta);</span>
 368 |     | <span class='unexecuted'>        EchidnaAssertions.assertLiquidityDeltaZeroOnUnlock(1);</span>
 369 |     | <span class='unexecuted'>        pool.liquidity += uint128(ticks[pool.tickAtPrice].liquidityDelta);</span>
 370 |     | <span class='unexecuted'>        int24 tickToClear = pool.tickAtPrice;</span>
 371 |     | <span class='unexecuted'>        uint160 tickPriceAt = ticks[pool.tickAtPrice].priceAt;</span>
 372 |     | <span class='neutral'></span>
 373 |     | <span class='unexecuted'>        if (tickPriceAt == 0) {</span>
 374 |     | <span class='neutral'>            // if full tick crossed</span>
 375 |     | <span class='unexecuted'>            pool.price = ConstantProduct.getPriceAtTick(pool.tickAtPrice, cache.constants);</span>
 376 |     | <span class='neutral'>        } else {</span>
 377 |     | <span class='neutral'>            // if half tick crossed</span>
 378 |     | <span class='unexecuted'>            pool.price = tickPriceAt;</span>
 379 |     | <span class='unexecuted'>            pool.tickAtPrice = ConstantProduct.getTickAtPrice(tickPriceAt, cache.constants);</span>
 380 |     | <span class='neutral'>        }</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>        // zero out tick</span>
 383 |     | <span class='unexecuted'>        ticks[tickToClear].liquidityDelta = 0;</span>
 384 |     | <span class='unexecuted'>        Ticks.clear(ticks, cache.constants, tickMap, tickToClear);</span>
 385 |     | <span class='neutral'></span>
 386 |     | <span class='unexecuted'>        return (cache, pool);</span>
 387 |     | <span class='neutral'>    }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='unexecuted'>    function _cross(</span>
 390 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 391 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 392 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool,</span>
 393 |     | <span class='neutral'>        ILimitPoolStructs.SwapCache memory cache,</span>
 394 |     | <span class='neutral'>        bool zeroForOne</span>
 395 |     | <span class='neutral'>    ) internal returns (</span>
 396 |     | <span class='unexecuted'>        ILimitPoolStructs.PoolState memory,</span>
 397 |     | <span class='unexecuted'>        ILimitPoolStructs.SwapCache memory</span>
 398 |     | <span class='neutral'>    ) {</span>
 399 |     | <span class='unexecuted'>        EpochMap.set(cache.crossTick, cache.pool.swapEpoch, tickMap, cache.constants);</span>
 400 |     | <span class='unexecuted'>        int128 liquidityDelta = ticks[cache.crossTick].liquidityDelta;</span>
 401 |     | <span class='neutral'></span>
 402 |     | <span class='unexecuted'>        if (liquidityDelta &gt; 0) cache.liquidity += uint128(liquidityDelta);</span>
 403 |     | <span class='neutral'>        else {</span>
 404 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityUnderflows(uint128(cache.liquidity), uint128(-liquidityDelta), &quot;TK-1&quot;);</span>
 405 |     | <span class='unexecuted'>            cache.liquidity -= uint128(-liquidityDelta);</span>
 406 |     | <span class='neutral'>        }</span>
 407 |     | <span class='unexecuted'>        pool.tickAtPrice = cache.crossTick;</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'>        // zero out liquidityDelta and priceAt</span>
 410 |     | <span class='unexecuted'>        ticks[cache.crossTick] = ILimitPoolStructs.Tick(0,0);</span>
 411 |     | <span class='unexecuted'>        clear(ticks, cache.constants, tickMap, cache.crossTick);</span>
 412 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 413 |     | <span class='unexecuted'>            cache.crossTick = TickMap.previous(tickMap, cache.crossTick, cache.constants.tickSpacing, false);</span>
 414 |     | <span class='neutral'>        } else {</span>
 415 |     | <span class='unexecuted'>            cache.crossTick = TickMap.next(tickMap, cache.crossTick, cache.constants.tickSpacing, false);</span>
 416 |     | <span class='neutral'>        }</span>
 417 |     | <span class='unexecuted'>        return (pool, cache);</span>
 418 |     | <span class='neutral'>    }</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='unexecuted'>    function _pass(</span>
 421 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 422 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 423 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool,</span>
 424 |     | <span class='neutral'>        ILimitPoolStructs.SwapCache memory cache,</span>
 425 |     | <span class='neutral'>        bool zeroForOne</span>
 426 |     | <span class='neutral'>    ) internal view returns (</span>
 427 |     | <span class='unexecuted'>        ILimitPoolStructs.PoolState memory,</span>
 428 |     | <span class='unexecuted'>        ILimitPoolStructs.SwapCache memory</span>
 429 |     | <span class='neutral'>    ) {</span>
 430 |     | <span class='unexecuted'>        int128 liquidityDelta = ticks[cache.crossTick].liquidityDelta;</span>
 431 |     | <span class='unexecuted'>        if (liquidityDelta &gt; 0) cache.liquidity += uint128(liquidityDelta);</span>
 432 |     | <span class='unexecuted'>        else cache.liquidity -= uint128(-liquidityDelta);</span>
 433 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 434 |     | <span class='unexecuted'>            cache.crossTick = TickMap.previous(tickMap, cache.crossTick, cache.constants.tickSpacing, false);</span>
 435 |     | <span class='neutral'>        } else {</span>
 436 |     | <span class='unexecuted'>            cache.crossTick = TickMap.next(tickMap, cache.crossTick, cache.constants.tickSpacing, false);</span>
 437 |     | <span class='neutral'>        }</span>
 438 |     | <span class='unexecuted'>        return (pool, cache);</span>
 439 |     | <span class='neutral'>    }</span>
 440 |     | <span class='neutral'>    </span>
 441 |     | <span class='unexecuted'>    function insert(</span>
 442 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 443 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 444 |     | <span class='neutral'>        ILimitPoolStructs.MintCache memory cache,</span>
 445 |     | <span class='neutral'>        ILimitPoolStructs.MintParams memory params</span>
 446 |     | <span class='neutral'>    ) internal {</span>
 447 |     | <span class='neutral'>        /// @auditor - validation of ticks is in Positions.validate</span>
 448 |     | <span class='unexecuted'>        if (cache.liquidityMinted &gt; (uint128(type(int128).max) - cache.pool.liquidityGlobal) )</span>
 449 |     | <span class='unexecuted'>            require (false, &#39;LiquidityOverflow()&#39;);</span>
 450 |     | <span class='neutral'></span>
 451 |     | <span class='unexecuted'>        int256 liquidityMinted = int256(cache.liquidityMinted);</span>
 452 |     | <span class='neutral'></span>
 453 |     | <span class='neutral'>        // check if adding liquidity necessary</span>
 454 |     | <span class='unexecuted'>        if (!params.zeroForOne || cache.priceLower &gt; cache.pool.price) {</span>
 455 |     | <span class='neutral'>            // sets bit in map</span>
 456 |     | <span class='unexecuted'>            TickMap.set(tickMap, params.lower, cache.constants.tickSpacing);</span>
 457 |     | <span class='unexecuted'>            ILimitPoolStructs.Tick memory tickLower = ticks[params.lower];</span>
 458 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 459 |     | <span class='unexecuted'>                tickLower.liquidityDelta += int128(liquidityMinted);</span>
 460 |     | <span class='neutral'>            } else {</span>
 461 |     | <span class='unexecuted'>                tickLower.liquidityDelta -= int128(liquidityMinted);</span>
 462 |     | <span class='neutral'>            }</span>
 463 |     | <span class='unexecuted'>            ticks[params.lower] = tickLower;</span>
 464 |     | <span class='neutral'>        }</span>
 465 |     | <span class='neutral'></span>
 466 |     | <span class='unexecuted'>        if (params.zeroForOne || cache.priceUpper &lt; cache.pool.price) {</span>
 467 |     | <span class='unexecuted'>            TickMap.set(tickMap, params.upper, cache.constants.tickSpacing);</span>
 468 |     | <span class='unexecuted'>            ILimitPoolStructs.Tick memory tickUpper = ticks[params.upper];</span>
 469 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 470 |     | <span class='unexecuted'>                tickUpper.liquidityDelta -= int128(liquidityMinted);</span>
 471 |     | <span class='neutral'>            } else {</span>
 472 |     | <span class='unexecuted'>                tickUpper.liquidityDelta += int128(liquidityMinted);</span>
 473 |     | <span class='neutral'>            }</span>
 474 |     | <span class='unexecuted'>            ticks[params.upper] = tickUpper;</span>
 475 |     | <span class='neutral'>        }</span>
 476 |     | <span class='neutral'>    }</span>
 477 |     | <span class='neutral'></span>
 478 |     | <span class='unexecuted'>    function insertSingle(</span>
 479 |     | <span class='neutral'>        ILimitPoolStructs.MintParams memory params,</span>
 480 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 481 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 482 |     | <span class='neutral'>        ILimitPoolStructs.MintCache memory cache,</span>
 483 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool,</span>
 484 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
 485 |     | <span class='neutral'>    ) internal returns (</span>
 486 |     | <span class='unexecuted'>        ILimitPoolStructs.PoolState memory</span>
 487 |     | <span class='neutral'>    ){</span>
 488 |     | <span class='neutral'>        /// @auditor - would be smart to protect against the case of epochs crossing</span>
 489 |     | <span class='unexecuted'>        (</span>
 490 |     | <span class='unexecuted'>            int24 tickToSave,</span>
 491 |     | <span class='unexecuted'>            uint160 roundedPrice</span>
 492 |     | <span class='unexecuted'>        ) = TickMap.roundHalf(pool.tickAtPrice, constants, pool.price);</span>
 493 |     | <span class='neutral'></span>
 494 |     | <span class='neutral'>        // update tick to save</span>
 495 |     | <span class='unexecuted'>        ILimitPoolStructs.Tick memory tick = ticks[tickToSave];</span>
 496 |     | <span class='neutral'>        /// @auditor - tick.priceAt will be zero for tick % tickSpacing == 0</span>
 497 |     | <span class='unexecuted'>        if (tick.priceAt == 0) {</span>
 498 |     | <span class='unexecuted'>            if (pool.price != (params.zeroForOne ? cache.priceLower : cache.priceUpper)) {</span>
 499 |     | <span class='unexecuted'>                TickMap.set(tickMap, tickToSave, constants.tickSpacing);</span>
 500 |     | <span class='neutral'>            }</span>
 501 |     | <span class='unexecuted'>            EpochMap.set(tickToSave, pool.swapEpoch, tickMap, constants);</span>
 502 |     | <span class='neutral'>        }</span>
 503 |     | <span class='neutral'>        // skip if we are at the nearest full tick</span>
 504 |     | <span class='unexecuted'>        if(pool.price != roundedPrice) {</span>
 505 |     | <span class='neutral'>            // if empty just save the pool price</span>
 506 |     | <span class='unexecuted'>            if (tick.priceAt == 0) {</span>
 507 |     | <span class='unexecuted'>                tick.priceAt = pool.price;</span>
 508 |     | <span class='neutral'>            }</span>
 509 |     | <span class='unexecuted'>            else {</span>
 510 |     | <span class='neutral'>                // we need to blend the two partial fills into a single tick</span>
 511 |     | <span class='unexecuted'>                ILimitPoolStructs.InsertSingleLocals memory locals;</span>
 512 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 513 |     | <span class='neutral'>                    // 0 -&gt; 1 positions price moves up so nextFullTick is greater</span>
 514 |     | <span class='unexecuted'>                    locals.previousFullTick = tickToSave - constants.tickSpacing / 2;</span>
 515 |     | <span class='unexecuted'>                    locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);</span>
 516 |     | <span class='neutral'>                    // calculate amountOut filled across both partial fills</span>
 517 |     | <span class='unexecuted'>                    locals.amountOutExact = ConstantProduct.getDy(pool.liquidity, locals.pricePrevious, pool.price, false);</span>
 518 |     | <span class='unexecuted'>                    locals.amountOutExact += ConstantProduct.getDy(uint128(tick.liquidityDelta), locals.pricePrevious, tick.priceAt, false);</span>
 519 |     | <span class='unexecuted'>                    uint128 combinedLiquidity = pool.liquidity + uint128(tick.liquidityDelta);</span>
 520 |     | <span class='neutral'>                    /// @auditor - the opposing amount calculated is off by 1/100 millionth</span>
 521 |     | <span class='neutral'>                    ///            (i.e. since we&#39;re using exactOut we lose precision on exactInput amount)</span>
 522 |     | <span class='neutral'>                    ///            the expected dy to the next tick is either exact or slightly more</span>
 523 |     | <span class='neutral'>                    ///            the expected dx to the next tick is 1/100 millionth less after the blend</span>
 524 |     | <span class='neutral'>                    // advance price past closest full tick using amountOut filled</span>
 525 |     | <span class='unexecuted'>                    tick.priceAt = ConstantProduct.getNewPrice(uint256(locals.pricePrevious), combinedLiquidity, locals.amountOutExact, false, true).toUint160();</span>
 526 |     | <span class='neutral'>                    // dx to the next tick is less than before the tick blend</span>
 527 |     | <span class='unexecuted'>                    EpochMap.set(tickToSave, pool.swapEpoch, tickMap, constants);</span>
 528 |     | <span class='unexecuted'>                } else {</span>
 529 |     | <span class='neutral'>                    // 0 -&gt; 1 positions price moves up so nextFullTick is lesser</span>
 530 |     | <span class='unexecuted'>                    locals.previousFullTick = tickToSave + constants.tickSpacing / 2;</span>
 531 |     | <span class='unexecuted'>                    locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);</span>
 532 |     | <span class='neutral'>                    // calculate amountOut filled across both partial fills</span>
 533 |     | <span class='unexecuted'>                    locals.amountOutExact = ConstantProduct.getDx(pool.liquidity, pool.price, locals.pricePrevious, false);</span>
 534 |     | <span class='unexecuted'>                    locals.amountOutExact += ConstantProduct.getDx(uint128(tick.liquidityDelta), tick.priceAt, locals.pricePrevious, false);</span>
 535 |     | <span class='neutral'>                    // add current pool liquidity to partial tick</span>
 536 |     | <span class='unexecuted'>                    uint128 combinedLiquidity = pool.liquidity + uint128(tick.liquidityDelta);</span>
 537 |     | <span class='neutral'>                    // advance price past closest full tick using amountOut filled</span>
 538 |     | <span class='unexecuted'>                    tick.priceAt = ConstantProduct.getNewPrice(uint256(locals.pricePrevious), combinedLiquidity, locals.amountOutExact, true, true).toUint160();</span>
 539 |     | <span class='neutral'>                    // mark epoch for second partial fill positions</span>
 540 |     | <span class='unexecuted'>                    EpochMap.set(tickToSave, pool.swapEpoch, tickMap, constants);</span>
 541 |     | <span class='neutral'>                }</span>
 542 |     | <span class='neutral'>            }</span>
 543 |     | <span class='neutral'>        }</span>
 544 |     | <span class='neutral'>        // invariant =&gt; if we save liquidity to tick clear pool liquidity</span>
 545 |     | <span class='unexecuted'>        if ((tickToSave != (params.zeroForOne ? params.lower : params.upper))) {</span>
 546 |     | <span class='unexecuted'>            tick.liquidityDelta += int128(pool.liquidity);</span>
 547 |     | <span class='unexecuted'>            pool.liquidity = 0;</span>
 548 |     | <span class='neutral'>        }</span>
 549 |     | <span class='unexecuted'>        ticks[tickToSave] = tick;</span>
 550 |     | <span class='unexecuted'>        return pool;</span>
 551 |     | <span class='neutral'>    }</span>
 552 |     | <span class='neutral'></span>
 553 |     | <span class='unexecuted'>    function remove(</span>
 554 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 555 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 556 |     | <span class='neutral'>        ILimitPoolStructs.UpdateCache memory cache,</span>
 557 |     | <span class='neutral'>        ILimitPoolStructs.UpdateParams memory params,</span>
 558 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
 559 |     | <span class='unexecuted'>    ) internal {</span>
 560 |     | <span class='neutral'>        // set ticks based on claim and zeroForOne</span>
 561 |     | <span class='unexecuted'>        int24 lower = params.zeroForOne ? params.claim : params.lower;</span>
 562 |     | <span class='unexecuted'>        int24 upper = params.zeroForOne ? params.upper : params.claim;</span>
 563 |     | <span class='neutral'>        {    </span>
 564 |     | <span class='unexecuted'>            ILimitPoolStructs.Tick memory tickLower = ticks[lower];</span>
 565 |     | <span class='neutral'>            </span>
 566 |     | <span class='unexecuted'>            if (cache.removeLower) {</span>
 567 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 568 |     | <span class='unexecuted'>                    tickLower.liquidityDelta -= int128(params.amount);</span>
 569 |     | <span class='neutral'>                } else {</span>
 570 |     | <span class='unexecuted'>                    tickLower.liquidityDelta += int128(params.amount);</span>
 571 |     | <span class='neutral'>                }</span>
 572 |     | <span class='unexecuted'>                ticks[lower] = tickLower;</span>
 573 |     | <span class='neutral'>            }</span>
 574 |     | <span class='unexecuted'>            clear(ticks, constants, tickMap, lower);</span>
 575 |     | <span class='neutral'>        }</span>
 576 |     | <span class='unexecuted'>        {</span>
 577 |     | <span class='unexecuted'>            ILimitPoolStructs.Tick memory tickUpper = ticks[upper];</span>
 578 |     | <span class='unexecuted'>            if (cache.removeUpper) {</span>
 579 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 580 |     | <span class='unexecuted'>                    tickUpper.liquidityDelta += int128(params.amount);</span>
 581 |     | <span class='neutral'>                } else {</span>
 582 |     | <span class='unexecuted'>                    tickUpper.liquidityDelta -= int128(params.amount);</span>
 583 |     | <span class='neutral'>                }</span>
 584 |     | <span class='unexecuted'>                ticks[upper] = tickUpper;</span>
 585 |     | <span class='neutral'>            }</span>
 586 |     | <span class='unexecuted'>            clear(ticks, constants, tickMap, upper);</span>
 587 |     | <span class='neutral'>        }</span>
 588 |     | <span class='neutral'>    }</span>
 589 |     | <span class='neutral'></span>
 590 |     | <span class='unexecuted'>    function clear(</span>
 591 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 592 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants,</span>
 593 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 594 |     | <span class='neutral'>        int24 tickToClear</span>
 595 |     | <span class='neutral'>    ) internal {</span>
 596 |     | <span class='unexecuted'>        if (_empty(ticks[tickToClear])) {</span>
 597 |     | <span class='unexecuted'>            if (tickToClear != ConstantProduct.maxTick(constants.tickSpacing) &amp;&amp;</span>
 598 |     | <span class='unexecuted'>                tickToClear != ConstantProduct.minTick(constants.tickSpacing)) {</span>
 599 |     | <span class='unexecuted'>                ticks[tickToClear] = ILimitPoolStructs.Tick(0,0);</span>
 600 |     | <span class='unexecuted'>                TickMap.unset(tickMap, tickToClear, constants.tickSpacing);</span>
 601 |     | <span class='neutral'>            }</span>
 602 |     | <span class='neutral'>        }</span>
 603 |     | <span class='neutral'>    }</span>
 604 |     | <span class='neutral'></span>
 605 |     | <span class='unexecuted'>    function _empty(</span>
 606 |     | <span class='neutral'>        ILimitPoolStructs.Tick memory tick</span>
 607 |     | <span class='neutral'>    ) internal pure returns (</span>
 608 |     | <span class='unexecuted'>        bool</span>
 609 |     | <span class='neutral'>    ) {</span>
 610 |     | <span class='unexecuted'>        if (tick.liquidityDelta != 0) {</span>
 611 |     | <span class='unexecuted'>            return false;</span>
 612 |     | <span class='neutral'>        }</span>
 613 |     | <span class='unexecuted'>        return true;</span>
 614 |     | <span class='neutral'>    }</span>
 615 |     | <span class='neutral'>}</span>
 616 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/math/ConstantProduct.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./OverflowMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/ILimitPoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/// @notice Math library that facilitates ranged liquidity calculations.</span>
   8 |     | <span class='unexecuted'>library ConstantProduct {</span>
   9 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    struct PriceBounds {</span>
  12 |     | <span class='neutral'>        uint160 min;</span>
  13 |     | <span class='neutral'>        uint160 max;</span>
  14 |     | <span class='neutral'>    }</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
  17 |     | <span class='neutral'>    ///////////////////////// DYDX MATH /////////////////////////</span>
  18 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    function getDy(</span>
  21 |     | <span class='neutral'>        uint256 liquidity,</span>
  22 |     | <span class='neutral'>        uint256 priceLower,</span>
  23 |     | <span class='neutral'>        uint256 priceUpper,</span>
  24 |     | <span class='neutral'>        bool roundUp</span>
  25 |     | <span class='unexecuted'>    ) internal pure returns (uint256 dy) {</span>
  26 |     | <span class='unexecuted'>        return _getDy(liquidity, priceLower, priceUpper, roundUp);</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    function getDx(</span>
  30 |     | <span class='neutral'>        uint256 liquidity,</span>
  31 |     | <span class='neutral'>        uint256 priceLower,</span>
  32 |     | <span class='neutral'>        uint256 priceUpper,</span>
  33 |     | <span class='neutral'>        bool roundUp</span>
  34 |     | <span class='unexecuted'>    ) internal pure returns (uint256 dx) {</span>
  35 |     | <span class='unexecuted'>        return _getDx(liquidity, priceLower, priceUpper, roundUp);</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    function _getDy(</span>
  39 |     | <span class='neutral'>        uint256 liquidity,</span>
  40 |     | <span class='neutral'>        uint256 priceLower,</span>
  41 |     | <span class='neutral'>        uint256 priceUpper,</span>
  42 |     | <span class='neutral'>        bool roundUp</span>
  43 |     | <span class='unexecuted'>    ) internal pure returns (uint256 dy) {</span>
  44 |     | <span class='neutral'>        unchecked {</span>
  45 |     | <span class='unexecuted'>            if (liquidity == 0) return 0;</span>
  46 |     | <span class='unexecuted'>            if (roundUp) {</span>
  47 |     | <span class='unexecuted'>                dy = OverflowMath.mulDivRoundingUp(liquidity, priceUpper - priceLower, Q96);</span>
  48 |     | <span class='neutral'>            } else {</span>
  49 |     | <span class='unexecuted'>                dy = OverflowMath.mulDiv(liquidity, priceUpper - priceLower, Q96);</span>
  50 |     | <span class='neutral'>            }</span>
  51 |     | <span class='neutral'>        }</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function _getDx(</span>
  55 |     | <span class='neutral'>        uint256 liquidity,</span>
  56 |     | <span class='neutral'>        uint256 priceLower,</span>
  57 |     | <span class='neutral'>        uint256 priceUpper,</span>
  58 |     | <span class='neutral'>        bool roundUp</span>
  59 |     | <span class='unexecuted'>    ) internal pure returns (uint256 dx) {</span>
  60 |     | <span class='neutral'>        unchecked {</span>
  61 |     | <span class='unexecuted'>            if (liquidity == 0) return 0;</span>
  62 |     | <span class='unexecuted'>            if (roundUp) {</span>
  63 |     | <span class='unexecuted'>                dx = OverflowMath.divRoundingUp(</span>
  64 |     | <span class='unexecuted'>                        OverflowMath.mulDivRoundingUp(</span>
  65 |     | <span class='unexecuted'>                            liquidity &lt;&lt; 96, </span>
  66 |     | <span class='unexecuted'>                            priceUpper - priceLower,</span>
  67 |     | <span class='unexecuted'>                            priceUpper</span>
  68 |     | <span class='neutral'>                        ),</span>
  69 |     | <span class='unexecuted'>                        priceLower</span>
  70 |     | <span class='neutral'>                );</span>
  71 |     | <span class='neutral'>            } else {</span>
  72 |     | <span class='unexecuted'>                dx = OverflowMath.mulDiv(</span>
  73 |     | <span class='unexecuted'>                        liquidity &lt;&lt; 96,</span>
  74 |     | <span class='unexecuted'>                        priceUpper - priceLower,</span>
  75 |     | <span class='unexecuted'>                        priceUpper</span>
  76 |     | <span class='unexecuted'>                ) / priceLower;</span>
  77 |     | <span class='neutral'>            }</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>    function getLiquidityForAmounts(</span>
  82 |     | <span class='neutral'>        uint256 priceLower,</span>
  83 |     | <span class='neutral'>        uint256 priceUpper,</span>
  84 |     | <span class='neutral'>        uint256 currentPrice,</span>
  85 |     | <span class='neutral'>        uint256 dy,</span>
  86 |     | <span class='neutral'>        uint256 dx</span>
  87 |     | <span class='unexecuted'>    ) internal pure returns (uint256 liquidity) {</span>
  88 |     | <span class='neutral'>        unchecked {</span>
  89 |     | <span class='unexecuted'>            if (priceUpper == currentPrice) {</span>
  90 |     | <span class='unexecuted'>                liquidity = OverflowMath.mulDiv(dy, Q96, priceUpper - priceLower);</span>
  91 |     | <span class='unexecuted'>            } else if (currentPrice == priceLower) {</span>
  92 |     | <span class='unexecuted'>                liquidity = OverflowMath.mulDiv(</span>
  93 |     | <span class='unexecuted'>                    dx,</span>
  94 |     | <span class='unexecuted'>                    OverflowMath.mulDiv(priceLower, priceUpper, Q96),</span>
  95 |     | <span class='unexecuted'>                    priceUpper - priceLower</span>
  96 |     | <span class='neutral'>                );</span>
  97 |     | <span class='neutral'>            } else {</span>
  98 |     | <span class='neutral'>                /// @dev - price should either be priceUpper or priceLower</span>
  99 |     | <span class='unexecuted'>                require (false, &#39;PriceOutsideBounds()&#39;);</span>
 100 |     | <span class='neutral'>            }  </span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    function getAmountsForLiquidity(</span>
 105 |     | <span class='neutral'>        uint256 priceLower,</span>
 106 |     | <span class='neutral'>        uint256 priceUpper,</span>
 107 |     | <span class='neutral'>        uint256 currentPrice,</span>
 108 |     | <span class='neutral'>        uint256 liquidityAmount,</span>
 109 |     | <span class='neutral'>        bool roundUp</span>
 110 |     | <span class='unexecuted'>    ) internal pure returns (uint128 token0amount, uint128 token1amount) {</span>
 111 |     | <span class='unexecuted'>        if (priceUpper &lt;= currentPrice) {</span>
 112 |     | <span class='unexecuted'>            token1amount = uint128(_getDy(liquidityAmount, priceLower, priceUpper, roundUp));</span>
 113 |     | <span class='unexecuted'>        } else if (currentPrice &lt;= priceLower) {</span>
 114 |     | <span class='unexecuted'>            token0amount = uint128(_getDx(liquidityAmount, priceLower, priceUpper, roundUp));</span>
 115 |     | <span class='neutral'>        } else {</span>
 116 |     | <span class='unexecuted'>            token0amount = uint128(_getDx(liquidityAmount, currentPrice, priceUpper, roundUp));</span>
 117 |     | <span class='unexecuted'>            token1amount = uint128(_getDy(liquidityAmount, priceLower, currentPrice, roundUp));</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>    function getNewPrice(</span>
 122 |     | <span class='neutral'>        uint256 price,</span>
 123 |     | <span class='neutral'>        uint256 liquidity,</span>
 124 |     | <span class='neutral'>        uint256 amount,</span>
 125 |     | <span class='neutral'>        bool zeroForOne,</span>
 126 |     | <span class='neutral'>        bool exactIn</span>
 127 |     | <span class='neutral'>    ) internal pure returns (</span>
 128 |     | <span class='unexecuted'>        uint256 newPrice</span>
 129 |     | <span class='neutral'>    ) {</span>
 130 |     | <span class='unexecuted'>        if (exactIn) {</span>
 131 |     | <span class='unexecuted'>            if (zeroForOne) {</span>
 132 |     | <span class='unexecuted'>                uint256 liquidityPadded = liquidity &lt;&lt; 96;</span>
 133 |     | <span class='unexecuted'>                newPrice = OverflowMath.mulDivRoundingUp(</span>
 134 |     | <span class='neutral'>                                liquidityPadded,</span>
 135 |     | <span class='unexecuted'>                                price,</span>
 136 |     | <span class='unexecuted'>                                liquidityPadded + price * amount</span>
 137 |     | <span class='neutral'>                    );</span>
 138 |     | <span class='neutral'>            } else {</span>
 139 |     | <span class='unexecuted'>                newPrice = price + (amount &lt;&lt; 96) / liquidity;</span>
 140 |     | <span class='neutral'>            }</span>
 141 |     | <span class='neutral'>        } else {</span>
 142 |     | <span class='unexecuted'>            if (zeroForOne) {</span>
 143 |     | <span class='unexecuted'>                newPrice = price - </span>
 144 |     | <span class='unexecuted'>                        OverflowMath.divRoundingUp(amount &lt;&lt; 96, liquidity);</span>
 145 |     | <span class='neutral'>            } else {</span>
 146 |     | <span class='unexecuted'>                uint256 liquidityPadded = uint256(liquidity) &lt;&lt; 96;</span>
 147 |     | <span class='unexecuted'>                newPrice = OverflowMath.mulDivRoundingUp(</span>
 148 |     | <span class='neutral'>                        liquidityPadded, </span>
 149 |     | <span class='unexecuted'>                        price,</span>
 150 |     | <span class='unexecuted'>                        liquidityPadded - uint256(price) * amount</span>
 151 |     | <span class='neutral'>                );</span>
 152 |     | <span class='neutral'>            }</span>
 153 |     | <span class='neutral'>        }</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
 157 |     | <span class='neutral'>    ///////////////////////// TICK MATH /////////////////////////</span>
 158 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    int24 internal constant MIN_TICK = -887272;   /// @dev - tick for price of 2^-128</span>
 161 |     | <span class='unexecuted'>    int24 internal constant MAX_TICK = -MIN_TICK; /// @dev - tick for price of 2^128</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>    function minTick(</span>
 164 |     | <span class='neutral'>        int16 tickSpacing</span>
 165 |     | <span class='neutral'>    ) internal pure returns (</span>
 166 |     | <span class='unexecuted'>        int24 tick</span>
 167 |     | <span class='neutral'>    ) {</span>
 168 |     | <span class='unexecuted'>        return MIN_TICK / tickSpacing * tickSpacing;</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>    function maxTick(</span>
 172 |     | <span class='neutral'>        int16 tickSpacing</span>
 173 |     | <span class='neutral'>    ) internal pure returns (</span>
 174 |     | <span class='unexecuted'>        int24 tick</span>
 175 |     | <span class='neutral'>    ) {</span>
 176 |     | <span class='unexecuted'>        return MAX_TICK / tickSpacing * tickSpacing;</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='unexecuted'>    function priceBounds(</span>
 180 |     | <span class='neutral'>        int16 tickSpacing</span>
 181 |     | <span class='neutral'>    ) internal pure returns (</span>
 182 |     | <span class='unexecuted'>        uint160,</span>
 183 |     | <span class='unexecuted'>        uint160</span>
 184 |     | <span class='neutral'>    ) {</span>
 185 |     | <span class='unexecuted'>        return (minPrice(tickSpacing), maxPrice(tickSpacing));</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='unexecuted'>    function minPrice(</span>
 189 |     | <span class='neutral'>        int16 tickSpacing</span>
 190 |     | <span class='neutral'>    ) internal pure returns (</span>
 191 |     | <span class='unexecuted'>        uint160 price</span>
 192 |     | <span class='neutral'>    ) {</span>
 193 |     | <span class='unexecuted'>        ILimitPoolStructs.Immutables memory constants;</span>
 194 |     | <span class='unexecuted'>        constants.tickSpacing = tickSpacing;</span>
 195 |     | <span class='unexecuted'>        return getPriceAtTick(minTick(tickSpacing), constants);</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>    function maxPrice(</span>
 199 |     | <span class='neutral'>        int16 tickSpacing</span>
 200 |     | <span class='neutral'>    ) internal pure returns (</span>
 201 |     | <span class='unexecuted'>        uint160 price</span>
 202 |     | <span class='neutral'>    ) {</span>
 203 |     | <span class='unexecuted'>        ILimitPoolStructs.Immutables memory constants;</span>
 204 |     | <span class='unexecuted'>        constants.tickSpacing = tickSpacing;</span>
 205 |     | <span class='unexecuted'>        return getPriceAtTick(maxTick(tickSpacing), constants);</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>    function checkTicks(</span>
 209 |     | <span class='neutral'>        int24 lower,</span>
 210 |     | <span class='neutral'>        int24 upper,</span>
 211 |     | <span class='neutral'>        int16 tickSpacing</span>
 212 |     | <span class='neutral'>    ) internal pure</span>
 213 |     | <span class='neutral'>    {</span>
 214 |     | <span class='unexecuted'>        if (lower &lt;= minTick(tickSpacing)) require (false, &#39;LowerTickOutOfBounds()&#39;);</span>
 215 |     | <span class='unexecuted'>        if (upper &gt;= maxTick(tickSpacing)) require (false, &#39;UpperTickOutOfBounds()&#39;);</span>
 216 |     | <span class='unexecuted'>        if (lower % tickSpacing != 0) require (false, &#39;LowerTickOutsideTickSpacing()&#39;);</span>
 217 |     | <span class='unexecuted'>        if (upper % tickSpacing != 0) require (false, &#39;UpperTickOutsideTickSpacing()&#39;);</span>
 218 |     | <span class='unexecuted'>        if (lower &gt;= upper) require (false, &#39;LowerUpperTickOrderInvalid()&#39;);</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    function checkPrice(</span>
 222 |     | <span class='neutral'>        uint160 price,</span>
 223 |     | <span class='neutral'>        PriceBounds memory bounds</span>
 224 |     | <span class='neutral'>    ) internal pure {</span>
 225 |     | <span class='neutral'>        if (price &lt; bounds.min || price &gt;= bounds.max) require (false, &#39;PriceOutOfBounds()&#39;);</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    /// @notice Calculates sqrt(1.0001^tick) * 2^96.</span>
 229 |     | <span class='neutral'>    /// @dev Throws if |tick| &gt; max tick.</span>
 230 |     | <span class='neutral'>    /// @param tick The input tick for the above formula.</span>
 231 |     | <span class='neutral'>    /// @return price Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)</span>
 232 |     | <span class='neutral'>    /// at the given tick.</span>
 233 |     | <span class='unexecuted'>    function getPriceAtTick(</span>
 234 |     | <span class='neutral'>        int24 tick,</span>
 235 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
 236 |     | <span class='neutral'>    ) internal pure returns (</span>
 237 |     | <span class='unexecuted'>        uint160 price</span>
 238 |     | <span class='unexecuted'>    ) {</span>
 239 |     | <span class='unexecuted'>        uint256 absTick = tick &lt; 0 ? uint256(-int256(tick)) : uint256(int256(tick));</span>
 240 |     | <span class='unexecuted'>        if (absTick &gt; uint256(uint24(maxTick(constants.tickSpacing)))) require (false, &#39;TickOutOfBounds()&#39;);</span>
 241 |     | <span class='unexecuted'>        unchecked {</span>
 242 |     | <span class='unexecuted'>            uint256 ratio = absTick &amp; 0x1 != 0</span>
 243 |     | <span class='unexecuted'>                ? 0xfffcb933bd6fad37aa2d162d1a594001</span>
 244 |     | <span class='neutral'>                : 0x100000000000000000000000000000000;</span>
 245 |     | <span class='unexecuted'>            if (absTick &amp; 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span>
 246 |     | <span class='unexecuted'>            if (absTick &amp; 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span>
 247 |     | <span class='unexecuted'>            if (absTick &amp; 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span>
 248 |     | <span class='unexecuted'>            if (absTick &amp; 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span>
 249 |     | <span class='unexecuted'>            if (absTick &amp; 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span>
 250 |     | <span class='unexecuted'>            if (absTick &amp; 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span>
 251 |     | <span class='unexecuted'>            if (absTick &amp; 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span>
 252 |     | <span class='unexecuted'>            if (absTick &amp; 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span>
 253 |     | <span class='unexecuted'>            if (absTick &amp; 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span>
 254 |     | <span class='unexecuted'>            if (absTick &amp; 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span>
 255 |     | <span class='unexecuted'>            if (absTick &amp; 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span>
 256 |     | <span class='unexecuted'>            if (absTick &amp; 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span>
 257 |     | <span class='unexecuted'>            if (absTick &amp; 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span>
 258 |     | <span class='unexecuted'>            if (absTick &amp; 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span>
 259 |     | <span class='unexecuted'>            if (absTick &amp; 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span>
 260 |     | <span class='unexecuted'>            if (absTick &amp; 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span>
 261 |     | <span class='unexecuted'>            if (absTick &amp; 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span>
 262 |     | <span class='unexecuted'>            if (absTick &amp; 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span>
 263 |     | <span class='unexecuted'>            if (absTick &amp; 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='unexecuted'>            if (tick &gt; 0) ratio = type(uint256).max / ratio;</span>
 266 |     | <span class='neutral'>            // This divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span>
 267 |     | <span class='neutral'>            // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.</span>
 268 |     | <span class='neutral'>            // We round up in the division so getTickAtPrice of the output price is always consistent.</span>
 269 |     | <span class='unexecuted'>            price = uint160((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1));</span>
 270 |     | <span class='neutral'>        }</span>
 271 |     | <span class='neutral'>    }</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='neutral'>    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) &lt;= ratio.</span>
 274 |     | <span class='neutral'>    /// @param price The sqrt ratio for which to compute the tick as a Q64.96.</span>
 275 |     | <span class='neutral'>    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.</span>
 276 |     | <span class='unexecuted'>    function getTickAtPrice(</span>
 277 |     | <span class='neutral'>        uint160 price,</span>
 278 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
 279 |     | <span class='unexecuted'>    ) internal pure returns (int24 tick) {</span>
 280 |     | <span class='neutral'>        // Second inequality must be &lt; because the price can never reach the price at the max tick.</span>
 281 |     | <span class='unexecuted'>        if (price &lt; constants.bounds.min || price &gt;= constants.bounds.max)</span>
 282 |     | <span class='unexecuted'>            require (false, &#39;PriceOutOfBounds()&#39;);</span>
 283 |     | <span class='unexecuted'>        uint256 ratio = uint256(price) &lt;&lt; 32;</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        uint256 r = ratio;</span>
 286 |     | <span class='neutral'>        uint256 msb = 0;</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>        assembly {</span>
 289 |     | <span class='unexecuted'>            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))</span>
 290 |     | <span class='neutral'>            msb := or(msb, f)</span>
 291 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 292 |     | <span class='neutral'>        }</span>
 293 |     | <span class='neutral'>        assembly {</span>
 294 |     | <span class='unexecuted'>            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))</span>
 295 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 296 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 297 |     | <span class='neutral'>        }</span>
 298 |     | <span class='neutral'>        assembly {</span>
 299 |     | <span class='unexecuted'>            let f := shl(5, gt(r, 0xFFFFFFFF))</span>
 300 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 301 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 302 |     | <span class='neutral'>        }</span>
 303 |     | <span class='neutral'>        assembly {</span>
 304 |     | <span class='unexecuted'>            let f := shl(4, gt(r, 0xFFFF))</span>
 305 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 306 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 307 |     | <span class='neutral'>        }</span>
 308 |     | <span class='neutral'>        assembly {</span>
 309 |     | <span class='unexecuted'>            let f := shl(3, gt(r, 0xFF))</span>
 310 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 311 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 312 |     | <span class='neutral'>        }</span>
 313 |     | <span class='neutral'>        assembly {</span>
 314 |     | <span class='unexecuted'>            let f := shl(2, gt(r, 0xF))</span>
 315 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 316 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 317 |     | <span class='neutral'>        }</span>
 318 |     | <span class='neutral'>        assembly {</span>
 319 |     | <span class='unexecuted'>            let f := shl(1, gt(r, 0x3))</span>
 320 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 321 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 322 |     | <span class='neutral'>        }</span>
 323 |     | <span class='neutral'>        assembly {</span>
 324 |     | <span class='unexecuted'>            let f := gt(r, 0x1)</span>
 325 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 326 |     | <span class='neutral'>        }</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='unexecuted'>        if (msb &gt;= 128) r = ratio &gt;&gt; (msb - 127);</span>
 329 |     | <span class='unexecuted'>        else r = ratio &lt;&lt; (127 - msb);</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='unexecuted'>        int256 log_2 = (int256(msb) - 128) &lt;&lt; 64;</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>        assembly {</span>
 334 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 335 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 336 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(63, f))</span>
 337 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 338 |     | <span class='neutral'>        }</span>
 339 |     | <span class='neutral'>        assembly {</span>
 340 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 341 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 342 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(62, f))</span>
 343 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 344 |     | <span class='neutral'>        }</span>
 345 |     | <span class='neutral'>        assembly {</span>
 346 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 347 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 348 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(61, f))</span>
 349 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 350 |     | <span class='neutral'>        }</span>
 351 |     | <span class='neutral'>        assembly {</span>
 352 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 353 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 354 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(60, f))</span>
 355 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 356 |     | <span class='neutral'>        }</span>
 357 |     | <span class='neutral'>        assembly {</span>
 358 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 359 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 360 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(59, f))</span>
 361 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 362 |     | <span class='neutral'>        }</span>
 363 |     | <span class='neutral'>        assembly {</span>
 364 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 365 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 366 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(58, f))</span>
 367 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 368 |     | <span class='neutral'>        }</span>
 369 |     | <span class='neutral'>        assembly {</span>
 370 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 371 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 372 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(57, f))</span>
 373 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 374 |     | <span class='neutral'>        }</span>
 375 |     | <span class='neutral'>        assembly {</span>
 376 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 377 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 378 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(56, f))</span>
 379 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 380 |     | <span class='neutral'>        }</span>
 381 |     | <span class='neutral'>        assembly {</span>
 382 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 383 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 384 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(55, f))</span>
 385 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 386 |     | <span class='neutral'>        }</span>
 387 |     | <span class='neutral'>        assembly {</span>
 388 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 389 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 390 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(54, f))</span>
 391 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 392 |     | <span class='neutral'>        }</span>
 393 |     | <span class='neutral'>        assembly {</span>
 394 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 395 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 396 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(53, f))</span>
 397 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 398 |     | <span class='neutral'>        }</span>
 399 |     | <span class='neutral'>        assembly {</span>
 400 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 401 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 402 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(52, f))</span>
 403 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 404 |     | <span class='neutral'>        }</span>
 405 |     | <span class='neutral'>        assembly {</span>
 406 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 407 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 408 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(51, f))</span>
 409 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 410 |     | <span class='neutral'>        }</span>
 411 |     | <span class='neutral'>        assembly {</span>
 412 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 413 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 414 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(50, f))</span>
 415 |     | <span class='neutral'>        }</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='unexecuted'>        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='unexecuted'>        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) &gt;&gt; 128);</span>
 420 |     | <span class='unexecuted'>        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) &gt;&gt; 128);</span>
 421 |     | <span class='neutral'></span>
 422 |     | <span class='unexecuted'>        tick = tickLow == tickHi ? tickLow : getPriceAtTick(tickHi, constants) &lt;= price</span>
 423 |     | <span class='unexecuted'>            ? tickHi</span>
 424 |     | <span class='unexecuted'>            : tickLow;</span>
 425 |     | <span class='neutral'>    }</span>
 426 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/math/OverflowMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Math library that facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision.</span>
   5 |     | <span class='unexecuted'>library OverflowMath {</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>    // @dev no underflow or overflow checks</span>
   8 |     | <span class='unexecuted'>    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
   9 |     | <span class='neutral'>        assembly {</span>
  10 |     | <span class='unexecuted'>            z := add(div(x, y), gt(mod(x, y), 0))</span>
  11 |     | <span class='neutral'>        }</span>
  12 |     | <span class='neutral'>    }</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    /// @notice Calculates floor(a×b÷denominator) with full precision - throws if result overflows an uint256 or denominator == 0.</span>
  15 |     | <span class='neutral'>    /// @param a The multiplicand.</span>
  16 |     | <span class='neutral'>    /// @param b The multiplier.</span>
  17 |     | <span class='neutral'>    /// @param denominator The divisor.</span>
  18 |     | <span class='neutral'>    /// @return result The 256-bit result.</span>
  19 |     | <span class='neutral'>    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.</span>
  20 |     | <span class='unexecuted'>    function mulDiv(</span>
  21 |     | <span class='neutral'>        uint256 a,</span>
  22 |     | <span class='neutral'>        uint256 b,</span>
  23 |     | <span class='neutral'>        uint256 denominator</span>
  24 |     | <span class='unexecuted'>    ) internal pure returns (uint256 result) {</span>
  25 |     | <span class='neutral'>        unchecked {</span>
  26 |     | <span class='neutral'>            // 512-bit multiply [prod1 prod0] = a * b.</span>
  27 |     | <span class='neutral'>            // Compute the product mod 2**256 and mod 2**256 - 1,</span>
  28 |     | <span class='neutral'>            // then use the Chinese Remainder Theorem to reconstruct</span>
  29 |     | <span class='neutral'>            // the 512 bit result. The result is stored in two 256</span>
  30 |     | <span class='neutral'>            // variables such that product = prod1 * 2**256 + prod0.</span>
  31 |     | <span class='neutral'>            uint256 prod0; // Least significant 256 bits of the product.</span>
  32 |     | <span class='neutral'>            uint256 prod1; // Most significant 256 bits of the product.</span>
  33 |     | <span class='neutral'>            assembly {</span>
  34 |     | <span class='unexecuted'>                let mm := mulmod(a, b, not(0))</span>
  35 |     | <span class='unexecuted'>                prod0 := mul(a, b)</span>
  36 |     | <span class='unexecuted'>                prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  37 |     | <span class='neutral'>            }</span>
  38 |     | <span class='neutral'>            // Handle non-overflow cases, 256 by 256 division.</span>
  39 |     | <span class='unexecuted'>            if (prod1 == 0) {</span>
  40 |     | <span class='unexecuted'>                require(denominator &gt; 0);</span>
  41 |     | <span class='neutral'>                assembly {</span>
  42 |     | <span class='unexecuted'>                    result := div(prod0, denominator)</span>
  43 |     | <span class='neutral'>                }</span>
  44 |     | <span class='unexecuted'>                return result;</span>
  45 |     | <span class='neutral'>            }</span>
  46 |     | <span class='neutral'>            // Make sure the result is less than 2**256 -</span>
  47 |     | <span class='neutral'>            // also prevents denominator == 0.</span>
  48 |     | <span class='unexecuted'>            require(denominator &gt; prod1);</span>
  49 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  50 |     | <span class='neutral'>            // 512 by 256 division.</span>
  51 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  52 |     | <span class='neutral'>            // Make division exact by subtracting the remainder from [prod1 prod0] -</span>
  53 |     | <span class='neutral'>            // compute remainder using mulmod.</span>
  54 |     | <span class='unexecuted'>            uint256 remainder;</span>
  55 |     | <span class='neutral'>            assembly {</span>
  56 |     | <span class='unexecuted'>                remainder := mulmod(a, b, denominator)</span>
  57 |     | <span class='neutral'>            }</span>
  58 |     | <span class='neutral'>            // Subtract 256 bit number from 512 bit number.</span>
  59 |     | <span class='neutral'>            assembly {</span>
  60 |     | <span class='unexecuted'>                prod1 := sub(prod1, gt(remainder, prod0))</span>
  61 |     | <span class='unexecuted'>                prod0 := sub(prod0, remainder)</span>
  62 |     | <span class='neutral'>            }</span>
  63 |     | <span class='neutral'>            // Factor powers of two out of denominator -</span>
  64 |     | <span class='neutral'>            // compute largest power of two divisor of denominator</span>
  65 |     | <span class='neutral'>            // (always &gt;= 1).</span>
  66 |     | <span class='unexecuted'>            uint256 twos = uint256(-int256(denominator)) &amp; denominator;</span>
  67 |     | <span class='neutral'>            // Divide denominator by power of two.</span>
  68 |     | <span class='neutral'>            assembly {</span>
  69 |     | <span class='unexecuted'>                denominator := div(denominator, twos)</span>
  70 |     | <span class='neutral'>            }</span>
  71 |     | <span class='neutral'>            // Divide [prod1 prod0] by the factors of two.</span>
  72 |     | <span class='neutral'>            assembly {</span>
  73 |     | <span class='unexecuted'>                prod0 := div(prod0, twos)</span>
  74 |     | <span class='neutral'>            }</span>
  75 |     | <span class='neutral'>            // Shift in bits from prod1 into prod0. For this we need</span>
  76 |     | <span class='neutral'>            // to flip `twos` such that it is 2**256 / twos -</span>
  77 |     | <span class='neutral'>            // if twos is zero, then it becomes one.</span>
  78 |     | <span class='neutral'>            assembly {</span>
  79 |     | <span class='unexecuted'>                twos := add(div(sub(0, twos), twos), 1)</span>
  80 |     | <span class='neutral'>            }</span>
  81 |     | <span class='unexecuted'>            prod0 |= prod1 * twos;</span>
  82 |     | <span class='neutral'>            // Invert denominator mod 2**256 -</span>
  83 |     | <span class='neutral'>            // now that denominator is an odd number, it has an inverse</span>
  84 |     | <span class='neutral'>            // modulo 2**256 such that denominator * inv = 1 mod 2**256.</span>
  85 |     | <span class='neutral'>            // Compute the inverse by starting with a seed that is correct</span>
  86 |     | <span class='neutral'>            // for four bits. That is, denominator * inv = 1 mod 2**4.</span>
  87 |     | <span class='unexecuted'>            uint256 inv = (3 * denominator) ^ 2;</span>
  88 |     | <span class='neutral'>            // Now use Newton-Raphson iteration to improve the precision.</span>
  89 |     | <span class='neutral'>            // Thanks to Hensel&#39;s lifting lemma, this also works in modular</span>
  90 |     | <span class='neutral'>            // arithmetic, doubling the correct bits in each step.</span>
  91 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**8.</span>
  92 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**16.</span>
  93 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**32.</span>
  94 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**64.</span>
  95 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**128.</span>
  96 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**256.</span>
  97 |     | <span class='neutral'>            // Because the division is now exact we can divide by multiplying</span>
  98 |     | <span class='neutral'>            // with the modular inverse of denominator. This will give us the</span>
  99 |     | <span class='neutral'>            // correct result modulo 2**256. Since the precoditions guarantee</span>
 100 |     | <span class='neutral'>            // that the outcome is less than 2**256, this is the final result.</span>
 101 |     | <span class='neutral'>            // We don&#39;t need to compute the high bits of the result and prod1</span>
 102 |     | <span class='neutral'>            // is no longer required.</span>
 103 |     | <span class='unexecuted'>            result = prod0 * inv;</span>
 104 |     | <span class='neutral'>            return result;</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice Calculates ceil(a×b÷denominator) with full precision - throws if result overflows an uint256 or denominator == 0.</span>
 109 |     | <span class='neutral'>    /// @param a The multiplicand.</span>
 110 |     | <span class='neutral'>    /// @param b The multiplier.</span>
 111 |     | <span class='neutral'>    /// @param denominator The divisor.</span>
 112 |     | <span class='neutral'>    /// @return result The 256-bit result.</span>
 113 |     | <span class='unexecuted'>    function mulDivRoundingUp(</span>
 114 |     | <span class='neutral'>        uint256 a,</span>
 115 |     | <span class='neutral'>        uint256 b,</span>
 116 |     | <span class='neutral'>        uint256 denominator</span>
 117 |     | <span class='unexecuted'>    ) internal pure returns (uint256 result) {</span>
 118 |     | <span class='unexecuted'>        result = mulDiv(a, b, denominator);</span>
 119 |     | <span class='neutral'>        unchecked {</span>
 120 |     | <span class='unexecuted'>            if (mulmod(a, b, denominator) != 0) {</span>
 121 |     | <span class='unexecuted'>                if (result &gt;= type(uint256).max) require (false, &#39;MaxUintExceeded()&#39;);</span>
 122 |     | <span class='unexecuted'>                result++;</span>
 123 |     | <span class='neutral'>            }</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'>}</span>
 127 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/math/constant-product/DyDxMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../../interfaces/modules/curves/IDyDxMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../../libraries/math/OverflowMath.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/// @notice Math library that facilitates ranged liquidity calculations.</span>
   8 |     | <span class='unexecuted'>library DyDxMath</span>
   9 |     | <span class='neutral'>{</span>
  10 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    function getDy(</span>
  13 |     | <span class='neutral'>        uint256 liquidity,</span>
  14 |     | <span class='neutral'>        uint256 priceLower,</span>
  15 |     | <span class='neutral'>        uint256 priceUpper,</span>
  16 |     | <span class='neutral'>        bool roundUp</span>
  17 |     | <span class='neutral'>    ) internal pure returns (uint256 dy) {</span>
  18 |     | <span class='neutral'>        return _getDy(liquidity, priceLower, priceUpper, roundUp);</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    function getDx(</span>
  22 |     | <span class='neutral'>        uint256 liquidity,</span>
  23 |     | <span class='neutral'>        uint256 priceLower,</span>
  24 |     | <span class='neutral'>        uint256 priceUpper,</span>
  25 |     | <span class='neutral'>        bool roundUp</span>
  26 |     | <span class='neutral'>    ) internal pure returns (uint256 dx) {</span>
  27 |     | <span class='neutral'>        return _getDx(liquidity, priceLower, priceUpper, roundUp);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function _getDy(</span>
  31 |     | <span class='neutral'>        uint256 liquidity,</span>
  32 |     | <span class='neutral'>        uint256 priceLower,</span>
  33 |     | <span class='neutral'>        uint256 priceUpper,</span>
  34 |     | <span class='neutral'>        bool roundUp</span>
  35 |     | <span class='neutral'>    ) internal pure returns (uint256 dy) {</span>
  36 |     | <span class='neutral'>        unchecked {</span>
  37 |     | <span class='neutral'>            if (roundUp) {</span>
  38 |     | <span class='neutral'>                dy = OverflowMath.mulDivRoundingUp(liquidity, priceUpper - priceLower, Q96);</span>
  39 |     | <span class='neutral'>            } else {</span>
  40 |     | <span class='neutral'>                dy = OverflowMath.mulDiv(liquidity, priceUpper - priceLower, Q96);</span>
  41 |     | <span class='neutral'>            }</span>
  42 |     | <span class='neutral'>        }</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    function _getDx(</span>
  46 |     | <span class='neutral'>        uint256 liquidity,</span>
  47 |     | <span class='neutral'>        uint256 priceLower,</span>
  48 |     | <span class='neutral'>        uint256 priceUpper,</span>
  49 |     | <span class='neutral'>        bool roundUp</span>
  50 |     | <span class='neutral'>    ) internal pure returns (uint256 dx) {</span>
  51 |     | <span class='neutral'>        unchecked {</span>
  52 |     | <span class='neutral'>            if (roundUp) {</span>
  53 |     | <span class='neutral'>                dx = OverflowMath.divRoundingUp(OverflowMath.mulDivRoundingUp(liquidity &lt;&lt; 96, priceUpper - priceLower, priceUpper), priceLower);</span>
  54 |     | <span class='neutral'>            } else {</span>
  55 |     | <span class='neutral'>                dx = OverflowMath.mulDiv(liquidity &lt;&lt; 96, priceUpper - priceLower, priceUpper) / priceLower;</span>
  56 |     | <span class='neutral'>            }</span>
  57 |     | <span class='neutral'>        }</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function getLiquidityForAmounts(</span>
  61 |     | <span class='neutral'>        uint256 priceLower,</span>
  62 |     | <span class='neutral'>        uint256 priceUpper,</span>
  63 |     | <span class='neutral'>        uint256 currentPrice,</span>
  64 |     | <span class='neutral'>        uint256 dy,</span>
  65 |     | <span class='neutral'>        uint256 dx</span>
  66 |     | <span class='neutral'>    ) internal pure returns (uint256 liquidity) {</span>
  67 |     | <span class='neutral'>        unchecked {</span>
  68 |     | <span class='neutral'>            if (priceUpper == currentPrice) {</span>
  69 |     | <span class='neutral'>                liquidity = OverflowMath.mulDiv(dy, Q96, priceUpper - priceLower);</span>
  70 |     | <span class='neutral'>            } else if (currentPrice == priceLower) {</span>
  71 |     | <span class='neutral'>                liquidity = OverflowMath.mulDiv(</span>
  72 |     | <span class='neutral'>                    dx,</span>
  73 |     | <span class='neutral'>                    OverflowMath.mulDiv(priceLower, priceUpper, Q96),</span>
  74 |     | <span class='neutral'>                    priceUpper - priceLower</span>
  75 |     | <span class='neutral'>                );</span>
  76 |     | <span class='neutral'>            } else {</span>
  77 |     | <span class='neutral'>                /// @dev - price should either be priceUpper or priceLower</span>
  78 |     | <span class='neutral'>                require (false, &#39;PriceOutsideBounds()&#39;);</span>
  79 |     | <span class='neutral'>            }  </span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function getAmountsForLiquidity(</span>
  84 |     | <span class='neutral'>        uint256 priceLower,</span>
  85 |     | <span class='neutral'>        uint256 priceUpper,</span>
  86 |     | <span class='neutral'>        uint256 currentPrice,</span>
  87 |     | <span class='neutral'>        uint256 liquidityAmount,</span>
  88 |     | <span class='neutral'>        bool roundUp</span>
  89 |     | <span class='neutral'>    ) internal pure returns (uint128 token0amount, uint128 token1amount) {</span>
  90 |     | <span class='neutral'>        if (priceUpper &lt;= currentPrice) {</span>
  91 |     | <span class='neutral'>            token1amount = uint128(_getDy(liquidityAmount, priceLower, priceUpper, roundUp));</span>
  92 |     | <span class='neutral'>        } else if (currentPrice &lt;= priceLower) {</span>
  93 |     | <span class='neutral'>            token0amount = uint128(_getDx(liquidityAmount, priceLower, priceUpper, roundUp));</span>
  94 |     | <span class='neutral'>        } else {</span>
  95 |     | <span class='neutral'>            token0amount = uint128(_getDx(liquidityAmount, currentPrice, priceUpper, roundUp));</span>
  96 |     | <span class='neutral'>            token1amount = uint128(_getDy(liquidityAmount, priceLower, currentPrice, roundUp));</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    function getNewPrice(</span>
 101 |     | <span class='neutral'>        uint256 price,</span>
 102 |     | <span class='neutral'>        uint256 liquidity,</span>
 103 |     | <span class='neutral'>        uint256 input,</span>
 104 |     | <span class='neutral'>        bool zeroForOne</span>
 105 |     | <span class='neutral'>    ) internal pure returns (</span>
 106 |     | <span class='neutral'>        uint256 newPrice</span>
 107 |     | <span class='neutral'>    ) {</span>
 108 |     | <span class='neutral'>        if (zeroForOne) {</span>
 109 |     | <span class='neutral'>            uint256 liquidityPadded = liquidity &lt;&lt; 96;</span>
 110 |     | <span class='neutral'>            newPrice = OverflowMath.mulDivRoundingUp(</span>
 111 |     | <span class='neutral'>                            liquidityPadded,</span>
 112 |     | <span class='neutral'>                            price,</span>
 113 |     | <span class='neutral'>                            liquidityPadded + price * input</span>
 114 |     | <span class='neutral'>                       );</span>
 115 |     | <span class='neutral'>        } else {</span>
 116 |     | <span class='neutral'>            newPrice = price + OverflowMath.mulDiv(input, Q96, liquidity);</span>
 117 |     | <span class='neutral'>        }</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'>}</span>
 120 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/math/constant-product/TickMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../../interfaces/modules/curves/ITickMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../../libraries/math/OverflowMath.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/// @notice Math library for computing sqrt price for ticks of size 1.0001, i.e., sqrt(1.0001^tick) as fixed point Q64.96 numbers - supports</span>
   8 |     | <span class='neutral'>/// prices between 2**-128 and 2**128 - 1.</span>
   9 |     | <span class='neutral'>/// @author Adapted from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/TickMath.sol.</span>
  10 |     | <span class='unexecuted'>library TickMath {</span>
  11 |     | <span class='neutral'>    /// @dev The minimum tick that may be passed to #getPriceAtTick computed from log base 1.0001 of 2**-128.</span>
  12 |     | <span class='neutral'>    int24 internal constant MIN_TICK = -887272;</span>
  13 |     | <span class='neutral'>    /// @dev The maximum tick that may be passed to #getPriceAtTick computed from log base 1.0001 of 2**128 - 1.</span>
  14 |     | <span class='neutral'>    int24 internal constant MAX_TICK = -MIN_TICK;</span>
  15 |     | <span class='neutral'>    uint256 private constant Q96 = 0x1000000000000000000000000;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    function minTick(</span>
  18 |     | <span class='neutral'>        int16 tickSpacing</span>
  19 |     | <span class='neutral'>    ) internal pure returns (</span>
  20 |     | <span class='neutral'>        int24 tick</span>
  21 |     | <span class='neutral'>    ) {</span>
  22 |     | <span class='neutral'>        return MIN_TICK / tickSpacing * tickSpacing;</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    function maxTick(</span>
  26 |     | <span class='neutral'>        int16 tickSpacing</span>
  27 |     | <span class='neutral'>    ) internal pure returns (</span>
  28 |     | <span class='neutral'>        int24 tick</span>
  29 |     | <span class='neutral'>    ) {</span>
  30 |     | <span class='neutral'>        return MAX_TICK / tickSpacing * tickSpacing;</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    function minPrice(</span>
  34 |     | <span class='neutral'>        int16 tickSpacing</span>
  35 |     | <span class='neutral'>    ) internal pure returns (</span>
  36 |     | <span class='neutral'>        uint160 price</span>
  37 |     | <span class='neutral'>    ) {</span>
  38 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants;</span>
  39 |     | <span class='neutral'>        constants.tickSpacing = tickSpacing;</span>
  40 |     | <span class='neutral'>        return getPriceAtTick(minTick(tickSpacing), constants);</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    function maxPrice(</span>
  44 |     | <span class='neutral'>        int16 tickSpacing</span>
  45 |     | <span class='neutral'>    ) internal pure returns (</span>
  46 |     | <span class='neutral'>        uint160 price</span>
  47 |     | <span class='neutral'>    ) {</span>
  48 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants;</span>
  49 |     | <span class='neutral'>        constants.tickSpacing = tickSpacing;</span>
  50 |     | <span class='neutral'>        return getPriceAtTick(maxTick(tickSpacing), constants);</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    function checkTicks(</span>
  54 |     | <span class='neutral'>        int24 lower,</span>
  55 |     | <span class='neutral'>        int24 upper,</span>
  56 |     | <span class='neutral'>        int16 tickSpacing</span>
  57 |     | <span class='neutral'>    ) internal pure</span>
  58 |     | <span class='neutral'>    {</span>
  59 |     | <span class='neutral'>        if (lower &lt; minTick(tickSpacing)) require (false, &#39;LowerTickOutOfBounds()&#39;);</span>
  60 |     | <span class='neutral'>        if (upper &gt; maxTick(tickSpacing)) require (false, &#39;UpperTickOutOfBounds()&#39;);</span>
  61 |     | <span class='neutral'>        if (lower % tickSpacing != 0) require (false, &#39;LowerTickOutsideTickSpacing()&#39;);</span>
  62 |     | <span class='neutral'>        if (upper % tickSpacing != 0) require (false, &#39;UpperTickOutsideTickSpacing()&#39;);</span>
  63 |     | <span class='neutral'>        if (lower &gt;= upper) require (false, &#39;LowerUpperTickOrderInvalid()&#39;);</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    function checkPrice(</span>
  67 |     | <span class='neutral'>        uint160 price,</span>
  68 |     | <span class='neutral'>        ITickMath.PriceBounds memory bounds</span>
  69 |     | <span class='neutral'>    ) internal pure {</span>
  70 |     | <span class='neutral'>        if (price &lt; bounds.min || price &gt;= bounds.max) require (false, &#39;PriceOutOfBounds()&#39;);</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /// @notice Calculates sqrt(1.0001^tick) * 2^96.</span>
  74 |     | <span class='neutral'>    /// @dev Throws if |tick| &gt; max tick.</span>
  75 |     | <span class='neutral'>    /// @param tick The input tick for the above formula.</span>
  76 |     | <span class='neutral'>    /// @return price Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)</span>
  77 |     | <span class='neutral'>    /// at the given tick.</span>
  78 |     | <span class='neutral'>    function getPriceAtTick(</span>
  79 |     | <span class='neutral'>        int24 tick,</span>
  80 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
  81 |     | <span class='neutral'>    ) internal pure returns (</span>
  82 |     | <span class='neutral'>        uint160 price</span>
  83 |     | <span class='neutral'>    ) {</span>
  84 |     | <span class='neutral'>        uint256 absTick = tick &lt; 0 ? uint256(-int256(tick)) : uint256(int256(tick));</span>
  85 |     | <span class='neutral'>        if (absTick &gt; uint256(uint24(maxTick(constants.tickSpacing)))) require (false, &#39;TickOutOfBounds()&#39;);</span>
  86 |     | <span class='neutral'>        unchecked {</span>
  87 |     | <span class='neutral'>            uint256 ratio = absTick &amp; 0x1 != 0</span>
  88 |     | <span class='neutral'>                ? 0xfffcb933bd6fad37aa2d162d1a594001</span>
  89 |     | <span class='neutral'>                : 0x100000000000000000000000000000000;</span>
  90 |     | <span class='neutral'>            if (absTick &amp; 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span>
  91 |     | <span class='neutral'>            if (absTick &amp; 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span>
  92 |     | <span class='neutral'>            if (absTick &amp; 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span>
  93 |     | <span class='neutral'>            if (absTick &amp; 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span>
  94 |     | <span class='neutral'>            if (absTick &amp; 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span>
  95 |     | <span class='neutral'>            if (absTick &amp; 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span>
  96 |     | <span class='neutral'>            if (absTick &amp; 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span>
  97 |     | <span class='neutral'>            if (absTick &amp; 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span>
  98 |     | <span class='neutral'>            if (absTick &amp; 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span>
  99 |     | <span class='neutral'>            if (absTick &amp; 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span>
 100 |     | <span class='neutral'>            if (absTick &amp; 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span>
 101 |     | <span class='neutral'>            if (absTick &amp; 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span>
 102 |     | <span class='neutral'>            if (absTick &amp; 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span>
 103 |     | <span class='neutral'>            if (absTick &amp; 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span>
 104 |     | <span class='neutral'>            if (absTick &amp; 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span>
 105 |     | <span class='neutral'>            if (absTick &amp; 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span>
 106 |     | <span class='neutral'>            if (absTick &amp; 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span>
 107 |     | <span class='neutral'>            if (absTick &amp; 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span>
 108 |     | <span class='neutral'>            if (absTick &amp; 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>            if (tick &gt; 0) ratio = type(uint256).max / ratio;</span>
 111 |     | <span class='neutral'>            // This divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span>
 112 |     | <span class='neutral'>            // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.</span>
 113 |     | <span class='neutral'>            // We round up in the division so getTickAtPrice of the output price is always consistent.</span>
 114 |     | <span class='neutral'>            price = uint160((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1));</span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) &lt;= ratio.</span>
 119 |     | <span class='neutral'>    /// @param price The sqrt ratio for which to compute the tick as a Q64.96.</span>
 120 |     | <span class='neutral'>    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.</span>
 121 |     | <span class='neutral'>    function getTickAtPrice(</span>
 122 |     | <span class='neutral'>        uint160 price,</span>
 123 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory constants</span>
 124 |     | <span class='neutral'>    ) internal pure returns (int24 tick) {</span>
 125 |     | <span class='neutral'>        // Second inequality must be &lt; because the price can never reach the price at the max tick.</span>
 126 |     | <span class='neutral'>        if (price &lt; constants.bounds.min || price &gt;= constants.bounds.max)</span>
 127 |     | <span class='neutral'>            require (false, &#39;PriceOutOfBounds()&#39;);</span>
 128 |     | <span class='neutral'>        uint256 ratio = uint256(price) &lt;&lt; 32;</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        uint256 r = ratio;</span>
 131 |     | <span class='neutral'>        uint256 msb = 0;</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>        assembly {</span>
 134 |     | <span class='neutral'>            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))</span>
 135 |     | <span class='neutral'>            msb := or(msb, f)</span>
 136 |     | <span class='neutral'>            r := shr(f, r)</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'>        assembly {</span>
 139 |     | <span class='neutral'>            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))</span>
 140 |     | <span class='neutral'>            msb := or(msb, f)</span>
 141 |     | <span class='neutral'>            r := shr(f, r)</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='neutral'>        assembly {</span>
 144 |     | <span class='neutral'>            let f := shl(5, gt(r, 0xFFFFFFFF))</span>
 145 |     | <span class='neutral'>            msb := or(msb, f)</span>
 146 |     | <span class='neutral'>            r := shr(f, r)</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'>        assembly {</span>
 149 |     | <span class='neutral'>            let f := shl(4, gt(r, 0xFFFF))</span>
 150 |     | <span class='neutral'>            msb := or(msb, f)</span>
 151 |     | <span class='neutral'>            r := shr(f, r)</span>
 152 |     | <span class='neutral'>        }</span>
 153 |     | <span class='neutral'>        assembly {</span>
 154 |     | <span class='neutral'>            let f := shl(3, gt(r, 0xFF))</span>
 155 |     | <span class='neutral'>            msb := or(msb, f)</span>
 156 |     | <span class='neutral'>            r := shr(f, r)</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='neutral'>        assembly {</span>
 159 |     | <span class='neutral'>            let f := shl(2, gt(r, 0xF))</span>
 160 |     | <span class='neutral'>            msb := or(msb, f)</span>
 161 |     | <span class='neutral'>            r := shr(f, r)</span>
 162 |     | <span class='neutral'>        }</span>
 163 |     | <span class='neutral'>        assembly {</span>
 164 |     | <span class='neutral'>            let f := shl(1, gt(r, 0x3))</span>
 165 |     | <span class='neutral'>            msb := or(msb, f)</span>
 166 |     | <span class='neutral'>            r := shr(f, r)</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='neutral'>        assembly {</span>
 169 |     | <span class='neutral'>            let f := gt(r, 0x1)</span>
 170 |     | <span class='neutral'>            msb := or(msb, f)</span>
 171 |     | <span class='neutral'>        }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>        if (msb &gt;= 128) r = ratio &gt;&gt; (msb - 127);</span>
 174 |     | <span class='neutral'>        else r = ratio &lt;&lt; (127 - msb);</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>        int256 log_2 = (int256(msb) - 128) &lt;&lt; 64;</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>        assembly {</span>
 179 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 180 |     | <span class='neutral'>            let f := shr(128, r)</span>
 181 |     | <span class='neutral'>            log_2 := or(log_2, shl(63, f))</span>
 182 |     | <span class='neutral'>            r := shr(f, r)</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'>        assembly {</span>
 185 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 186 |     | <span class='neutral'>            let f := shr(128, r)</span>
 187 |     | <span class='neutral'>            log_2 := or(log_2, shl(62, f))</span>
 188 |     | <span class='neutral'>            r := shr(f, r)</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'>        assembly {</span>
 191 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 192 |     | <span class='neutral'>            let f := shr(128, r)</span>
 193 |     | <span class='neutral'>            log_2 := or(log_2, shl(61, f))</span>
 194 |     | <span class='neutral'>            r := shr(f, r)</span>
 195 |     | <span class='neutral'>        }</span>
 196 |     | <span class='neutral'>        assembly {</span>
 197 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 198 |     | <span class='neutral'>            let f := shr(128, r)</span>
 199 |     | <span class='neutral'>            log_2 := or(log_2, shl(60, f))</span>
 200 |     | <span class='neutral'>            r := shr(f, r)</span>
 201 |     | <span class='neutral'>        }</span>
 202 |     | <span class='neutral'>        assembly {</span>
 203 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 204 |     | <span class='neutral'>            let f := shr(128, r)</span>
 205 |     | <span class='neutral'>            log_2 := or(log_2, shl(59, f))</span>
 206 |     | <span class='neutral'>            r := shr(f, r)</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'>        assembly {</span>
 209 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 210 |     | <span class='neutral'>            let f := shr(128, r)</span>
 211 |     | <span class='neutral'>            log_2 := or(log_2, shl(58, f))</span>
 212 |     | <span class='neutral'>            r := shr(f, r)</span>
 213 |     | <span class='neutral'>        }</span>
 214 |     | <span class='neutral'>        assembly {</span>
 215 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 216 |     | <span class='neutral'>            let f := shr(128, r)</span>
 217 |     | <span class='neutral'>            log_2 := or(log_2, shl(57, f))</span>
 218 |     | <span class='neutral'>            r := shr(f, r)</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'>        assembly {</span>
 221 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 222 |     | <span class='neutral'>            let f := shr(128, r)</span>
 223 |     | <span class='neutral'>            log_2 := or(log_2, shl(56, f))</span>
 224 |     | <span class='neutral'>            r := shr(f, r)</span>
 225 |     | <span class='neutral'>        }</span>
 226 |     | <span class='neutral'>        assembly {</span>
 227 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 228 |     | <span class='neutral'>            let f := shr(128, r)</span>
 229 |     | <span class='neutral'>            log_2 := or(log_2, shl(55, f))</span>
 230 |     | <span class='neutral'>            r := shr(f, r)</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='neutral'>        assembly {</span>
 233 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 234 |     | <span class='neutral'>            let f := shr(128, r)</span>
 235 |     | <span class='neutral'>            log_2 := or(log_2, shl(54, f))</span>
 236 |     | <span class='neutral'>            r := shr(f, r)</span>
 237 |     | <span class='neutral'>        }</span>
 238 |     | <span class='neutral'>        assembly {</span>
 239 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 240 |     | <span class='neutral'>            let f := shr(128, r)</span>
 241 |     | <span class='neutral'>            log_2 := or(log_2, shl(53, f))</span>
 242 |     | <span class='neutral'>            r := shr(f, r)</span>
 243 |     | <span class='neutral'>        }</span>
 244 |     | <span class='neutral'>        assembly {</span>
 245 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 246 |     | <span class='neutral'>            let f := shr(128, r)</span>
 247 |     | <span class='neutral'>            log_2 := or(log_2, shl(52, f))</span>
 248 |     | <span class='neutral'>            r := shr(f, r)</span>
 249 |     | <span class='neutral'>        }</span>
 250 |     | <span class='neutral'>        assembly {</span>
 251 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 252 |     | <span class='neutral'>            let f := shr(128, r)</span>
 253 |     | <span class='neutral'>            log_2 := or(log_2, shl(51, f))</span>
 254 |     | <span class='neutral'>            r := shr(f, r)</span>
 255 |     | <span class='neutral'>        }</span>
 256 |     | <span class='neutral'>        assembly {</span>
 257 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 258 |     | <span class='neutral'>            let f := shr(128, r)</span>
 259 |     | <span class='neutral'>            log_2 := or(log_2, shl(50, f))</span>
 260 |     | <span class='neutral'>        }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) &gt;&gt; 128);</span>
 265 |     | <span class='neutral'>        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) &gt;&gt; 128);</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>        tick = tickLow == tickHi ? tickLow : getPriceAtTick(tickHi, constants) &lt;= price</span>
 268 |     | <span class='neutral'>            ? tickHi</span>
 269 |     | <span class='neutral'>            : tickLow;</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'>}</span>
 272 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/pool/BurnCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/ILimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../Positions.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../utils/Collect.sol&#39;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>library BurnCall {</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>    error SimulateBurn(int24 lower, int24 upper, bool positionExists);</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    event BurnLimit(</span>
  13 |     | <span class='neutral'>        address indexed to,</span>
  14 |     | <span class='neutral'>        int24 lower,</span>
  15 |     | <span class='neutral'>        int24 upper,</span>
  16 |     | <span class='neutral'>        int24 claim,</span>
  17 |     | <span class='neutral'>        bool zeroForOne,</span>
  18 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  19 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
  20 |     | <span class='neutral'>        uint128 tokenOutBurned</span>
  21 |     | <span class='neutral'>    );</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function perform(</span>
  24 |     | <span class='neutral'>        ILimitPoolStructs.BurnParams memory params,</span>
  25 |     | <span class='neutral'>        ILimitPoolStructs.BurnCache memory cache,</span>
  26 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
  27 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
  28 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.Position)))</span>
  29 |     | <span class='neutral'>            storage positions</span>
  30 |     | <span class='unexecuted'>    ) internal returns (ILimitPoolStructs.BurnCache memory) {</span>
  31 |     | <span class='unexecuted'>        if (params.lower &gt;= params.upper) require (false, &#39;InvalidPositionBounds()&#39;);</span>
  32 |     | <span class='unexecuted'>        if (cache.position.epochLast == 0) require(false, &#39;PositionNotFound()&#39;);</span>
  33 |     | <span class='unexecuted'>        if (cache.position.claimPriceLast &gt; 0</span>
  34 |     | <span class='unexecuted'>            || params.claim != (params.zeroForOne ? params.lower : params.upper)</span>
  35 |     | <span class='unexecuted'>            || cache.position.epochLast &lt; (params.zeroForOne ? EpochMap.get(params.lower, tickMap, cache.constants)</span>
  36 |     | <span class='unexecuted'>                                                             : EpochMap.get(params.upper, tickMap, cache.constants)))</span>
  37 |     | <span class='neutral'>        {</span>
  38 |     | <span class='neutral'>            // position has been crossed into</span>
  39 |     | <span class='unexecuted'>            (</span>
  40 |     | <span class='neutral'>                cache.state,</span>
  41 |     | <span class='unexecuted'>                cache.pool,</span>
  42 |     | <span class='unexecuted'>                cache.position,</span>
  43 |     | <span class='unexecuted'>                params.claim</span>
  44 |     | <span class='unexecuted'>            ) = Positions.update(</span>
  45 |     | <span class='unexecuted'>                positions,</span>
  46 |     | <span class='unexecuted'>                ticks,</span>
  47 |     | <span class='unexecuted'>                tickMap,</span>
  48 |     | <span class='unexecuted'>                cache.state,</span>
  49 |     | <span class='unexecuted'>                cache.pool,</span>
  50 |     | <span class='unexecuted'>                ILimitPoolStructs.UpdateParams(</span>
  51 |     | <span class='unexecuted'>                    msg.sender,</span>
  52 |     | <span class='unexecuted'>                    params.to,</span>
  53 |     | <span class='unexecuted'>                    params.burnPercent,</span>
  54 |     | <span class='unexecuted'>                    params.lower,</span>
  55 |     | <span class='unexecuted'>                    params.upper,</span>
  56 |     | <span class='unexecuted'>                    params.claim,</span>
  57 |     | <span class='unexecuted'>                    params.zeroForOne</span>
  58 |     | <span class='neutral'>                ),</span>
  59 |     | <span class='unexecuted'>                cache.constants</span>
  60 |     | <span class='neutral'>            );</span>
  61 |     | <span class='neutral'>        } else {</span>
  62 |     | <span class='neutral'>            // position has not been crossed into</span>
  63 |     | <span class='unexecuted'>            (cache.pool, cache.position) = Positions.remove(</span>
  64 |     | <span class='unexecuted'>                positions,</span>
  65 |     | <span class='unexecuted'>                ticks,</span>
  66 |     | <span class='unexecuted'>                tickMap,</span>
  67 |     | <span class='unexecuted'>                cache.pool,</span>
  68 |     | <span class='unexecuted'>                ILimitPoolStructs.UpdateParams(</span>
  69 |     | <span class='unexecuted'>                    msg.sender,</span>
  70 |     | <span class='unexecuted'>                    params.to,</span>
  71 |     | <span class='unexecuted'>                    params.burnPercent,</span>
  72 |     | <span class='unexecuted'>                    params.lower,</span>
  73 |     | <span class='unexecuted'>                    params.upper,</span>
  74 |     | <span class='unexecuted'>                    params.zeroForOne ? params.lower : params.upper,</span>
  75 |     | <span class='unexecuted'>                    params.zeroForOne</span>
  76 |     | <span class='neutral'>                ),</span>
  77 |     | <span class='unexecuted'>                cache.constants</span>
  78 |     | <span class='neutral'>            );</span>
  79 |     | <span class='neutral'>        }</span>
  80 |     | <span class='unexecuted'>        cache = Collect.burn(</span>
  81 |     | <span class='unexecuted'>            cache,</span>
  82 |     | <span class='unexecuted'>            params</span>
  83 |     | <span class='neutral'>        );</span>
  84 |     | <span class='unexecuted'>        if ((params.zeroForOne ? params.claim != params.upper</span>
  85 |     | <span class='unexecuted'>                               : params.claim != params.lower))</span>
  86 |     | <span class='unexecuted'>            params.zeroForOne</span>
  87 |     | <span class='unexecuted'>                ? positions[msg.sender][params.claim][params.upper] = cache.position</span>
  88 |     | <span class='unexecuted'>                : positions[msg.sender][params.lower][params.claim] = cache.position;</span>
  89 |     | <span class='unexecuted'>        return cache;</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    // Echidna funcs</span>
  93 |     | <span class='unexecuted'>    function getResizedTicks(</span>
  94 |     | <span class='neutral'>        ILimitPoolStructs.BurnParams memory params,</span>
  95 |     | <span class='neutral'>        ILimitPoolStructs.BurnCache memory cache,</span>
  96 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
  97 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
  98 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.Position)))</span>
  99 |     | <span class='neutral'>            storage positions</span>
 100 |     | <span class='neutral'>    ) external {</span>
 101 |     | <span class='unexecuted'>        if (cache.position.epochLast == 0) require(false, &#39;PositionNotFound()&#39;);</span>
 102 |     | <span class='unexecuted'>        if (cache.position.claimPriceLast &gt; 0</span>
 103 |     | <span class='unexecuted'>            || params.claim != (params.zeroForOne ? params.lower : params.upper)</span>
 104 |     | <span class='unexecuted'>            || cache.position.epochLast &lt; (params.zeroForOne ? EpochMap.get(params.lower, tickMap, cache.constants)</span>
 105 |     | <span class='unexecuted'>                                                             : EpochMap.get(params.upper, tickMap, cache.constants)))</span>
 106 |     | <span class='neutral'>        {</span>
 107 |     | <span class='neutral'>            // position has been crossed into</span>
 108 |     | <span class='unexecuted'>            (</span>
 109 |     | <span class='neutral'>                cache.state,</span>
 110 |     | <span class='unexecuted'>                cache.pool,</span>
 111 |     | <span class='unexecuted'>                cache.position,</span>
 112 |     | <span class='unexecuted'>                params.claim</span>
 113 |     | <span class='unexecuted'>            ) = Positions.update(</span>
 114 |     | <span class='unexecuted'>                positions,</span>
 115 |     | <span class='unexecuted'>                ticks,</span>
 116 |     | <span class='unexecuted'>                tickMap,</span>
 117 |     | <span class='unexecuted'>                cache.state,</span>
 118 |     | <span class='unexecuted'>                cache.pool,</span>
 119 |     | <span class='unexecuted'>                ILimitPoolStructs.UpdateParams(</span>
 120 |     | <span class='unexecuted'>                    params.to,</span>
 121 |     | <span class='unexecuted'>                    params.to,</span>
 122 |     | <span class='unexecuted'>                    params.burnPercent,</span>
 123 |     | <span class='unexecuted'>                    params.lower,</span>
 124 |     | <span class='unexecuted'>                    params.upper,</span>
 125 |     | <span class='unexecuted'>                    params.claim,</span>
 126 |     | <span class='unexecuted'>                    params.zeroForOne</span>
 127 |     | <span class='neutral'>                ),</span>
 128 |     | <span class='unexecuted'>                cache.constants</span>
 129 |     | <span class='neutral'>            );</span>
 130 |     | <span class='neutral'>        } else {</span>
 131 |     | <span class='neutral'>            // position has not been crossed into</span>
 132 |     | <span class='unexecuted'>            (cache.pool, cache.position) = Positions.remove(</span>
 133 |     | <span class='unexecuted'>                positions,</span>
 134 |     | <span class='unexecuted'>                ticks,</span>
 135 |     | <span class='unexecuted'>                tickMap,</span>
 136 |     | <span class='unexecuted'>                cache.pool,</span>
 137 |     | <span class='unexecuted'>                ILimitPoolStructs.UpdateParams(</span>
 138 |     | <span class='unexecuted'>                    params.to,</span>
 139 |     | <span class='unexecuted'>                    params.to,</span>
 140 |     | <span class='unexecuted'>                    params.burnPercent,</span>
 141 |     | <span class='unexecuted'>                    params.lower,</span>
 142 |     | <span class='unexecuted'>                    params.upper,</span>
 143 |     | <span class='unexecuted'>                    params.zeroForOne ? params.lower : params.upper,</span>
 144 |     | <span class='unexecuted'>                    params.zeroForOne</span>
 145 |     | <span class='neutral'>                ),</span>
 146 |     | <span class='unexecuted'>                cache.constants</span>
 147 |     | <span class='neutral'>            );</span>
 148 |     | <span class='neutral'>        }</span>
 149 |     | <span class='unexecuted'>        cache = Collect.burn(</span>
 150 |     | <span class='unexecuted'>            cache,</span>
 151 |     | <span class='unexecuted'>            params</span>
 152 |     | <span class='neutral'>        );</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>        bool positionExists = cache.position.epochLast != 0;</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>        if ((params.zeroForOne ? params.claim != params.upper</span>
 157 |     | <span class='unexecuted'>                               : params.claim != params.lower)) {</span>
 158 |     | <span class='unexecuted'>            params.zeroForOne</span>
 159 |     | <span class='unexecuted'>                ? positions[msg.sender][params.claim][params.upper] = cache.position</span>
 160 |     | <span class='unexecuted'>                : positions[msg.sender][params.lower][params.claim] = cache.position;</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 163 |     | <span class='unexecuted'>                revert SimulateBurn(params.claim, params.upper, positionExists);</span>
 164 |     | <span class='neutral'>            }</span>
 165 |     | <span class='neutral'>            else {</span>
 166 |     | <span class='unexecuted'>                revert SimulateBurn(params.lower, params.claim, positionExists);</span>
 167 |     | <span class='neutral'>            }</span>
 168 |     | <span class='neutral'>        }</span>
 169 |     | <span class='neutral'>        </span>
 170 |     | <span class='unexecuted'>        revert SimulateBurn(params.lower, params.upper, positionExists);</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'>}</span>
 173 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/pool/MintCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/ILimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../Positions.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../utils/Collect.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../EchidnaAssertions.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../../interfaces/IERC20Minimal.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>library MintCall {</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    error SimulateMint(int24 lower, int24 upper, bool positionCreated);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    event MintLimit(</span>
  16 |     | <span class='neutral'>        address indexed to,</span>
  17 |     | <span class='neutral'>        int24 lower,</span>
  18 |     | <span class='neutral'>        int24 upper,</span>
  19 |     | <span class='neutral'>        bool zeroForOne,</span>
  20 |     | <span class='neutral'>        uint32 epochLast,</span>
  21 |     | <span class='neutral'>        uint128 amountIn,</span>
  22 |     | <span class='neutral'>        uint128 amountFilled,</span>
  23 |     | <span class='neutral'>        uint128 liquidityMinted</span>
  24 |     | <span class='neutral'>    );</span>
  25 |     | <span class='neutral'>    </span>
  26 |     | <span class='unexecuted'>    function perform(</span>
  27 |     | <span class='neutral'>        ILimitPoolStructs.MintParams memory params,</span>
  28 |     | <span class='neutral'>        ILimitPoolStructs.MintCache memory cache,</span>
  29 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
  30 |     | <span class='neutral'>        ILimitPoolStructs.PoolState storage pool,</span>
  31 |     | <span class='neutral'>        ILimitPoolStructs.PoolState storage swapPool,</span>
  32 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
  33 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage swapTicks,</span>
  34 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.Position)))</span>
  35 |     | <span class='neutral'>            storage positions</span>
  36 |     | <span class='unexecuted'>    ) internal returns (ILimitPoolStructs.MintCache memory) {</span>
  37 |     | <span class='neutral'>        // bump swapPool in case user is trying to undercut</span>
  38 |     | <span class='neutral'>        // this avoids trimming positions unnecessarily</span>
  39 |     | <span class='unexecuted'>        if (cache.swapPool.liquidity == 0) {</span>
  40 |     | <span class='unexecuted'>            (cache, cache.swapPool) = Ticks.unlock(cache, cache.swapPool, swapTicks, tickMap, !params.zeroForOne);</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>        // resize position if necessary</span>
  44 |     | <span class='unexecuted'>        (params, cache) = Positions.resize(</span>
  45 |     | <span class='unexecuted'>            params,</span>
  46 |     | <span class='unexecuted'>            cache,</span>
  47 |     | <span class='unexecuted'>            tickMap,</span>
  48 |     | <span class='unexecuted'>            swapTicks</span>
  49 |     | <span class='neutral'>        );</span>
  50 |     | <span class='neutral'>        // save state for safe reentrancy</span>
  51 |     | <span class='unexecuted'>        save(cache.swapPool, swapPool);</span>
  52 |     | <span class='neutral'>        // load position given params</span>
  53 |     | <span class='unexecuted'>        cache.position = positions[params.to][params.lower][params.upper];</span>
  54 |     | <span class='neutral'>        // transfer in token amount</span>
  55 |     | <span class='unexecuted'>        SafeTransfers.transferIn(</span>
  56 |     | <span class='unexecuted'>                                 params.zeroForOne ? cache.constants.token0 </span>
  57 |     | <span class='unexecuted'>                                                   : cache.constants.token1,</span>
  58 |     | <span class='unexecuted'>                                 params.amount + cache.swapCache.input</span>
  59 |     | <span class='neutral'>                                );</span>
  60 |     | <span class='neutral'>        // uint256 poolBalanceOut = params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0);</span>
  61 |     | <span class='unexecuted'>        EchidnaAssertions.assertPoolBalanceExceeded(</span>
  62 |     | <span class='unexecuted'>            (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)), </span>
  63 |     | <span class='unexecuted'>            cache.swapCache.output</span>
  64 |     | <span class='neutral'>        );</span>
  65 |     | <span class='neutral'>        // if swap output</span>
  66 |     | <span class='unexecuted'>        if (cache.swapCache.output &gt; 0)</span>
  67 |     | <span class='unexecuted'>            SafeTransfers.transferOut(</span>
  68 |     | <span class='unexecuted'>                params.to,</span>
  69 |     | <span class='unexecuted'>                params.zeroForOne ? cache.constants.token1 </span>
  70 |     | <span class='unexecuted'>                                  : cache.constants.token0,</span>
  71 |     | <span class='unexecuted'>                cache.swapCache.output</span>
  72 |     | <span class='neutral'>            );</span>
  73 |     | <span class='neutral'>        // bump to the next tick if there is no liquidity</span>
  74 |     | <span class='unexecuted'>        if (cache.pool.liquidity == 0) {</span>
  75 |     | <span class='neutral'>            /// @dev - this makes sure to have liquidity unlocked if undercutting</span>
  76 |     | <span class='unexecuted'>            (cache, cache.pool) = Ticks.unlock(cache, cache.pool, ticks, tickMap, params.zeroForOne);</span>
  77 |     | <span class='neutral'>        }</span>
  78 |     | <span class='neutral'>        // mint position if amount is left</span>
  79 |     | <span class='unexecuted'>        if (params.amount &gt; 0 &amp;&amp; params.lower &lt; params.upper) {</span>
  80 |     | <span class='neutral'>            /// @auditor not sure if the lower &gt;= upper case is possible</span>
  81 |     | <span class='unexecuted'>            (cache.pool, cache.position) = Positions.add(</span>
  82 |     | <span class='unexecuted'>                cache,</span>
  83 |     | <span class='unexecuted'>                ticks,</span>
  84 |     | <span class='unexecuted'>                tickMap,</span>
  85 |     | <span class='unexecuted'>                params</span>
  86 |     | <span class='neutral'>            );</span>
  87 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
  88 |     | <span class='unexecuted'>                uint160 priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
  89 |     | <span class='unexecuted'>                if (priceLower &lt;= cache.pool.price) {</span>
  90 |     | <span class='neutral'>                    // save liquidity if active</span>
  91 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
  92 |     | <span class='unexecuted'>                        cache.pool = Ticks.insertSingle(params, ticks, tickMap, cache, cache.pool, cache.constants);</span>
  93 |     | <span class='neutral'>                    }</span>
  94 |     | <span class='unexecuted'>                    cache.pool.price = priceLower;</span>
  95 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.lower;</span>
  96 |     | <span class='neutral'>                    /// @auditor - double check liquidity is set correctly for this in insertSingle</span>
  97 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
  98 |     | <span class='unexecuted'>                    cache.pool.swapEpoch += 1;</span>
  99 |     | <span class='unexecuted'>                    cache.position.claimPriceLast = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 100 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 101 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 102 |     | <span class='unexecuted'>                    EpochMap.set(params.lower, cache.pool.swapEpoch, tickMap, cache.constants);</span>
 103 |     | <span class='neutral'>                }</span>
 104 |     | <span class='unexecuted'>            } else {</span>
 105 |     | <span class='unexecuted'>                uint160 priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 106 |     | <span class='unexecuted'>                if (priceUpper &gt;= cache.pool.price) {</span>
 107 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
 108 |     | <span class='unexecuted'>                        cache.pool = Ticks.insertSingle(params, ticks, tickMap, cache, cache.pool, cache.constants);</span>
 109 |     | <span class='neutral'>                    }</span>
 110 |     | <span class='unexecuted'>                    cache.pool.price = priceUpper;</span>
 111 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.upper;</span>
 112 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
 113 |     | <span class='unexecuted'>                    cache.pool.swapEpoch += 1;</span>
 114 |     | <span class='unexecuted'>                    cache.position.claimPriceLast = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 115 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 116 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 117 |     | <span class='unexecuted'>                    EpochMap.set(params.upper, cache.pool.swapEpoch, tickMap, cache.constants);</span>
 118 |     | <span class='neutral'>                }</span>
 119 |     | <span class='neutral'>            }</span>
 120 |     | <span class='neutral'>            // save lp side for safe reentrancy</span>
 121 |     | <span class='unexecuted'>            save(cache.pool, pool);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>            // save position to storage</span>
 124 |     | <span class='unexecuted'>            positions[params.to][params.lower][params.upper] = cache.position;</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>            emit MintLimit(</span>
 127 |     | <span class='unexecuted'>                params.to,</span>
 128 |     | <span class='unexecuted'>                params.lower,</span>
 129 |     | <span class='unexecuted'>                params.upper,</span>
 130 |     | <span class='unexecuted'>                params.zeroForOne,</span>
 131 |     | <span class='unexecuted'>                cache.position.epochLast,</span>
 132 |     | <span class='unexecuted'>                uint128(params.amount + cache.swapCache.input),</span>
 133 |     | <span class='unexecuted'>                uint128(cache.swapCache.output),</span>
 134 |     | <span class='unexecuted'>                uint128(cache.liquidityMinted)</span>
 135 |     | <span class='neutral'>            );</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='unexecuted'>        return cache;</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>    function save(</span>
 141 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool,</span>
 142 |     | <span class='neutral'>        ILimitPoolStructs.PoolState storage poolState</span>
 143 |     | <span class='neutral'>    ) internal {</span>
 144 |     | <span class='unexecuted'>        poolState.price = pool.price;</span>
 145 |     | <span class='unexecuted'>        poolState.liquidity = pool.liquidity;</span>
 146 |     | <span class='unexecuted'>        poolState.liquidityGlobal = pool.liquidityGlobal;</span>
 147 |     | <span class='unexecuted'>        poolState.swapEpoch = pool.swapEpoch;</span>
 148 |     | <span class='unexecuted'>        poolState.tickAtPrice = pool.tickAtPrice;</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    // Echidna funcs</span>
 152 |     | <span class='unexecuted'>    function getResizedTicks(</span>
 153 |     | <span class='neutral'>       ILimitPoolStructs.MintParams memory params,</span>
 154 |     | <span class='neutral'>        ILimitPoolStructs.MintCache memory cache,</span>
 155 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 156 |     | <span class='neutral'>        ILimitPoolStructs.PoolState storage pool,</span>
 157 |     | <span class='neutral'>        ILimitPoolStructs.PoolState storage swapPool,</span>
 158 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 159 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage swapTicks,</span>
 160 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.Position)))</span>
 161 |     | <span class='neutral'>            storage positions</span>
 162 |     | <span class='neutral'>    ) external {</span>
 163 |     | <span class='unexecuted'>        bool positionCreated = false;</span>
 164 |     | <span class='neutral'>        // bump swapPool in case user is trying to undercut</span>
 165 |     | <span class='neutral'>        // this avoids trimming positions unnecessarily</span>
 166 |     | <span class='unexecuted'>        if (cache.swapPool.liquidity == 0) {</span>
 167 |     | <span class='unexecuted'>            (cache, cache.swapPool) = Ticks.unlock(cache, cache.swapPool, swapTicks, tickMap, !params.zeroForOne);</span>
 168 |     | <span class='neutral'>        }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>        // resize position if necessary</span>
 171 |     | <span class='unexecuted'>        (params, cache) = Positions.resize(</span>
 172 |     | <span class='unexecuted'>            params,</span>
 173 |     | <span class='unexecuted'>            cache,</span>
 174 |     | <span class='unexecuted'>            tickMap,</span>
 175 |     | <span class='unexecuted'>            swapTicks</span>
 176 |     | <span class='neutral'>        );</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>        // save state for safe reentrancy</span>
 179 |     | <span class='unexecuted'>        save(cache.swapPool, swapPool);</span>
 180 |     | <span class='neutral'>        // load position given params</span>
 181 |     | <span class='unexecuted'>        cache.position = positions[params.to][params.lower][params.upper];</span>
 182 |     | <span class='neutral'>        // transfer in token amount</span>
 183 |     | <span class='unexecuted'>        SafeTransfers.transferIn(</span>
 184 |     | <span class='unexecuted'>                                 params.zeroForOne ? cache.constants.token0 </span>
 185 |     | <span class='unexecuted'>                                                   : cache.constants.token1,</span>
 186 |     | <span class='unexecuted'>                                 params.amount + cache.swapCache.input</span>
 187 |     | <span class='neutral'>                                );</span>
 188 |     | <span class='neutral'>        // if swap output</span>
 189 |     | <span class='unexecuted'>        if (cache.swapCache.output &gt; 0)</span>
 190 |     | <span class='unexecuted'>            SafeTransfers.transferOut(</span>
 191 |     | <span class='unexecuted'>                params.to,</span>
 192 |     | <span class='unexecuted'>                params.zeroForOne ? cache.constants.token1 </span>
 193 |     | <span class='unexecuted'>                                  : cache.constants.token0,</span>
 194 |     | <span class='unexecuted'>                cache.swapCache.output</span>
 195 |     | <span class='neutral'>            );</span>
 196 |     | <span class='neutral'>        // bump to the next tick if there is no liquidity</span>
 197 |     | <span class='unexecuted'>        if (cache.pool.liquidity == 0) {</span>
 198 |     | <span class='neutral'>            /// @dev - this makes sure to have liquidity unlocked if undercutting</span>
 199 |     | <span class='unexecuted'>            (cache, cache.pool) = Ticks.unlock(cache, cache.pool, ticks, tickMap, params.zeroForOne);</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'>        // mint position if amount is left</span>
 202 |     | <span class='unexecuted'>        if (params.amount &gt; 0 &amp;&amp; params.lower &lt; params.upper) {</span>
 203 |     | <span class='neutral'>            /// @auditor not sure if the lower &gt;= upper case is possible</span>
 204 |     | <span class='unexecuted'>            (cache.pool, cache.position) = Positions.add(</span>
 205 |     | <span class='unexecuted'>                cache,</span>
 206 |     | <span class='unexecuted'>                ticks,</span>
 207 |     | <span class='unexecuted'>                tickMap,</span>
 208 |     | <span class='unexecuted'>                params</span>
 209 |     | <span class='neutral'>            );</span>
 210 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 211 |     | <span class='unexecuted'>                uint160 priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 212 |     | <span class='unexecuted'>                if (priceLower &lt;= cache.pool.price) {</span>
 213 |     | <span class='neutral'>                    // save liquidity if active</span>
 214 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
 215 |     | <span class='unexecuted'>                        cache.pool = Ticks.insertSingle(params, ticks, tickMap, cache, cache.pool, cache.constants);</span>
 216 |     | <span class='neutral'>                    }</span>
 217 |     | <span class='unexecuted'>                    cache.pool.price = priceLower;</span>
 218 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.lower;</span>
 219 |     | <span class='neutral'>                    /// @auditor - double check liquidity is set correctly for this in insertSingle</span>
 220 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
 221 |     | <span class='unexecuted'>                    cache.pool.swapEpoch += 1;</span>
 222 |     | <span class='unexecuted'>                    cache.position.claimPriceLast = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 223 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 224 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 225 |     | <span class='unexecuted'>                    EpochMap.set(params.lower, cache.pool.swapEpoch, tickMap, cache.constants);</span>
 226 |     | <span class='neutral'>                }</span>
 227 |     | <span class='unexecuted'>            } else {</span>
 228 |     | <span class='unexecuted'>                uint160 priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 229 |     | <span class='unexecuted'>                if (priceUpper &gt;= cache.pool.price) {</span>
 230 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
 231 |     | <span class='unexecuted'>                        cache.pool = Ticks.insertSingle(params, ticks, tickMap, cache, cache.pool, cache.constants);</span>
 232 |     | <span class='neutral'>                    }</span>
 233 |     | <span class='unexecuted'>                    cache.pool.price = priceUpper;</span>
 234 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.upper;</span>
 235 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
 236 |     | <span class='unexecuted'>                    cache.pool.swapEpoch += 1;</span>
 237 |     | <span class='unexecuted'>                    cache.position.claimPriceLast = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 238 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 239 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 240 |     | <span class='unexecuted'>                    EpochMap.set(params.upper, cache.pool.swapEpoch, tickMap, cache.constants);</span>
 241 |     | <span class='neutral'>                }</span>
 242 |     | <span class='neutral'>            }</span>
 243 |     | <span class='neutral'>            // save lp side for safe reentrancy</span>
 244 |     | <span class='unexecuted'>            save(cache.pool, pool);</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>            // save position to storage</span>
 247 |     | <span class='unexecuted'>            positionCreated = true;</span>
 248 |     | <span class='unexecuted'>            positions[params.to][params.lower][params.upper] = cache.position;</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='unexecuted'>            emit MintLimit(</span>
 251 |     | <span class='unexecuted'>                params.to,</span>
 252 |     | <span class='unexecuted'>                params.lower,</span>
 253 |     | <span class='unexecuted'>                params.upper,</span>
 254 |     | <span class='unexecuted'>                params.zeroForOne,</span>
 255 |     | <span class='unexecuted'>                cache.position.epochLast,</span>
 256 |     | <span class='unexecuted'>                uint128(params.amount + cache.swapCache.input),</span>
 257 |     | <span class='unexecuted'>                uint128(cache.swapCache.output),</span>
 258 |     | <span class='unexecuted'>                uint128(cache.liquidityMinted)</span>
 259 |     | <span class='neutral'>            );</span>
 260 |     | <span class='neutral'>        }</span>
 261 |     | <span class='neutral'>    </span>
 262 |     | <span class='unexecuted'>        revert SimulateMint(params.lower, params.upper, positionCreated);</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>    function balance(</span>
 266 |     | <span class='neutral'>        address token</span>
 267 |     | <span class='neutral'>    ) private view returns (uint256) {</span>
 268 |     | <span class='neutral'>        (</span>
 269 |     | <span class='neutral'>            bool success,</span>
 270 |     | <span class='neutral'>            bytes memory data</span>
 271 |     | <span class='neutral'>        ) = token.staticcall(</span>
 272 |     | <span class='neutral'>                                    abi.encodeWithSelector(</span>
 273 |     | <span class='neutral'>                                        IERC20Minimal.balanceOf.selector,</span>
 274 |     | <span class='neutral'>                                        address(this)</span>
 275 |     | <span class='neutral'>                                    )</span>
 276 |     | <span class='neutral'>                                );</span>
 277 |     | <span class='neutral'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 278 |     | <span class='neutral'>        return abi.decode(data, (uint256));</span>
 279 |     | <span class='neutral'>    }</span>
 280 |     | <span class='neutral'>}</span>
 281 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/pool/QuoteCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/ILimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../Ticks.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library QuoteCall {</span>
  8 |     | <span class='neutral'>    event Swap(</span>
  9 |     | <span class='neutral'>        address indexed recipient,</span>
 10 |     | <span class='neutral'>        bool zeroForOne,</span>
 11 |     | <span class='neutral'>        uint256 amountIn,</span>
 12 |     | <span class='neutral'>        uint256 amountOut,</span>
 13 |     | <span class='neutral'>        uint160 price,</span>
 14 |     | <span class='neutral'>        uint128 liquidity,</span>
 15 |     | <span class='neutral'>        int24 tickAtPrice</span>
 16 |     | <span class='neutral'>    );</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    function perform(</span>
 19 |     | <span class='neutral'>        ILimitPoolStructs.QuoteParams memory params,</span>
 20 |     | <span class='neutral'>        ILimitPoolStructs.SwapCache memory cache,</span>
 21 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
 22 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks</span>
 23 |     | <span class='neutral'>    ) internal view returns (</span>
 24 |     | <span class='unexecuted'>        uint256,</span>
 25 |     | <span class='unexecuted'>        uint256,</span>
 26 |     | <span class='unexecuted'>        uint160</span>
 27 |     | <span class='neutral'>    ) {</span>
 28 |     | <span class='unexecuted'>        return Ticks.quote(</span>
 29 |     | <span class='unexecuted'>            ticks,</span>
 30 |     | <span class='unexecuted'>            tickMap,</span>
 31 |     | <span class='unexecuted'>            params,</span>
 32 |     | <span class='unexecuted'>            cache,</span>
 33 |     | <span class='unexecuted'>            cache.pool</span>
 34 |     | <span class='neutral'>        );</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/pool/SwapCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/ILimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/callbacks/IPoolsharkSwapCallback.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/IERC20Minimal.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../Positions.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../Ticks.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../utils/Collect.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../utils/SafeTransfers.sol&#39;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>library SwapCall {</span>
  13 |     | <span class='neutral'>    event SwapPool0(</span>
  14 |     | <span class='neutral'>        address indexed recipient,</span>
  15 |     | <span class='neutral'>        uint128 amountIn,</span>
  16 |     | <span class='neutral'>        uint128 amountOut,</span>
  17 |     | <span class='neutral'>        uint160 priceLimit,</span>
  18 |     | <span class='neutral'>        uint160 newPrice</span>
  19 |     | <span class='neutral'>    );</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    event SwapPool1(</span>
  22 |     | <span class='neutral'>        address indexed recipient,</span>
  23 |     | <span class='neutral'>        uint128 amountIn,</span>
  24 |     | <span class='neutral'>        uint128 amountOut,</span>
  25 |     | <span class='neutral'>        uint160 priceLimit,</span>
  26 |     | <span class='neutral'>        uint160 newPrice</span>
  27 |     | <span class='neutral'>    );</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    function perform(</span>
  30 |     | <span class='neutral'>        ILimitPoolStructs.SwapParams memory params,</span>
  31 |     | <span class='neutral'>        ILimitPoolStructs.SwapCache memory cache,</span>
  32 |     | <span class='neutral'>        ILimitPoolStructs.TickMap storage tickMap,</span>
  33 |     | <span class='neutral'>        ILimitPoolStructs.PoolState storage poolState,</span>
  34 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks</span>
  35 |     | <span class='neutral'>    ) internal returns (</span>
  36 |     | <span class='unexecuted'>        int256,</span>
  37 |     | <span class='unexecuted'>        int256</span>
  38 |     | <span class='neutral'>    ) {</span>
  39 |     | <span class='unexecuted'>        (cache.pool, cache) = Ticks.swap(</span>
  40 |     | <span class='unexecuted'>            ticks,</span>
  41 |     | <span class='unexecuted'>            tickMap,</span>
  42 |     | <span class='unexecuted'>            params,</span>
  43 |     | <span class='unexecuted'>            cache,</span>
  44 |     | <span class='unexecuted'>            cache.pool</span>
  45 |     | <span class='neutral'>        );</span>
  46 |     | <span class='unexecuted'>        save(cache.pool, poolState);</span>
  47 |     | <span class='unexecuted'>        EchidnaAssertions.assertPoolBalanceExceeded(</span>
  48 |     | <span class='unexecuted'>            (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)), </span>
  49 |     | <span class='unexecuted'>            cache.output</span>
  50 |     | <span class='neutral'>        );</span>
  51 |     | <span class='neutral'>        // transfer output amount</span>
  52 |     | <span class='unexecuted'>        SafeTransfers.transferOut(</span>
  53 |     | <span class='unexecuted'>            params.to, </span>
  54 |     | <span class='unexecuted'>            params.zeroForOne ? cache.constants.token1</span>
  55 |     | <span class='unexecuted'>                              : cache.constants.token0,</span>
  56 |     | <span class='unexecuted'>            cache.output</span>
  57 |     | <span class='neutral'>        );</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        // check balance and execute callback</span>
  60 |     | <span class='unexecuted'>        uint256 balanceStart = balance(params, cache);</span>
  61 |     | <span class='unexecuted'>        IPoolsharkSwapCallback(msg.sender).poolsharkSwapCallback(</span>
  62 |     | <span class='unexecuted'>            params.zeroForOne ? -int256(cache.input) : int256(cache.output),</span>
  63 |     | <span class='unexecuted'>            params.zeroForOne ? int256(cache.output) : -int256(cache.input),</span>
  64 |     | <span class='unexecuted'>            params.callbackData</span>
  65 |     | <span class='neutral'>        );</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        // check balance requirements after callback</span>
  68 |     | <span class='unexecuted'>        if (balance(params, cache) &lt; balanceStart + cache.input)</span>
  69 |     | <span class='unexecuted'>            require(false, &#39;SwapInputAmountTooLow()&#39;);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>        return (</span>
  72 |     | <span class='unexecuted'>            params.zeroForOne ? </span>
  73 |     | <span class='neutral'>                (</span>
  74 |     | <span class='unexecuted'>                    -int256(cache.input),</span>
  75 |     | <span class='unexecuted'>                     int256(cache.output)</span>
  76 |     | <span class='neutral'>                )</span>
  77 |     | <span class='neutral'>              : (</span>
  78 |     | <span class='unexecuted'>                     int256(cache.output),</span>
  79 |     | <span class='unexecuted'>                    -int256(cache.input)</span>
  80 |     | <span class='neutral'>                )</span>
  81 |     | <span class='neutral'>        );</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    function save(</span>
  85 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool,</span>
  86 |     | <span class='neutral'>        ILimitPoolStructs.PoolState storage poolState</span>
  87 |     | <span class='neutral'>    ) internal {</span>
  88 |     | <span class='unexecuted'>        poolState.price = pool.price;</span>
  89 |     | <span class='unexecuted'>        poolState.liquidity = pool.liquidity;</span>
  90 |     | <span class='unexecuted'>        poolState.liquidityGlobal = pool.liquidityGlobal;</span>
  91 |     | <span class='unexecuted'>        poolState.swapEpoch = pool.swapEpoch;</span>
  92 |     | <span class='unexecuted'>        poolState.tickAtPrice = pool.tickAtPrice;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>    function balance(</span>
  96 |     | <span class='neutral'>        ILimitPoolStructs.SwapParams memory params,</span>
  97 |     | <span class='neutral'>        ILimitPoolStructs.SwapCache memory cache</span>
  98 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
  99 |     | <span class='unexecuted'>        (</span>
 100 |     | <span class='unexecuted'>            bool success,</span>
 101 |     | <span class='unexecuted'>            bytes memory data</span>
 102 |     | <span class='unexecuted'>        ) = (params.zeroForOne ? cache.constants.token0</span>
 103 |     | <span class='unexecuted'>                               : cache.constants.token1)</span>
 104 |     | <span class='neutral'>                               .staticcall(</span>
 105 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 106 |     | <span class='neutral'>                                        IERC20Minimal.balanceOf.selector,</span>
 107 |     | <span class='unexecuted'>                                        address(this)</span>
 108 |     | <span class='neutral'>                                    )</span>
 109 |     | <span class='neutral'>                                );</span>
 110 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 111 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>    function balance(</span>
 115 |     | <span class='neutral'>        address token</span>
 116 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 117 |     | <span class='unexecuted'>        (</span>
 118 |     | <span class='neutral'>            bool success,</span>
 119 |     | <span class='neutral'>            bytes memory data</span>
 120 |     | <span class='unexecuted'>        ) = token.staticcall(</span>
 121 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 122 |     | <span class='neutral'>                                        IERC20Minimal.balanceOf.selector,</span>
 123 |     | <span class='unexecuted'>                                        address(this)</span>
 124 |     | <span class='neutral'>                                    )</span>
 125 |     | <span class='neutral'>                                );</span>
 126 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 127 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'>}</span>
 130 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/solady/Clone.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Class with helper read functions for clone with immutable args.</span>
   5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Clone.sol)</span>
   6 |     | <span class='neutral'>/// @author Adapted from clones with immutable args by zefram.eth, Saw-mon &amp; Natalie</span>
   7 |     | <span class='neutral'>/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)</span>
   8 |     | <span class='neutral'>abstract contract Clone {</span>
   9 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type bytes.</span>
  10 |     | <span class='neutral'>    function _getArgBytes(uint256 argOffset, uint256 length)</span>
  11 |     | <span class='neutral'>        internal</span>
  12 |     | <span class='neutral'>        pure</span>
  13 |     | <span class='neutral'>        returns (bytes memory arg)</span>
  14 |     | <span class='neutral'>    {</span>
  15 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  16 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  17 |     | <span class='neutral'>        assembly {</span>
  18 |     | <span class='neutral'>            arg := mload(0x40)</span>
  19 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  20 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), length)</span>
  21 |     | <span class='neutral'>            let o := add(add(arg, 0x20), length)</span>
  22 |     | <span class='neutral'>            mstore(o, 0) // Zeroize the slot after the bytes.</span>
  23 |     | <span class='neutral'>            mstore(0x40, add(o, 0x20)) // Allocate the memory.</span>
  24 |     | <span class='neutral'>        }</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type address.</span>
  28 |     | <span class='unexecuted'>    function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {</span>
  29 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  30 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  31 |     | <span class='neutral'>        assembly {</span>
  32 |     | <span class='unexecuted'>            arg := shr(96, calldataload(add(offset, argOffset)))</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /// @dev Reads a uint256 array stored in the immutable args.</span>
  37 |     | <span class='neutral'>    function _getArgUint256Array(uint256 argOffset, uint256 length)</span>
  38 |     | <span class='neutral'>        internal</span>
  39 |     | <span class='neutral'>        pure</span>
  40 |     | <span class='neutral'>        returns (uint256[] memory arg)</span>
  41 |     | <span class='neutral'>    {</span>
  42 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  43 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  44 |     | <span class='neutral'>        assembly {</span>
  45 |     | <span class='neutral'>            arg := mload(0x40)</span>
  46 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  47 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))</span>
  48 |     | <span class='neutral'>            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /// @dev Reads a bytes32 array stored in the immutable args.</span>
  53 |     | <span class='neutral'>    function _getArgBytes32Array(uint256 argOffset, uint256 length)</span>
  54 |     | <span class='neutral'>        internal</span>
  55 |     | <span class='neutral'>        pure</span>
  56 |     | <span class='neutral'>        returns (bytes32[] memory arg)</span>
  57 |     | <span class='neutral'>    {</span>
  58 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  59 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  60 |     | <span class='neutral'>        assembly {</span>
  61 |     | <span class='neutral'>            arg := mload(0x40)</span>
  62 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  63 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))</span>
  64 |     | <span class='neutral'>            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type bytes32.</span>
  69 |     | <span class='neutral'>    function _getArgBytes32(uint256 argOffset) internal pure returns (bytes32 arg) {</span>
  70 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  71 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  72 |     | <span class='neutral'>        assembly {</span>
  73 |     | <span class='neutral'>            arg := calldataload(add(offset, argOffset))</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint256.</span>
  78 |     | <span class='neutral'>    function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {</span>
  79 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  80 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  81 |     | <span class='neutral'>        assembly {</span>
  82 |     | <span class='neutral'>            arg := calldataload(add(offset, argOffset))</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint248.</span>
  87 |     | <span class='neutral'>    function _getArgUint248(uint256 argOffset) internal pure returns (uint248 arg) {</span>
  88 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  89 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  90 |     | <span class='neutral'>        assembly {</span>
  91 |     | <span class='neutral'>            arg := shr(8, calldataload(add(offset, argOffset)))</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint240.</span>
  96 |     | <span class='neutral'>    function _getArgUint240(uint256 argOffset) internal pure returns (uint240 arg) {</span>
  97 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  98 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  99 |     | <span class='neutral'>        assembly {</span>
 100 |     | <span class='neutral'>            arg := shr(16, calldataload(add(offset, argOffset)))</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint232.</span>
 105 |     | <span class='neutral'>    function _getArgUint232(uint256 argOffset) internal pure returns (uint232 arg) {</span>
 106 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 107 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 108 |     | <span class='neutral'>        assembly {</span>
 109 |     | <span class='neutral'>            arg := shr(24, calldataload(add(offset, argOffset)))</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint224.</span>
 114 |     | <span class='neutral'>    function _getArgUint224(uint256 argOffset) internal pure returns (uint224 arg) {</span>
 115 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 116 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 117 |     | <span class='neutral'>        assembly {</span>
 118 |     | <span class='neutral'>            arg := shr(0x20, calldataload(add(offset, argOffset)))</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint216.</span>
 123 |     | <span class='neutral'>    function _getArgUint216(uint256 argOffset) internal pure returns (uint216 arg) {</span>
 124 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 125 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 126 |     | <span class='neutral'>        assembly {</span>
 127 |     | <span class='neutral'>            arg := shr(40, calldataload(add(offset, argOffset)))</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint208.</span>
 132 |     | <span class='neutral'>    function _getArgUint208(uint256 argOffset) internal pure returns (uint208 arg) {</span>
 133 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 134 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 135 |     | <span class='neutral'>        assembly {</span>
 136 |     | <span class='neutral'>            arg := shr(48, calldataload(add(offset, argOffset)))</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint200.</span>
 141 |     | <span class='neutral'>    function _getArgUint200(uint256 argOffset) internal pure returns (uint200 arg) {</span>
 142 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 143 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 144 |     | <span class='neutral'>        assembly {</span>
 145 |     | <span class='neutral'>            arg := shr(56, calldataload(add(offset, argOffset)))</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint192.</span>
 150 |     | <span class='neutral'>    function _getArgUint192(uint256 argOffset) internal pure returns (uint192 arg) {</span>
 151 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 152 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 153 |     | <span class='neutral'>        assembly {</span>
 154 |     | <span class='neutral'>            arg := shr(64, calldataload(add(offset, argOffset)))</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint184.</span>
 159 |     | <span class='neutral'>    function _getArgUint184(uint256 argOffset) internal pure returns (uint184 arg) {</span>
 160 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 161 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 162 |     | <span class='neutral'>        assembly {</span>
 163 |     | <span class='neutral'>            arg := shr(72, calldataload(add(offset, argOffset)))</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint176.</span>
 168 |     | <span class='neutral'>    function _getArgUint176(uint256 argOffset) internal pure returns (uint176 arg) {</span>
 169 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 170 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 171 |     | <span class='neutral'>        assembly {</span>
 172 |     | <span class='neutral'>            arg := shr(80, calldataload(add(offset, argOffset)))</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint168.</span>
 177 |     | <span class='neutral'>    function _getArgUint168(uint256 argOffset) internal pure returns (uint168 arg) {</span>
 178 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 179 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 180 |     | <span class='neutral'>        assembly {</span>
 181 |     | <span class='neutral'>            arg := shr(88, calldataload(add(offset, argOffset)))</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint160.</span>
 186 |     | <span class='neutral'>    function _getArgUint160(uint256 argOffset) internal pure returns (uint160 arg) {</span>
 187 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 188 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 189 |     | <span class='neutral'>        assembly {</span>
 190 |     | <span class='neutral'>            arg := shr(96, calldataload(add(offset, argOffset)))</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint152.</span>
 195 |     | <span class='neutral'>    function _getArgUint152(uint256 argOffset) internal pure returns (uint152 arg) {</span>
 196 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 197 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 198 |     | <span class='neutral'>        assembly {</span>
 199 |     | <span class='neutral'>            arg := shr(104, calldataload(add(offset, argOffset)))</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint144.</span>
 204 |     | <span class='neutral'>    function _getArgUint144(uint256 argOffset) internal pure returns (uint144 arg) {</span>
 205 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 206 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 207 |     | <span class='neutral'>        assembly {</span>
 208 |     | <span class='neutral'>            arg := shr(112, calldataload(add(offset, argOffset)))</span>
 209 |     | <span class='neutral'>        }</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint136.</span>
 213 |     | <span class='neutral'>    function _getArgUint136(uint256 argOffset) internal pure returns (uint136 arg) {</span>
 214 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 215 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 216 |     | <span class='neutral'>        assembly {</span>
 217 |     | <span class='neutral'>            arg := shr(120, calldataload(add(offset, argOffset)))</span>
 218 |     | <span class='neutral'>        }</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint128.</span>
 222 |     | <span class='neutral'>    function _getArgUint128(uint256 argOffset) internal pure returns (uint128 arg) {</span>
 223 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 224 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 225 |     | <span class='neutral'>        assembly {</span>
 226 |     | <span class='neutral'>            arg := shr(128, calldataload(add(offset, argOffset)))</span>
 227 |     | <span class='neutral'>        }</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint120.</span>
 231 |     | <span class='neutral'>    function _getArgUint120(uint256 argOffset) internal pure returns (uint120 arg) {</span>
 232 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 233 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 234 |     | <span class='neutral'>        assembly {</span>
 235 |     | <span class='neutral'>            arg := shr(136, calldataload(add(offset, argOffset)))</span>
 236 |     | <span class='neutral'>        }</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint112.</span>
 240 |     | <span class='neutral'>    function _getArgUint112(uint256 argOffset) internal pure returns (uint112 arg) {</span>
 241 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 242 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 243 |     | <span class='neutral'>        assembly {</span>
 244 |     | <span class='neutral'>            arg := shr(144, calldataload(add(offset, argOffset)))</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint104.</span>
 249 |     | <span class='neutral'>    function _getArgUint104(uint256 argOffset) internal pure returns (uint104 arg) {</span>
 250 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 251 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 252 |     | <span class='neutral'>        assembly {</span>
 253 |     | <span class='neutral'>            arg := shr(152, calldataload(add(offset, argOffset)))</span>
 254 |     | <span class='neutral'>        }</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint96.</span>
 258 |     | <span class='neutral'>    function _getArgUint96(uint256 argOffset) internal pure returns (uint96 arg) {</span>
 259 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 260 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 261 |     | <span class='neutral'>        assembly {</span>
 262 |     | <span class='neutral'>            arg := shr(160, calldataload(add(offset, argOffset)))</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint88.</span>
 267 |     | <span class='neutral'>    function _getArgUint88(uint256 argOffset) internal pure returns (uint88 arg) {</span>
 268 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 269 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 270 |     | <span class='neutral'>        assembly {</span>
 271 |     | <span class='neutral'>            arg := shr(168, calldataload(add(offset, argOffset)))</span>
 272 |     | <span class='neutral'>        }</span>
 273 |     | <span class='neutral'>    }</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint80.</span>
 276 |     | <span class='neutral'>    function _getArgUint80(uint256 argOffset) internal pure returns (uint80 arg) {</span>
 277 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 278 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 279 |     | <span class='neutral'>        assembly {</span>
 280 |     | <span class='neutral'>            arg := shr(176, calldataload(add(offset, argOffset)))</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint72.</span>
 285 |     | <span class='neutral'>    function _getArgUint72(uint256 argOffset) internal pure returns (uint72 arg) {</span>
 286 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 287 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 288 |     | <span class='neutral'>        assembly {</span>
 289 |     | <span class='neutral'>            arg := shr(184, calldataload(add(offset, argOffset)))</span>
 290 |     | <span class='neutral'>        }</span>
 291 |     | <span class='neutral'>    }</span>
 292 |     | <span class='neutral'></span>
 293 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint64.</span>
 294 |     | <span class='neutral'>    function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {</span>
 295 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 296 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 297 |     | <span class='neutral'>        assembly {</span>
 298 |     | <span class='neutral'>            arg := shr(192, calldataload(add(offset, argOffset)))</span>
 299 |     | <span class='neutral'>        }</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint56.</span>
 303 |     | <span class='neutral'>    function _getArgUint56(uint256 argOffset) internal pure returns (uint56 arg) {</span>
 304 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 305 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 306 |     | <span class='neutral'>        assembly {</span>
 307 |     | <span class='neutral'>            arg := shr(200, calldataload(add(offset, argOffset)))</span>
 308 |     | <span class='neutral'>        }</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint48.</span>
 312 |     | <span class='neutral'>    function _getArgUint48(uint256 argOffset) internal pure returns (uint48 arg) {</span>
 313 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 314 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 315 |     | <span class='neutral'>        assembly {</span>
 316 |     | <span class='neutral'>            arg := shr(208, calldataload(add(offset, argOffset)))</span>
 317 |     | <span class='neutral'>        }</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint40.</span>
 321 |     | <span class='neutral'>    function _getArgUint40(uint256 argOffset) internal pure returns (uint40 arg) {</span>
 322 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 323 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 324 |     | <span class='neutral'>        assembly {</span>
 325 |     | <span class='neutral'>            arg := shr(216, calldataload(add(offset, argOffset)))</span>
 326 |     | <span class='neutral'>        }</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint32.</span>
 330 |     | <span class='neutral'>    function _getArgUint32(uint256 argOffset) internal pure returns (uint32 arg) {</span>
 331 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 332 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 333 |     | <span class='neutral'>        assembly {</span>
 334 |     | <span class='neutral'>            arg := shr(224, calldataload(add(offset, argOffset)))</span>
 335 |     | <span class='neutral'>        }</span>
 336 |     | <span class='neutral'>    }</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint24.</span>
 339 |     | <span class='neutral'>    function _getArgUint24(uint256 argOffset) internal pure returns (uint24 arg) {</span>
 340 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 341 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 342 |     | <span class='neutral'>        assembly {</span>
 343 |     | <span class='neutral'>            arg := shr(232, calldataload(add(offset, argOffset)))</span>
 344 |     | <span class='neutral'>        }</span>
 345 |     | <span class='neutral'>    }</span>
 346 |     | <span class='neutral'></span>
 347 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint16.</span>
 348 |     | <span class='neutral'>    function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {</span>
 349 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 350 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 351 |     | <span class='neutral'>        assembly {</span>
 352 |     | <span class='unexecuted'>            arg := shr(240, calldataload(add(offset, argOffset)))</span>
 353 |     | <span class='neutral'>        }</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint8.</span>
 357 |     | <span class='neutral'>    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {</span>
 358 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 359 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 360 |     | <span class='neutral'>        assembly {</span>
 361 |     | <span class='neutral'>            arg := shr(248, calldataload(add(offset, argOffset)))</span>
 362 |     | <span class='neutral'>        }</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>    /// @return offset The offset of the packed immutable args in calldata.</span>
 366 |     | <span class='neutral'>    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {</span>
 367 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 368 |     | <span class='neutral'>        assembly {</span>
 369 |     | <span class='unexecuted'>            offset := sub(calldatasize(), shr(240, calldataload(sub(calldatasize(), 2))))</span>
 370 |     | <span class='neutral'>        }</span>
 371 |     | <span class='neutral'>    }</span>
 372 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/solady/LibClone.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Minimal proxy library.</span>
   5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)</span>
   6 |     | <span class='neutral'>/// @author Minimal proxy by 0age (https://github.com/0age)</span>
   7 |     | <span class='neutral'>/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon &amp; Natalie</span>
   8 |     | <span class='neutral'>/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)</span>
   9 |     | <span class='neutral'>///</span>
  10 |     | <span class='neutral'>/// @dev Minimal proxy:</span>
  11 |     | <span class='neutral'>/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,</span>
  12 |     | <span class='neutral'>/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,</span>
  13 |     | <span class='neutral'>/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.</span>
  14 |     | <span class='neutral'>///</span>
  15 |     | <span class='neutral'>/// @dev Clones with immutable args (CWIA):</span>
  16 |     | <span class='neutral'>/// The implementation of CWIA here implements a `receive()` method that emits the</span>
  17 |     | <span class='neutral'>/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,</span>
  18 |     | <span class='neutral'>/// enabling us to accept hard gas-capped `sends` &amp; `transfers` for maximum backwards</span>
  19 |     | <span class='neutral'>/// composability. The minimal proxy implementation does not offer this feature.</span>
  20 |     | <span class='unexecuted'>library LibClone {</span>
  21 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
  22 |     | <span class='neutral'>    /*                       CUSTOM ERRORS                        */</span>
  23 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /// @dev Unable to deploy the clone.</span>
  26 |     | <span class='neutral'>    error DeploymentFailed();</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /// @dev The salt must start with either the zero address or the caller.</span>
  29 |     | <span class='neutral'>    error SaltDoesNotStartWithCaller();</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
  32 |     | <span class='neutral'>    /*                  MINIMAL PROXY OPERATIONS                  */</span>
  33 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @dev Deploys a deterministic clone of `implementation`,</span>
  36 |     | <span class='neutral'>    /// using immutable  arguments encoded in `data`, with `salt`.</span>
  37 |     | <span class='unexecuted'>    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)</span>
  38 |     | <span class='neutral'>        internal</span>
  39 |     | <span class='unexecuted'>        returns (address instance)</span>
  40 |     | <span class='neutral'>    {</span>
  41 |     | <span class='neutral'>        assembly {</span>
  42 |     | <span class='neutral'>            // Compute the boundaries of the data and cache the memory slots around it.</span>
  43 |     | <span class='unexecuted'>            let mBefore3 := mload(sub(data, 0x60))</span>
  44 |     | <span class='unexecuted'>            let mBefore2 := mload(sub(data, 0x40))</span>
  45 |     | <span class='unexecuted'>            let mBefore1 := mload(sub(data, 0x20))</span>
  46 |     | <span class='unexecuted'>            let dataLength := mload(data)</span>
  47 |     | <span class='unexecuted'>            let dataEnd := add(add(data, 0x20), dataLength)</span>
  48 |     | <span class='unexecuted'>            let mAfter1 := mload(dataEnd)</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>            // +2 bytes for telling how much data there is appended to the call.</span>
  51 |     | <span class='unexecuted'>            let extraLength := add(dataLength, 2)</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>            // Write the bytecode before the data.</span>
  54 |     | <span class='unexecuted'>            mstore(data, 0x5af43d3d93803e606057fd5bf3)</span>
  55 |     | <span class='neutral'>            // Write the address of the implementation.</span>
  56 |     | <span class='unexecuted'>            mstore(sub(data, 0x0d), implementation)</span>
  57 |     | <span class='neutral'>            // Write the rest of the bytecode.</span>
  58 |     | <span class='unexecuted'>            mstore(</span>
  59 |     | <span class='unexecuted'>                sub(data, 0x21),</span>
  60 |     | <span class='unexecuted'>                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)</span>
  61 |     | <span class='neutral'>            )</span>
  62 |     | <span class='neutral'>            // `keccak256(&quot;ReceiveETH(uint256)&quot;)`</span>
  63 |     | <span class='unexecuted'>            mstore(</span>
  64 |     | <span class='unexecuted'>                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff</span>
  65 |     | <span class='neutral'>            )</span>
  66 |     | <span class='unexecuted'>            mstore(</span>
  67 |     | <span class='unexecuted'>                sub(data, 0x5a),</span>
  68 |     | <span class='unexecuted'>                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)</span>
  69 |     | <span class='neutral'>            )</span>
  70 |     | <span class='unexecuted'>            mstore(dataEnd, shl(0xf0, extraLength))</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>            // Create the instance.</span>
  73 |     | <span class='unexecuted'>            instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>            // If `instance` is zero, revert.</span>
  76 |     | <span class='unexecuted'>            if iszero(instance) {</span>
  77 |     | <span class='neutral'>                // Store the function selector of `DeploymentFailed()`.</span>
  78 |     | <span class='unexecuted'>                mstore(0x00, 0x30116425)</span>
  79 |     | <span class='neutral'>                // Revert with (offset, size).</span>
  80 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
  81 |     | <span class='neutral'>            }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>            // Restore the overwritten memory surrounding `data`.</span>
  84 |     | <span class='unexecuted'>            mstore(dataEnd, mAfter1)</span>
  85 |     | <span class='unexecuted'>            mstore(data, dataLength)</span>
  86 |     | <span class='unexecuted'>            mstore(sub(data, 0x20), mBefore1)</span>
  87 |     | <span class='unexecuted'>            mstore(sub(data, 0x40), mBefore2)</span>
  88 |     | <span class='unexecuted'>            mstore(sub(data, 0x60), mBefore3)</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /// @dev Returns the initialization code hash of the clone of `implementation`</span>
  93 |     | <span class='neutral'>    /// using immutable arguments encoded in `data`.</span>
  94 |     | <span class='neutral'>    /// Used for mining vanity addresses with create2crunch.</span>
  95 |     | <span class='neutral'>    function initCodeHash(address implementation, bytes memory data)</span>
  96 |     | <span class='neutral'>        internal</span>
  97 |     | <span class='neutral'>        pure</span>
  98 |     | <span class='neutral'>        returns (bytes32 hash)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='neutral'>        assembly {</span>
 101 |     | <span class='neutral'>            // Compute the boundaries of the data and cache the memory slots around it.</span>
 102 |     | <span class='unexecuted'>            let mBefore3 := mload(sub(data, 0x60))</span>
 103 |     | <span class='unexecuted'>            let mBefore2 := mload(sub(data, 0x40))</span>
 104 |     | <span class='unexecuted'>            let mBefore1 := mload(sub(data, 0x20))</span>
 105 |     | <span class='unexecuted'>            let dataLength := mload(data)</span>
 106 |     | <span class='unexecuted'>            let dataEnd := add(add(data, 0x20), dataLength)</span>
 107 |     | <span class='unexecuted'>            let mAfter1 := mload(dataEnd)</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>            // +2 bytes for telling how much data there is appended to the call.</span>
 110 |     | <span class='unexecuted'>            let extraLength := add(dataLength, 2)</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>            // Write the bytecode before the data.</span>
 113 |     | <span class='unexecuted'>            mstore(data, 0x5af43d3d93803e606057fd5bf3)</span>
 114 |     | <span class='neutral'>            // Write the address of the implementation.</span>
 115 |     | <span class='unexecuted'>            mstore(sub(data, 0x0d), implementation)</span>
 116 |     | <span class='neutral'>            // Write the rest of the bytecode.</span>
 117 |     | <span class='unexecuted'>            mstore(</span>
 118 |     | <span class='unexecuted'>                sub(data, 0x21),</span>
 119 |     | <span class='unexecuted'>                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)</span>
 120 |     | <span class='neutral'>            )</span>
 121 |     | <span class='neutral'>            // `keccak256(&quot;ReceiveETH(uint256)&quot;)`</span>
 122 |     | <span class='unexecuted'>            mstore(</span>
 123 |     | <span class='unexecuted'>                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff</span>
 124 |     | <span class='neutral'>            )</span>
 125 |     | <span class='unexecuted'>            mstore(</span>
 126 |     | <span class='unexecuted'>                sub(data, 0x5a),</span>
 127 |     | <span class='unexecuted'>                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)</span>
 128 |     | <span class='neutral'>            )</span>
 129 |     | <span class='unexecuted'>            mstore(dataEnd, shl(0xf0, extraLength))</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>            // Compute and store the bytecode hash.</span>
 132 |     | <span class='unexecuted'>            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>            // Restore the overwritten memory surrounding `data`.</span>
 135 |     | <span class='unexecuted'>            mstore(dataEnd, mAfter1)</span>
 136 |     | <span class='unexecuted'>            mstore(data, dataLength)</span>
 137 |     | <span class='unexecuted'>            mstore(sub(data, 0x20), mBefore1)</span>
 138 |     | <span class='unexecuted'>            mstore(sub(data, 0x40), mBefore2)</span>
 139 |     | <span class='unexecuted'>            mstore(sub(data, 0x60), mBefore3)</span>
 140 |     | <span class='neutral'>        }</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /// @dev Returns the address of the deterministic clone of</span>
 144 |     | <span class='neutral'>    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.</span>
 145 |     | <span class='unexecuted'>    function predictDeterministicAddress(</span>
 146 |     | <span class='neutral'>        address implementation,</span>
 147 |     | <span class='neutral'>        bytes memory data,</span>
 148 |     | <span class='neutral'>        bytes32 salt,</span>
 149 |     | <span class='neutral'>        address deployer</span>
 150 |     | <span class='neutral'>    ) internal pure returns (address predicted) {</span>
 151 |     | <span class='neutral'>        bytes32 hash = initCodeHash(implementation, data);</span>
 152 |     | <span class='unexecuted'>        predicted = predictDeterministicAddress(hash, salt, deployer);</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
 156 |     | <span class='neutral'>    /*                      OTHER OPERATIONS                      */</span>
 157 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /// @dev Returns the address when a contract with initialization code hash,</span>
 160 |     | <span class='neutral'>    /// `hash`, is deployed with `salt`, by `deployer`.</span>
 161 |     | <span class='unexecuted'>    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)</span>
 162 |     | <span class='neutral'>        internal</span>
 163 |     | <span class='neutral'>        pure</span>
 164 |     | <span class='unexecuted'>        returns (address predicted)</span>
 165 |     | <span class='neutral'>    {</span>
 166 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 167 |     | <span class='neutral'>        assembly {</span>
 168 |     | <span class='neutral'>            // Compute and store the bytecode hash.</span>
 169 |     | <span class='unexecuted'>            mstore8(0x00, 0xff) // Write the prefix.</span>
 170 |     | <span class='unexecuted'>            mstore(0x35, hash)</span>
 171 |     | <span class='unexecuted'>            mstore(0x01, shl(96, deployer))</span>
 172 |     | <span class='unexecuted'>            mstore(0x15, salt)</span>
 173 |     | <span class='unexecuted'>            predicted := keccak256(0x00, 0x55)</span>
 174 |     | <span class='neutral'>            // Restore the part of the free memory pointer that has been overwritten.</span>
 175 |     | <span class='unexecuted'>            mstore(0x35, 0)</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /// @dev Reverts if `salt` does not start with either the zero address or the caller.</span>
 180 |     | <span class='neutral'>    function checkStartsWithCaller(bytes32 salt) internal view {</span>
 181 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 182 |     | <span class='neutral'>        assembly {</span>
 183 |     | <span class='neutral'>            // If the salt does not start with the zero address or the caller.</span>
 184 |     | <span class='neutral'>            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {</span>
 185 |     | <span class='neutral'>                // Store the function selector of `SaltDoesNotStartWithCaller()`.</span>
 186 |     | <span class='neutral'>                mstore(0x00, 0x2f634836)</span>
 187 |     | <span class='neutral'>                // Revert with (offset, size).</span>
 188 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 189 |     | <span class='neutral'>            }</span>
 190 |     | <span class='neutral'>        }</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/utils/Collect.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/ILimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../Positions.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../utils/SafeTransfers.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>library Collect {</span>
  9 |     | <span class='unexecuted'>    function burn(</span>
 10 |     | <span class='neutral'>        ILimitPoolStructs.BurnCache memory cache,</span>
 11 |     | <span class='neutral'>        ILimitPoolStructs.BurnParams memory params</span>
 12 |     | <span class='neutral'>    ) internal returns (</span>
 13 |     | <span class='unexecuted'>        ILimitPoolStructs.BurnCache memory</span>
 14 |     | <span class='neutral'>    )    </span>
 15 |     | <span class='neutral'>    {</span>
 16 |     | <span class='neutral'>        // store amounts for transferOut</span>
 17 |     | <span class='unexecuted'>        uint128 amountIn  = cache.position.amountIn;</span>
 18 |     | <span class='unexecuted'>        uint128 amountOut = cache.position.amountOut;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>        /// zero out balances and transfer out</span>
 21 |     | <span class='unexecuted'>        if (amountIn &gt; 0) {</span>
 22 |     | <span class='unexecuted'>            cache.position.amountIn = 0;</span>
 23 |     | <span class='unexecuted'>            SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token1 : cache.constants.token0, amountIn);</span>
 24 |     | <span class='neutral'>        }</span>
 25 |     | <span class='unexecuted'>        if (amountOut &gt; 0) {</span>
 26 |     | <span class='unexecuted'>            cache.position.amountOut = 0;</span>
 27 |     | <span class='unexecuted'>            SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token0 : cache.constants.token1, amountOut);</span>
 28 |     | <span class='neutral'>        }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>        return cache;</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/utils/SafeCast.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Safe casting methods</span>
  5 |     | <span class='neutral'>/// @notice Contains methods for safely casting between types</span>
  6 |     | <span class='unexecuted'>library SafeCast {</span>
  7 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint128, revert on overflow</span>
  8 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
  9 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint128</span>
 10 |     | <span class='unexecuted'>    function toUint128(uint256 y) internal pure returns (uint128 z) {</span>
 11 |     | <span class='unexecuted'>        require((z = uint128(y)) == y);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint160, revert on overflow</span>
 15 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 16 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint160</span>
 17 |     | <span class='unexecuted'>    function toUint160(uint256 y) internal pure returns (uint160 z) {</span>
 18 |     | <span class='unexecuted'>        require((z = uint160(y)) == y);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /// @notice Cast a int256 to a int128, revert on overflow or underflow</span>
 22 |     | <span class='neutral'>    /// @param y The int256 to be downcasted</span>
 23 |     | <span class='neutral'>    /// @return z The downcasted integer, now type int128</span>
 24 |     | <span class='neutral'>    function toInt128(int256 y) internal pure returns (int128 z) {</span>
 25 |     | <span class='neutral'>        require((z = int128(y)) == y);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    /// @notice Cast a uint256 to a int256, revert on overflow</span>
 29 |     | <span class='neutral'>    /// @param y The uint256 to be casted</span>
 30 |     | <span class='neutral'>    /// @return z The casted integer, now type int256</span>
 31 |     | <span class='neutral'>    function toInt256(uint256 y) internal pure returns (int256 z) {</span>
 32 |     | <span class='neutral'>        require(y &lt; 2**255);</span>
 33 |     | <span class='neutral'>        z = int256(y);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/utils/SafeState.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/ILimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../interfaces/IERC20Minimal.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library Checks {</span>
  8 |     | <span class='neutral'>    function save(</span>
  9 |     | <span class='neutral'>        ILimitPoolStructs.PoolState memory pool,</span>
 10 |     | <span class='neutral'>        ILimitPoolStructs.PoolState storage poolState</span>
 11 |     | <span class='neutral'>    ) internal {</span>
 12 |     | <span class='neutral'>        poolState.price = pool.price;</span>
 13 |     | <span class='neutral'>        poolState.liquidity = pool.liquidity;</span>
 14 |     | <span class='neutral'>        poolState.liquidityGlobal = pool.liquidityGlobal;</span>
 15 |     | <span class='neutral'>        poolState.swapEpoch = pool.swapEpoch;</span>
 16 |     | <span class='neutral'>        poolState.tickAtPrice = pool.tickAtPrice;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function balance(</span>
 20 |     | <span class='neutral'>        ILimitPoolStructs.SwapParams memory params,</span>
 21 |     | <span class='neutral'>        ILimitPoolStructs.SwapCache memory cache</span>
 22 |     | <span class='neutral'>    ) private view returns (uint256) {</span>
 23 |     | <span class='neutral'>        (</span>
 24 |     | <span class='neutral'>            bool success,</span>
 25 |     | <span class='neutral'>            bytes memory data</span>
 26 |     | <span class='neutral'>        ) = (params.zeroForOne ? cache.constants.token0</span>
 27 |     | <span class='neutral'>                               : cache.constants.token1)</span>
 28 |     | <span class='neutral'>                               .staticcall(</span>
 29 |     | <span class='neutral'>                                    abi.encodeWithSelector(</span>
 30 |     | <span class='neutral'>                                        IERC20Minimal.balanceOf.selector,</span>
 31 |     | <span class='neutral'>                                        address(this)</span>
 32 |     | <span class='neutral'>                                    )</span>
 33 |     | <span class='neutral'>                                );</span>
 34 |     | <span class='neutral'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 35 |     | <span class='neutral'>        return abi.decode(data, (uint256));</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'>}</span>
 38 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/utils/SafeTransfers.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: Unlicense</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>library SafeTransfers {</span>
   7 |     | <span class='neutral'>    /**</span>
   8 |     | <span class='neutral'>     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.</span>
   9 |     | <span class='neutral'>     *      This will revert due to insufficient balance or insufficient allowance.</span>
  10 |     | <span class='neutral'>     *      This function returns the actual amount received,</span>
  11 |     | <span class='neutral'>     *      which may be less than `amount` if there is a fee attached to the transfer.</span>
  12 |     | <span class='neutral'>     *</span>
  13 |     | <span class='neutral'>     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.</span>
  14 |     | <span class='neutral'>     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca</span>
  15 |     | <span class='neutral'>     */</span>
  16 |     | <span class='neutral'>    // slither-disable-next-line assembly</span>
  17 |     | <span class='unexecuted'>    function transferIn(address token, uint256 amount) internal returns (uint256) {</span>
  18 |     | <span class='unexecuted'>        if (token == address(0)) {</span>
  19 |     | <span class='unexecuted'>            if (msg.value &lt; amount) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
  20 |     | <span class='unexecuted'>            return amount;</span>
  21 |     | <span class='neutral'>        }</span>
  22 |     | <span class='unexecuted'>        if (amount == 0) return 0;</span>
  23 |     | <span class='unexecuted'>        IERC20 erc20Token = IERC20(token);</span>
  24 |     | <span class='unexecuted'>        uint256 balanceBefore = IERC20(token).balanceOf(address(this));</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>        // ? We are checking the transfer, but since we are doing so in an assembly block</span>
  27 |     | <span class='neutral'>        // ? Slither does not pick up on that and results in a hit</span>
  28 |     | <span class='neutral'>        // slither-disable-next-line unchecked-transfer</span>
  29 |     | <span class='unexecuted'>        erc20Token.transferFrom(msg.sender, address(this), amount);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>        bool success;</span>
  32 |     | <span class='neutral'>        assembly {</span>
  33 |     | <span class='unexecuted'>            switch returndatasize()</span>
  34 |     | <span class='unexecuted'>            case 0 {</span>
  35 |     | <span class='neutral'>                // This is a non-standard ERC-20</span>
  36 |     | <span class='unexecuted'>                success := 1 // set success to true</span>
  37 |     | <span class='neutral'>            }</span>
  38 |     | <span class='unexecuted'>            case 32 {</span>
  39 |     | <span class='neutral'>                // This is a compliant ERC-20</span>
  40 |     | <span class='unexecuted'>                returndatacopy(0, 0, 32)</span>
  41 |     | <span class='unexecuted'>                success := mload(0) // Set `success = returndata` of external call</span>
  42 |     | <span class='neutral'>            }</span>
  43 |     | <span class='neutral'>            default {</span>
  44 |     | <span class='neutral'>                // This is an excessively non-compliant ERC-20, revert.</span>
  45 |     | <span class='unexecuted'>                success := 0</span>
  46 |     | <span class='neutral'>            }</span>
  47 |     | <span class='neutral'>        }</span>
  48 |     | <span class='unexecuted'>        if (!success) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        // Calculate the amount that was *actually* transferred</span>
  51 |     | <span class='unexecuted'>        uint256 balanceAfter = IERC20(token).balanceOf(address(this));</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        return balanceAfter - balanceBefore; // underflow already checked above, just subtract</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory</span>
  58 |     | <span class='neutral'>     *      error code rather than reverting. If caller has not called checked protocol&#39;s balance, this may revert due to</span>
  59 |     | <span class='neutral'>     *      insufficient cash held in this contract. If caller has checked protocol&#39;s balance prior to this call, and verified</span>
  60 |     | <span class='neutral'>     *      it is &gt;= amount, this should not revert in normal conditions.</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.</span>
  63 |     | <span class='neutral'>     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='neutral'>    // slither-disable-next-line assembly</span>
  66 |     | <span class='unexecuted'>    function transferOut(</span>
  67 |     | <span class='neutral'>        address to,</span>
  68 |     | <span class='neutral'>        address token,</span>
  69 |     | <span class='neutral'>        uint256 amount</span>
  70 |     | <span class='unexecuted'>    ) internal {</span>
  71 |     | <span class='unexecuted'>        if (token == address(0)) {</span>
  72 |     | <span class='unexecuted'>            if (address(this).balance &lt; amount) require(false, &#39;TransferFailed(address(this), to&#39;);</span>
  73 |     | <span class='unexecuted'>            payable(to).transfer(amount);</span>
  74 |     | <span class='neutral'>            return;</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='unexecuted'>        if (amount == 0) return;</span>
  77 |     | <span class='unexecuted'>        IERC20 erc20Token = IERC20(token);</span>
  78 |     | <span class='neutral'>        // ? We are checking the transfer, but since we are doing so in an assembly block</span>
  79 |     | <span class='neutral'>        // ? Slither does not pick up on that and results in a hit</span>
  80 |     | <span class='neutral'>        // slither-disable-next-line unchecked-transfer</span>
  81 |     | <span class='unexecuted'>        erc20Token.transfer(to, amount);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        bool success;</span>
  84 |     | <span class='neutral'>        assembly {</span>
  85 |     | <span class='unexecuted'>            switch returndatasize()</span>
  86 |     | <span class='unexecuted'>            case 0 {</span>
  87 |     | <span class='neutral'>                // This is a non-standard ERC-20</span>
  88 |     | <span class='unexecuted'>                success := 1 // set success to true</span>
  89 |     | <span class='neutral'>            }</span>
  90 |     | <span class='unexecuted'>            case 32 {</span>
  91 |     | <span class='neutral'>                // This is a complaint ERC-20</span>
  92 |     | <span class='unexecuted'>                returndatacopy(0, 0, 32)</span>
  93 |     | <span class='unexecuted'>                success := mload(0) // Set `success = returndata` of external call</span>
  94 |     | <span class='neutral'>            }</span>
  95 |     | <span class='neutral'>            default {</span>
  96 |     | <span class='neutral'>                // This is an excessively non-compliant ERC-20, revert.</span>
  97 |     | <span class='unexecuted'>                success := 0</span>
  98 |     | <span class='neutral'>            }</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='unexecuted'>        if (!success) require(false, &#39;TransferFailed(address(this), msg.sender&#39;);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /**</span>
 104 |     | <span class='neutral'>     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.</span>
 105 |     | <span class='neutral'>     *      This will revert due to insufficient balance or insufficient allowance.</span>
 106 |     | <span class='neutral'>     *      This function returns the actual amount received,</span>
 107 |     | <span class='neutral'>     *      which may be less than `amount` if there is a fee attached to the transfer.</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='neutral'>     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.</span>
 110 |     | <span class='neutral'>     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca</span>
 111 |     | <span class='neutral'>     */</span>
 112 |     | <span class='neutral'>    // slither-disable-next-line assembly</span>
 113 | *   | <span class='executed'>    function transferInto(address token, address sender, uint256 amount) internal returns (uint256) {</span>
 114 | *   | <span class='executed'>        if (token == address(0)) {</span>
 115 |     | <span class='unexecuted'>            if (msg.value &lt; amount) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
 116 |     | <span class='unexecuted'>            return amount;</span>
 117 |     | <span class='neutral'>        }</span>
 118 | *   | <span class='executed'>        IERC20 erc20Token = IERC20(token);</span>
 119 | *   | <span class='executed'>        uint256 balanceBefore = IERC20(token).balanceOf(address(this));</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        /// @dev - msg.sender here is the pool</span>
 122 | *r  | <span class='executed'>        erc20Token.transferFrom(sender, msg.sender, amount);</span>
 123 |     | <span class='neutral'></span>
 124 | *   | <span class='executed'>        bool success;</span>
 125 |     | <span class='neutral'>        assembly {</span>
 126 | *   | <span class='executed'>            switch returndatasize()</span>
 127 | *   | <span class='executed'>            case 0 {</span>
 128 |     | <span class='neutral'>                // This is a non-standard ERC-20</span>
 129 |     | <span class='unexecuted'>                success := 1 // set success to true</span>
 130 |     | <span class='neutral'>            }</span>
 131 | *   | <span class='executed'>            case 32 {</span>
 132 |     | <span class='neutral'>                // This is a compliant ERC-20</span>
 133 | *   | <span class='executed'>                returndatacopy(0, 0, 32)</span>
 134 | *   | <span class='executed'>                success := mload(0) // Set `success = returndata` of external call</span>
 135 |     | <span class='neutral'>            }</span>
 136 |     | <span class='neutral'>            default {</span>
 137 |     | <span class='neutral'>                // This is an excessively non-compliant ERC-20, revert.</span>
 138 |     | <span class='unexecuted'>                success := 0</span>
 139 |     | <span class='neutral'>            }</span>
 140 |     | <span class='neutral'>        }</span>
 141 | *   | <span class='executed'>        if (!success) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>        // Calculate the amount that was *actually* transferred</span>
 144 | *   | <span class='executed'>        uint256 balanceAfter = IERC20(token).balanceOf(address(this));</span>
 145 |     | <span class='neutral'></span>
 146 | *   | <span class='executed'>        return balanceAfter - balanceBefore; // underflow already checked above, just subtract</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'>}</span>
 149 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/libraries/utils/String.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library String {</span>
  5 |     | <span class='neutral'>    bytes16 private constant alphabet = &quot;0123456789abcdef&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function from(bytes32 value) internal pure returns(string memory) {</span>
  8 |     | <span class='neutral'>        return toString(abi.encodePacked(value));</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function from(address account) internal pure returns(string memory) {</span>
 12 |     | <span class='neutral'>        return toString(abi.encodePacked(account));</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function from(uint256 value) internal pure returns(string memory) {</span>
 16 |     | <span class='neutral'>        unchecked {</span>
 17 |     | <span class='unexecuted'>            uint256 length = log10(value) + 1;</span>
 18 |     | <span class='unexecuted'>            string memory buffer = new string(length);</span>
 19 |     | <span class='neutral'>            uint256 ptr;</span>
 20 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 21 |     | <span class='neutral'>            assembly {</span>
 22 |     | <span class='unexecuted'>                ptr := add(buffer, add(32, length))</span>
 23 |     | <span class='neutral'>            }</span>
 24 |     | <span class='unexecuted'>            while (true) {</span>
 25 |     | <span class='unexecuted'>                ptr--;</span>
 26 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 27 |     | <span class='neutral'>                assembly {</span>
 28 |     | <span class='unexecuted'>                    mstore8(ptr, byte(mod(value, 10), alphabet))</span>
 29 |     | <span class='neutral'>                }</span>
 30 |     | <span class='unexecuted'>                value /= 10;</span>
 31 |     | <span class='unexecuted'>                if (value == 0) break;</span>
 32 |     | <span class='neutral'>            }</span>
 33 |     | <span class='unexecuted'>            return buffer;</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function from(int256 value) internal pure returns (string memory) {</span>
 38 |     | <span class='unexecuted'>        return string(abi.encodePacked(value &lt; 0 ? &quot;-&quot; : &quot;&quot;, from(abs(value))));</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>    function abs(int256 n) internal pure returns (uint256) {</span>
 42 |     | <span class='neutral'>        unchecked {</span>
 43 |     | <span class='neutral'>            // must be unchecked in order to support `n = type(int256).min`</span>
 44 |     | <span class='unexecuted'>            return uint256(n &gt;= 0 ? n : -n);</span>
 45 |     | <span class='neutral'>        }</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>    function log10(uint256 value) internal pure returns (uint256) {</span>
 49 |     | <span class='neutral'>        uint256 result = 0;</span>
 50 |     | <span class='neutral'>        unchecked {</span>
 51 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 64) {</span>
 52 |     | <span class='unexecuted'>                value /= 10 ** 64;</span>
 53 |     | <span class='unexecuted'>                result += 64;</span>
 54 |     | <span class='neutral'>            }</span>
 55 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 32) {</span>
 56 |     | <span class='unexecuted'>                value /= 10 ** 32;</span>
 57 |     | <span class='unexecuted'>                result += 32;</span>
 58 |     | <span class='neutral'>            }</span>
 59 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 16) {</span>
 60 |     | <span class='unexecuted'>                value /= 10 ** 16;</span>
 61 |     | <span class='unexecuted'>                result += 16;</span>
 62 |     | <span class='neutral'>            }</span>
 63 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 8) {</span>
 64 |     | <span class='unexecuted'>                value /= 10 ** 8;</span>
 65 |     | <span class='unexecuted'>                result += 8;</span>
 66 |     | <span class='neutral'>            }</span>
 67 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 4) {</span>
 68 |     | <span class='unexecuted'>                value /= 10 ** 4;</span>
 69 |     | <span class='unexecuted'>                result += 4;</span>
 70 |     | <span class='neutral'>            }</span>
 71 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 2) {</span>
 72 |     | <span class='unexecuted'>                value /= 10 ** 2;</span>
 73 |     | <span class='unexecuted'>                result += 2;</span>
 74 |     | <span class='neutral'>            }</span>
 75 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 1) {</span>
 76 |     | <span class='unexecuted'>                result += 1;</span>
 77 |     | <span class='neutral'>            }</span>
 78 |     | <span class='neutral'>        }</span>
 79 |     | <span class='unexecuted'>        return result;</span>
 80 |     | <span class='neutral'>    }</span>
 81 |     | <span class='neutral'></span>
 82 |     | <span class='neutral'>    function toString(bytes memory data) internal pure returns(string memory) {</span>
 83 |     | <span class='neutral'>        bytes memory str = new bytes(2 + data.length * 2);</span>
 84 |     | <span class='neutral'>        str[0] = &quot;0&quot;;</span>
 85 |     | <span class='neutral'>        str[1] = &quot;x&quot;;</span>
 86 |     | <span class='neutral'>        for (uint i = 0; i &lt; data.length;) {</span>
 87 |     | <span class='neutral'>            str[2+i*2] = alphabet[uint(uint8(data[i] &gt;&gt; 4))];</span>
 88 |     | <span class='neutral'>            str[3+i*2] = alphabet[uint(uint8(data[i] &amp; 0x0f))];</span>
 89 |     | <span class='neutral'>            unchecked {</span>
 90 |     | <span class='neutral'>                ++i;</span>
 91 |     | <span class='neutral'>            }</span>
 92 |     | <span class='neutral'>        }</span>
 93 |     | <span class='neutral'>        return string(str);</span>
 94 |     | <span class='neutral'>    }</span>
 95 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/test/Token20.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: Unlicense</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 | *   | <span class='executed'>contract Token20 is ERC20, ERC20Burnable {</span>
  8 |     | <span class='neutral'>    uint8 _decimals;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    constructor(</span>
 11 |     | <span class='neutral'>        string memory tokenName,</span>
 12 |     | <span class='neutral'>        string memory tokenSymbol,</span>
 13 |     | <span class='neutral'>        uint8 decimals_</span>
 14 |     | <span class='unexecuted'>    ) ERC20(tokenName, tokenSymbol) {</span>
 15 |     | <span class='unexecuted'>        _decimals = decimals_;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 | *   | <span class='executed'>    function mint(address to, uint256 amount) external {</span>
 19 | *   | <span class='executed'>        _mint(to, amount);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function decimals() public view override returns (uint8) {</span>
 23 |     | <span class='unexecuted'>        return _decimals;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    function setDecimals(uint8 decimals_) public {</span>
 27 |     | <span class='unexecuted'>        _decimals = decimals_;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/utils/LimitPoolErrors.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolErrors {</span>
  5 |     | <span class='neutral'>    error Locked();</span>
  6 |     | <span class='neutral'>    error OwnerOnly();</span>
  7 |     | <span class='neutral'>    error InvalidToken();</span>
  8 |     | <span class='neutral'>    error InvalidPosition();</span>
  9 |     | <span class='neutral'>    error InvalidSwapFee();</span>
 10 |     | <span class='neutral'>    error InvalidTokenDecimals();</span>
 11 |     | <span class='neutral'>    error InvalidTickSpread();</span>
 12 |     | <span class='neutral'>    error LiquidityOverflow();</span>
 13 |     | <span class='neutral'>    error Token0Missing();</span>
 14 |     | <span class='neutral'>    error Token1Missing();</span>
 15 |     | <span class='neutral'>    error InvalidTick();</span>
 16 |     | <span class='neutral'>    error FactoryOnly();</span>
 17 |     | <span class='neutral'>    error LowerNotEvenTick();</span>
 18 |     | <span class='neutral'>    error UpperNotOddTick();</span>
 19 |     | <span class='neutral'>    error MaxTickLiquidity();</span>
 20 |     | <span class='neutral'>    error CollectToZeroAddress();</span>
 21 |     | <span class='neutral'>    error ProtocolFeeCeilingExceeded();</span>
 22 |     | <span class='neutral'>    error Overflow();</span>
 23 |     | <span class='neutral'>    error PoolAlreadyInitialized();</span>
 24 |     | <span class='neutral'>    error NotEnoughOutputLiquidity();</span>
 25 |     | <span class='neutral'>    error WaitUntilEnoughObservations();</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>abstract contract CoverTicksErrors {</span>
 29 |     | <span class='neutral'>    error WrongTickLowerRange();</span>
 30 |     | <span class='neutral'>    error WrongTickUpperRange();</span>
 31 |     | <span class='neutral'>    error WrongTickLowerOrder();</span>
 32 |     | <span class='neutral'>    error WrongTickUpperOrder();</span>
 33 |     | <span class='neutral'>    error WrongTickClaimedAt();</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>abstract contract CoverMiscErrors {</span>
 37 |     | <span class='neutral'>    // to be removed before production</span>
 38 |     | <span class='neutral'>    error NotImplementedYet();</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>abstract contract CoverPositionErrors {</span>
 42 |     | <span class='neutral'>    error NotEnoughPositionLiquidity();</span>
 43 |     | <span class='neutral'>    error InvalidClaimTick();</span>
 44 |     | <span class='neutral'>}</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>abstract contract LimitPoolFactoryErrors {</span>
 47 |     | <span class='neutral'>    error OwnerOnly();</span>
 48 |     | <span class='neutral'>    error InvalidTokenAddress();</span>
 49 |     | <span class='neutral'>    error PoolAlreadyExists();</span>
 50 |     | <span class='neutral'>    error FeeTierNotSupported();</span>
 51 |     | <span class='neutral'>    error TickSpacingNotSupported();</span>
 52 |     | <span class='neutral'>    error PoolTypeNotSupported();</span>
 53 |     | <span class='neutral'>}</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>abstract contract CoverTransferErrors {</span>
 56 |     | <span class='neutral'>    error TransferFailed(address from, address dest);</span>
 57 |     | <span class='neutral'>}</span>
 58 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/utils/LimitPoolManager.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &#39;../interfaces/ILimitPool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../interfaces/ILimitPoolFactory.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/ILimitPoolManager.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../base/events/LimitPoolManagerEvents.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Defines the actions which can be executed by the factory admin.</span>
  12 |     | <span class='neutral'> */</span>
  13 |     | <span class='unexecuted'>contract LimitPoolManager is ILimitPoolManager, LimitPoolManagerEvents {</span>
  14 |     | <span class='unexecuted'>    address public owner;</span>
  15 |     | <span class='unexecuted'>    address public feeTo;</span>
  16 |     | <span class='unexecuted'>    address public factory;</span>
  17 |     | <span class='unexecuted'>    uint16  public constant MAX_PROTOCOL_FEE = 1e4; /// @dev - max protocol fee of 1%</span>
  18 |     | <span class='neutral'>    // tickSpacing =&gt; enabled</span>
  19 |     | <span class='neutral'>    mapping(bytes32 =&gt; address) internal _implementations;</span>
  20 |     | <span class='neutral'>    mapping(int16 =&gt; bool) internal _tickSpacings;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    error InvalidTickSpacing();</span>
  23 |     | <span class='neutral'>    error TickSpacingAlreadyEnabled();</span>
  24 |     | <span class='neutral'>    error ImplementationAlreadyExists();</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    constructor() {</span>
  27 |     | <span class='unexecuted'>        owner = msg.sender;</span>
  28 |     | <span class='unexecuted'>        feeTo = msg.sender;</span>
  29 |     | <span class='unexecuted'>        emit OwnerTransfer(address(0), msg.sender);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>        // create supported tick spacings</span>
  32 |     | <span class='unexecuted'>        _tickSpacings[10] = true;</span>
  33 |     | <span class='unexecuted'>        _tickSpacings[20] = true;</span>
  34 |     | <span class='unexecuted'>        emit TickSpacingEnabled(10);</span>
  35 |     | <span class='unexecuted'>        emit TickSpacingEnabled(20);</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
  40 |     | <span class='neutral'>     */</span>
  41 |     | <span class='neutral'>    modifier onlyOwner() {</span>
  42 |     | <span class='unexecuted'>        _checkOwner();</span>
  43 |     | <span class='neutral'>        _;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    modifier onlyFeeTo() {</span>
  47 |     | <span class='unexecuted'>        _checkFeeTo();</span>
  48 |     | <span class='neutral'>        _;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /**</span>
  52 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
  53 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='unexecuted'>    function transferOwner(address newOwner) public virtual onlyOwner {</span>
  56 |     | <span class='unexecuted'>        if(newOwner == address(0)) require (false, &#39;TransferredToZeroAddress()&#39;);</span>
  57 |     | <span class='unexecuted'>        _transferOwner(newOwner);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>    function transferFeeTo(address newFeeTo) public virtual onlyFeeTo {</span>
  61 |     | <span class='unexecuted'>        if(newFeeTo == address(0)) require (false, &#39;TransferredToZeroAddress()&#39;);</span>
  62 |     | <span class='unexecuted'>        _transferFeeTo(newFeeTo);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
  67 |     | <span class='neutral'>     * Internal function without access restriction.</span>
  68 |     | <span class='neutral'>     */</span>
  69 |     | <span class='unexecuted'>    function _transferOwner(address newOwner) internal virtual {</span>
  70 |     | <span class='unexecuted'>        address oldOwner = owner;</span>
  71 |     | <span class='unexecuted'>        owner = newOwner;</span>
  72 |     | <span class='unexecuted'>        emit OwnerTransfer(oldOwner, newOwner);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /**</span>
  76 |     | <span class='neutral'>     * @dev Transfers fee collection to a new account (`newFeeTo`).</span>
  77 |     | <span class='neutral'>     * Internal function without access restriction.</span>
  78 |     | <span class='neutral'>     */</span>
  79 |     | <span class='unexecuted'>    function _transferFeeTo(address newFeeTo) internal virtual {</span>
  80 |     | <span class='unexecuted'>        address oldFeeTo = feeTo;</span>
  81 |     | <span class='unexecuted'>        feeTo = newFeeTo;</span>
  82 |     | <span class='unexecuted'>        emit OwnerTransfer(oldFeeTo, newFeeTo);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>    function enableTickSpacing(</span>
  86 |     | <span class='neutral'>        int16 tickSpacing</span>
  87 |     | <span class='neutral'>    ) external onlyOwner {</span>
  88 |     | <span class='unexecuted'>        if (_tickSpacings[tickSpacing]) revert TickSpacingAlreadyEnabled();</span>
  89 |     | <span class='unexecuted'>        if (tickSpacing &lt;= 0) revert InvalidTickSpacing();</span>
  90 |     | <span class='unexecuted'>        if (tickSpacing % 2 != 0) revert InvalidTickSpacing();</span>
  91 |     | <span class='unexecuted'>        _tickSpacings[tickSpacing] = true;</span>
  92 |     | <span class='unexecuted'>        emit TickSpacingEnabled(tickSpacing);</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>    function enableImplementation(</span>
  96 |     | <span class='neutral'>        bytes32 poolType_,</span>
  97 |     | <span class='neutral'>        address implementation_</span>
  98 |     | <span class='neutral'>    ) external onlyOwner {</span>
  99 |     | <span class='unexecuted'>        if (_implementations[poolType_] != address(0)) revert ImplementationAlreadyExists();</span>
 100 |     | <span class='unexecuted'>        _implementations[poolType_] = implementation_;</span>
 101 |     | <span class='unexecuted'>        emit ImplementationEnabled(poolType_, implementation_);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    function setFactory(</span>
 105 |     | <span class='neutral'>        address factory_</span>
 106 |     | <span class='neutral'>    ) external onlyOwner {</span>
 107 |     | <span class='unexecuted'>        if (factory != address(0)) require (false, &#39;FactoryAlreadySet()&#39;);</span>
 108 |     | <span class='unexecuted'>        emit FactoryChanged(factory, factory_);</span>
 109 |     | <span class='unexecuted'>        factory = factory_;</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>    function collectProtocolFees(</span>
 113 |     | <span class='neutral'>        address[] calldata collectPools</span>
 114 |     | <span class='unexecuted'>    ) external {</span>
 115 |     | <span class='unexecuted'>        if (collectPools.length == 0) require (false, &#39;EmptyPoolsArray()&#39;);</span>
 116 |     | <span class='unexecuted'>        uint128[] memory token0Fees = new uint128[](collectPools.length);</span>
 117 |     | <span class='unexecuted'>        uint128[] memory token1Fees = new uint128[](collectPools.length);</span>
 118 |     | <span class='unexecuted'>        for (uint i; i &lt; collectPools.length;) {</span>
 119 |     | <span class='unexecuted'>            (token0Fees[i], token1Fees[i]) = ILimitPool(collectPools[i]).fees(0,0,false);</span>
 120 |     | <span class='neutral'>            unchecked {</span>
 121 |     | <span class='unexecuted'>                ++i;</span>
 122 |     | <span class='neutral'>            }</span>
 123 |     | <span class='neutral'>        }</span>
 124 |     | <span class='unexecuted'>        emit ProtocolFeesCollected(collectPools, token0Fees, token1Fees);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>    function modifyProtocolFees(</span>
 128 |     | <span class='neutral'>        address[] calldata modifyPools,</span>
 129 |     | <span class='neutral'>        uint16[] calldata syncFees,</span>
 130 |     | <span class='neutral'>        uint16[] calldata fillFees,</span>
 131 |     | <span class='neutral'>        bool[] calldata setFees</span>
 132 |     | <span class='unexecuted'>    ) external onlyOwner {</span>
 133 |     | <span class='unexecuted'>        if (modifyPools.length == 0) require (false, &#39;EmptyPoolsArray()&#39;);</span>
 134 |     | <span class='unexecuted'>        if (modifyPools.length != syncFees.length</span>
 135 |     | <span class='unexecuted'>            || syncFees.length != fillFees.length</span>
 136 |     | <span class='unexecuted'>            || fillFees.length != setFees.length) {</span>
 137 |     | <span class='unexecuted'>            require (false, &#39;MismatchedArrayLengths()&#39;);</span>
 138 |     | <span class='neutral'>        }</span>
 139 |     | <span class='unexecuted'>        uint128[] memory token0Fees = new uint128[](modifyPools.length);</span>
 140 |     | <span class='unexecuted'>        uint128[] memory token1Fees = new uint128[](modifyPools.length);</span>
 141 |     | <span class='unexecuted'>        for (uint i; i &lt; modifyPools.length;) {</span>
 142 |     | <span class='unexecuted'>            if (syncFees[i] &gt; MAX_PROTOCOL_FEE) require (false, &#39;ProtocolFeeCeilingExceeded()&#39;);</span>
 143 |     | <span class='unexecuted'>            if (fillFees[i] &gt; MAX_PROTOCOL_FEE) require (false, &#39;ProtocolFeeCeilingExceeded()&#39;);</span>
 144 |     | <span class='unexecuted'>            (</span>
 145 |     | <span class='unexecuted'>                token0Fees[i],</span>
 146 |     | <span class='unexecuted'>                token1Fees[i]</span>
 147 |     | <span class='unexecuted'>            ) = ILimitPool(modifyPools[i]).fees(</span>
 148 |     | <span class='unexecuted'>                syncFees[i],</span>
 149 |     | <span class='unexecuted'>                fillFees[i],</span>
 150 |     | <span class='unexecuted'>                setFees[i]</span>
 151 |     | <span class='neutral'>            );</span>
 152 |     | <span class='neutral'>            unchecked {</span>
 153 |     | <span class='unexecuted'>                ++i;</span>
 154 |     | <span class='neutral'>            }</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='unexecuted'>        emit ProtocolFeesModified(modifyPools, syncFees, fillFees, setFees, token0Fees, token1Fees);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>    function implementations(</span>
 160 |     | <span class='neutral'>        bytes32 key</span>
 161 |     | <span class='neutral'>    ) external view returns (</span>
 162 |     | <span class='unexecuted'>        address</span>
 163 |     | <span class='neutral'>    ) {</span>
 164 |     | <span class='unexecuted'>        return _implementations[key];</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='unexecuted'>    function tickSpacings(</span>
 168 |     | <span class='neutral'>        int16 tickSpacing</span>
 169 |     | <span class='neutral'>    ) external view returns (</span>
 170 |     | <span class='unexecuted'>        bool</span>
 171 |     | <span class='neutral'>    ) {</span>
 172 |     | <span class='unexecuted'>        return _tickSpacings[tickSpacing];</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'>    </span>
 175 |     | <span class='neutral'>    /**</span>
 176 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
 177 |     | <span class='neutral'>     */</span>
 178 |     | <span class='unexecuted'>    function _checkOwner() internal view {</span>
 179 |     | <span class='unexecuted'>        if (owner != msg.sender) require (false, &#39;OwnerOnly()&#39;);</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    /**</span>
 183 |     | <span class='neutral'>     * @dev Throws if the sender is not the feeTo.</span>
 184 |     | <span class='neutral'>     */</span>
 185 |     | <span class='unexecuted'>    function _checkFeeTo() internal view {</span>
 186 |     | <span class='unexecuted'>        if (feeTo != msg.sender) require (false, &#39;FeeToOnly()&#39;);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/kevin/Documents/GitHub/limit-pocs/contracts/utils/PoolRouter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../interfaces/IPool.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../interfaces/callbacks/IPoolsharkSwapCallback.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../libraries/utils/SafeTransfers.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;../base/structs/PoolsharkStructs.sol&#39;;</span>
  8 |     | <span class='neutral'>import &#39;../libraries/solady/LibClone.sol&#39;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract PoolRouter is</span>
 11 |     | <span class='neutral'>    IPoolsharkSwapCallback,</span>
 12 |     | <span class='neutral'>    PoolsharkStructs</span>
 13 |     | <span class='neutral'>{</span>
 14 |     | <span class='unexecuted'>    address public immutable factory;</span>
 15 |     | <span class='unexecuted'>    address public immutable implementation;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    struct SwapCallbackData {</span>
 18 |     | <span class='neutral'>        address sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    constructor(</span>
 22 |     | <span class='neutral'>        address factory_,</span>
 23 |     | <span class='neutral'>        address implementation_</span>
 24 |     | <span class='neutral'>    ) {</span>
 25 |     | <span class='unexecuted'>        factory = factory_;</span>
 26 |     | <span class='unexecuted'>        implementation = implementation_;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /// @inheritdoc IPoolsharkSwapCallback</span>
 30 |     | <span class='unexecuted'>    function poolsharkSwapCallback(</span>
 31 |     | <span class='neutral'>        int256 amount0Delta,</span>
 32 |     | <span class='neutral'>        int256 amount1Delta,</span>
 33 |     | <span class='neutral'>        bytes calldata data</span>
 34 |     | <span class='unexecuted'>    ) external override {</span>
 35 |     | <span class='unexecuted'>        PoolsharkStructs.Immutables memory constants = IPool(msg.sender).immutables();</span>
 36 |     | <span class='neutral'>        // generate key for pool</span>
 37 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
 38 |     | <span class='unexecuted'>            implementation,</span>
 39 |     | <span class='unexecuted'>            constants.token0,</span>
 40 |     | <span class='unexecuted'>            constants.token1,</span>
 41 |     | <span class='unexecuted'>            constants.tickSpacing</span>
 42 |     | <span class='neutral'>        ));</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>        // compute address</span>
 45 |     | <span class='unexecuted'>        address predictedAddress = LibClone.predictDeterministicAddress(</span>
 46 |     | <span class='unexecuted'>            implementation,</span>
 47 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 48 |     | <span class='unexecuted'>                constants.owner,</span>
 49 |     | <span class='unexecuted'>                constants.token0,</span>
 50 |     | <span class='unexecuted'>                constants.token1,</span>
 51 |     | <span class='unexecuted'>                constants.bounds.min,</span>
 52 |     | <span class='unexecuted'>                constants.bounds.max,</span>
 53 |     | <span class='unexecuted'>                constants.tickSpacing</span>
 54 |     | <span class='neutral'>            ),</span>
 55 |     | <span class='unexecuted'>            key,</span>
 56 |     | <span class='unexecuted'>            factory</span>
 57 |     | <span class='neutral'>        );</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>        // revert on sender mismatch</span>
 60 |     | <span class='unexecuted'>        if (msg.sender != predictedAddress) require(false, &#39;InvalidCallerAddress()&#39;);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>        // decode original sender</span>
 63 |     | <span class='unexecuted'>        SwapCallbackData memory _data = abi.decode(data, (SwapCallbackData));</span>
 64 |     | <span class='neutral'>        </span>
 65 |     | <span class='neutral'>        // transfer from swap caller</span>
 66 |     | <span class='unexecuted'>        if (amount0Delta &lt; 0) {</span>
 67 |     | <span class='unexecuted'>            SafeTransfers.transferInto(constants.token0, _data.sender, uint256(-amount0Delta));</span>
 68 |     | <span class='neutral'>        } else {</span>
 69 |     | <span class='unexecuted'>            SafeTransfers.transferInto(constants.token1, _data.sender, uint256(-amount1Delta));</span>
 70 |     | <span class='neutral'>        }</span>
 71 |     | <span class='neutral'>    }</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='unexecuted'>    function multiCall(</span>
 74 |     | <span class='neutral'>        address[] memory pools,</span>
 75 |     | <span class='neutral'>        SwapParams[] memory params </span>
 76 |     | <span class='neutral'>    ) external {</span>
 77 |     | <span class='unexecuted'>        if (pools.length != params.length) require(false, &#39;InputArrayLengthsMismatch()&#39;);</span>
 78 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; pools.length;) {</span>
 79 |     | <span class='unexecuted'>            params[i].callbackData = abi.encode(SwapCallbackData({sender: msg.sender}));</span>
 80 |     | <span class='unexecuted'>            IPool(pools[i]).swap(params[i]);</span>
 81 |     | <span class='neutral'>            unchecked {</span>
 82 |     | <span class='unexecuted'>                ++i;</span>
 83 |     | <span class='neutral'>            }</span>
 84 |     | <span class='neutral'>        }</span>
 85 |     | <span class='neutral'>    }</span>
 86 |     | <span class='neutral'>}</span>

</code>
<br />

