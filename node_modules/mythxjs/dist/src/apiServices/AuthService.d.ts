import { JwtTokensInterface, StatsResponse, UsersResponse } from '..';
import { Openapi, Version } from '../types';
export declare class AuthService {
    ethAddress: string;
    password: string;
    private API_URL;
    constructor(ethAddress?: string, password?: string);
    login(ethAddress?: string, password?: string): Promise<JwtTokensInterface>;
    /**
     *  Login to the API using metamask challenge result message.
     *  In order to get the object containing the message, use `getChallenge` and handle Metamask login in the frontend.
     * @param signature message.value property contained in object returned from `getChallenge`.
     * @param provider pass a provider value for the HTTP headers. If nothing is passed defaults to MetaMask
     * @return {Promise<JwtTokensInterface>}  Returns an object containing two tokens (access+refresh) that can be saved in storage.
     */
    loginWithSignature(signature: string, provider?: string): Promise<JwtTokensInterface>;
    logout(): Promise<{}>;
    getVersion(): Promise<Version>;
    getOpenApiHTML(): Promise<Openapi>;
    getOpenApiYAML(): Promise<any>;
    getStats(queryString?: string): Promise<Array<StatsResponse> | void>;
    /**
     *  Generates authentication challenge (Metamask only for now).
     *  The Metamask flow needs to be handled on the front end since MythXJS does not have Web3 dependencies.
     * @param ethAddress Ethereum address for Mythx account
     * @returns Resolves with API response or throw error
     */
    getChallenge(ethAddress?: string): Promise<any>;
    /**
     * Retrieve list of registred API users or just caller user object if no required permission.
     * @param queryString Query string for detailed list (query parameters: offset, orderBy, email, ethAddress)
     * @returns Resolves with API response or throw error
     */
    getUsers(queryString?: string): Promise<UsersResponse>;
    private isUserLoggedIn;
    private setCredentials;
}
